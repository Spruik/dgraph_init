directive @cacheControl(maxAge: Int!) on QUERY

directive @cascade(fields: [String]) on FIELD

enum AccessLevel {
  MODERATOR
  OWNER
  VIEWER
}

type AccessRight {
  forRole(filter: RoleFilter): Role
  id: ID!
  isActive: Boolean
  name: AccessRights
}

type AccessRightAggregateResult {
  count: Int
}

input AccessRightFilter {
  and: [AccessRightFilter]
  has: [AccessRightHasFilter]
  id: [ID!]
  name: AccessRights_hash
  not: AccessRightFilter
  or: [AccessRightFilter]
}

enum AccessRightHasFilter {
  forRole
  isActive
  name
}

input AccessRightPatch {
  forRole: RoleRef
  isActive: Boolean
  name: AccessRights
}

input AccessRightRef {
  forRole: RoleRef
  id: ID
  isActive: Boolean
  name: AccessRights
}

enum AccessRights {
  addACL
  addAccessRight
  addAddress
  addBillOfMaterial
  addBox
  addCarrier
  addEquipment
  addEquipmentClass
  addEquipmentNameAlias
  addEquipmentPropertyOverride
  addEquipmentReasonOverride
  addEquipmentSpecification
  addEventDefinition
  addEventLog
  addForm
  addGeneralLedgerAccount
  addInventoryHandlingPolicy
  addInventoryHandlingRule
  addJobOrder
  addJobResponse
  addMaterialAlternate
  addMaterialClass
  addMaterialDefinition
  addMaterialEquipment
  addMaterialEventRuleset
  addMaterialLot
  addMaterialSpecification
  addMaterialStateModel
  addMaterialStateTransition
  addMaterialStatus
  addMaterialSubLot
  addMaterialUnit
  addMenu
  addOperationsDefinition
  addOperationsRequest
  addOperationsSegment
  addOrder
  addOrderLine
  addOrderStartRuleset
  addPartner
  addPayloadFieldDefinition
  addPerson
  addPersonnelClass
  addPersonnelSpecification
  addProperty
  addPropertyNameAlias
  addPropertyValueAlias
  addQuantityLog
  addReason
  addReasonCategory
  addRequestState
  addRole
  addSegmentDependency
  addSegmentInvoiceSetting
  addShipment
  addShipmentItem
  addStateEventRuleset
  addTestResult
  addTestSpecification
  addTransitionEventRuleset
  addUnitOfMeasure
  addUnitOfMeasureConversion
  addUser
  addUserRole
  addWorkCalendar
  addWorkCalendarDefinitionEntry
  addWorkCalendarEntry
  addWorkflowConnection
  addWorkflowConnectionType
  addWorkflowInstance
  addWorkflowNode
  addWorkflowNodeEvent
  addWorkflowNodeInstance
  addWorkflowNodeType
  addWorkflowProperty
  addWorkflowPropertyInstance
  addWorkflowPropertyValue
  addWorkflowSpecification
  aggregateACL
  aggregateAccessRight
  aggregateAddress
  aggregateBillOfMaterial
  aggregateBox
  aggregateCarrier
  aggregateEquipment
  aggregateEquipmentClass
  aggregateEquipmentNameAlias
  aggregateEquipmentPropertyOverride
  aggregateEquipmentReasonOverride
  aggregateEquipmentSpecification
  aggregateEventDefinition
  aggregateEventLog
  aggregateForm
  aggregateGeneralLedgerAccount
  aggregateInventoryHandlingPolicy
  aggregateInventoryHandlingRule
  aggregateJobOrder
  aggregateJobResponse
  aggregateMaterialAlternate
  aggregateMaterialClass
  aggregateMaterialDefinition
  aggregateMaterialEquipment
  aggregateMaterialEventRuleset
  aggregateMaterialLot
  aggregateMaterialSpecification
  aggregateMaterialStateModel
  aggregateMaterialStateTransition
  aggregateMaterialStatus
  aggregateMaterialSubLot
  aggregateMaterialUnit
  aggregateMenu
  aggregateOperationsDefinition
  aggregateOperationsRequest
  aggregateOperationsSegment
  aggregateOrder
  aggregateOrderLine
  aggregateOrderStartRuleset
  aggregatePartner
  aggregatePayloadFieldDefinition
  aggregatePerson
  aggregatePersonnelClass
  aggregatePersonnelSpecification
  aggregateProperty
  aggregatePropertyNameAlias
  aggregatePropertyValueAlias
  aggregateQuantityLog
  aggregateReason
  aggregateReasonCategory
  aggregateRequestState
  aggregateRole
  aggregateSegmentDependency
  aggregateSegmentInvoiceSetting
  aggregateShipment
  aggregateShipmentItem
  aggregateStateEventRuleset
  aggregateTestResult
  aggregateTestSpecification
  aggregateTransitionEventRuleset
  aggregateUnitOfMeasure
  aggregateUnitOfMeasureConversion
  aggregateUser
  aggregateUserRole
  aggregateWorkCalendar
  aggregateWorkCalendarDefinitionEntry
  aggregateWorkCalendarEntry
  aggregateWorkflowConnection
  aggregateWorkflowConnectionType
  aggregateWorkflowInstance
  aggregateWorkflowNode
  aggregateWorkflowNodeEvent
  aggregateWorkflowNodeInstance
  aggregateWorkflowNodeType
  aggregateWorkflowProperty
  aggregateWorkflowPropertyInstance
  aggregateWorkflowPropertyValue
  aggregateWorkflowSpecification
  deleteACL
  deleteAccessRight
  deleteAddress
  deleteBillOfMaterial
  deleteBox
  deleteCarrier
  deleteEquipment
  deleteEquipmentClass
  deleteEquipmentNameAlias
  deleteEquipmentPropertyOverride
  deleteEquipmentReasonOverride
  deleteEquipmentSpecification
  deleteEventDefinition
  deleteEventLog
  deleteForm
  deleteGeneralLedgerAccount
  deleteInventoryHandlingPolicy
  deleteInventoryHandlingRule
  deleteJobOrder
  deleteJobResponse
  deleteMaterialAlternate
  deleteMaterialClass
  deleteMaterialDefinition
  deleteMaterialEquipment
  deleteMaterialEventRuleset
  deleteMaterialLot
  deleteMaterialSpecification
  deleteMaterialStateModel
  deleteMaterialStateTransition
  deleteMaterialStatus
  deleteMaterialSubLot
  deleteMaterialUnit
  deleteMenu
  deleteOperationsDefinition
  deleteOperationsRequest
  deleteOperationsSegment
  deleteOrder
  deleteOrderLine
  deleteOrderStartRuleset
  deletePartner
  deletePayloadFieldDefinition
  deletePerson
  deletePersonnelClass
  deletePersonnelSpecification
  deleteProperty
  deletePropertyNameAlias
  deletePropertyValueAlias
  deleteQuantityLog
  deleteReason
  deleteReasonCategory
  deleteRequestState
  deleteRole
  deleteSegmentDependency
  deleteSegmentInvoiceSetting
  deleteShipment
  deleteShipmentItem
  deleteStateEventRuleset
  deleteTestResult
  deleteTestSpecification
  deleteTransitionEventRuleset
  deleteUnitOfMeasure
  deleteUnitOfMeasureConversion
  deleteUser
  deleteUserRole
  deleteWorkCalendar
  deleteWorkCalendarDefinitionEntry
  deleteWorkCalendarEntry
  deleteWorkflowConnection
  deleteWorkflowConnectionType
  deleteWorkflowInstance
  deleteWorkflowNode
  deleteWorkflowNodeEvent
  deleteWorkflowNodeInstance
  deleteWorkflowNodeType
  deleteWorkflowProperty
  deleteWorkflowPropertyInstance
  deleteWorkflowPropertyValue
  deleteWorkflowSpecification
  getACL
  getAccessRight
  getAddress
  getBillOfMaterial
  getBox
  getCarrier
  getEquipment
  getEquipmentClass
  getEquipmentNameAlias
  getEquipmentPropertyOverride
  getEquipmentReasonOverride
  getEquipmentSpecification
  getEventDefinition
  getEventLog
  getForm
  getGeneralLedgerAccount
  getInventoryHandlingPolicy
  getInventoryHandlingRule
  getJobOrder
  getJobResponse
  getMaterialAlternate
  getMaterialClass
  getMaterialDefinition
  getMaterialEquipment
  getMaterialEventRuleset
  getMaterialLot
  getMaterialSpecification
  getMaterialStateModel
  getMaterialStateTransition
  getMaterialStatus
  getMaterialSubLot
  getMaterialUnit
  getMenu
  getOperationsDefinition
  getOperationsRequest
  getOperationsSegment
  getOrder
  getOrderLine
  getOrderStartRuleset
  getPartner
  getPayloadFieldDefinition
  getPerson
  getPersonnelClass
  getPersonnelSpecification
  getProperty
  getPropertyNameAlias
  getPropertyValueAlias
  getQuantityLog
  getReason
  getReasonCategory
  getRequestState
  getRole
  getSegmentDependency
  getSegmentInvoiceSetting
  getShipment
  getShipmentItem
  getStateEventRuleset
  getTestResult
  getTestSpecification
  getTransitionEventRuleset
  getUnitOfMeasure
  getUnitOfMeasureConversion
  getUser
  getUserRole
  getWorkCalendar
  getWorkCalendarDefinitionEntry
  getWorkCalendarEntry
  getWorkflowConnection
  getWorkflowConnectionType
  getWorkflowInstance
  getWorkflowNode
  getWorkflowNodeEvent
  getWorkflowNodeInstance
  getWorkflowNodeType
  getWorkflowProperty
  getWorkflowPropertyInstance
  getWorkflowPropertyValue
  getWorkflowSpecification
  isAdmin
  queryACL
  queryAccessRight
  queryAddress
  queryBillOfMaterial
  queryBox
  queryCarrier
  queryEquipment
  queryEquipmentClass
  queryEquipmentNameAlias
  queryEquipmentPropertyOverride
  queryEquipmentReasonOverride
  queryEquipmentSpecification
  queryEventDefinition
  queryEventLog
  queryForm
  queryGeneralLedgerAccount
  queryInventoryHandlingPolicy
  queryInventoryHandlingRule
  queryJobOrder
  queryJobResponse
  queryMaterialAlternate
  queryMaterialClass
  queryMaterialDefinition
  queryMaterialEquipment
  queryMaterialEventRuleset
  queryMaterialLot
  queryMaterialSpecification
  queryMaterialStateModel
  queryMaterialStateTransition
  queryMaterialStatus
  queryMaterialSubLot
  queryMaterialUnit
  queryMenu
  queryOperationsDefinition
  queryOperationsRequest
  queryOperationsSegment
  queryOrder
  queryOrderLine
  queryOrderStartRuleset
  queryPartner
  queryPayloadFieldDefinition
  queryPerson
  queryPersonnelClass
  queryPersonnelSpecification
  queryProperty
  queryPropertyNameAlias
  queryPropertyValueAlias
  queryQuantityLog
  queryReason
  queryReasonCategory
  queryRequestState
  queryRole
  querySegmentDependency
  querySegmentInvoiceSetting
  queryShipment
  queryShipmentItem
  queryStateEventRuleset
  queryTestResult
  queryTestSpecification
  queryTransitionEventRuleset
  queryUnitOfMeasure
  queryUnitOfMeasureConversion
  queryUser
  queryUserRole
  queryWorkCalendar
  queryWorkCalendarDefinitionEntry
  queryWorkCalendarEntry
  queryWorkflowConnection
  queryWorkflowConnectionType
  queryWorkflowInstance
  queryWorkflowNode
  queryWorkflowNodeEvent
  queryWorkflowNodeInstance
  queryWorkflowNodeType
  queryWorkflowProperty
  queryWorkflowPropertyInstance
  queryWorkflowPropertyValue
  queryWorkflowSpecification
  updateACL
  updateAccessRight
  updateAddress
  updateBillOfMaterial
  updateBox
  updateCarrier
  updateEquipment
  updateEquipmentClass
  updateEquipmentNameAlias
  updateEquipmentPropertyOverride
  updateEquipmentReasonOverride
  updateEquipmentSpecification
  updateEventDefinition
  updateEventLog
  updateForm
  updateGeneralLedgerAccount
  updateInventoryHandlingPolicy
  updateInventoryHandlingRule
  updateJobOrder
  updateJobResponse
  updateMaterialAlternate
  updateMaterialClass
  updateMaterialDefinition
  updateMaterialEquipment
  updateMaterialEventRuleset
  updateMaterialLot
  updateMaterialSpecification
  updateMaterialStateModel
  updateMaterialStateTransition
  updateMaterialStatus
  updateMaterialSubLot
  updateMaterialUnit
  updateMenu
  updateOperationsDefinition
  updateOperationsRequest
  updateOperationsSegment
  updateOrder
  updateOrderLine
  updateOrderStartRuleset
  updatePartner
  updatePayloadFieldDefinition
  updatePerson
  updatePersonnelClass
  updatePersonnelSpecification
  updateProperty
  updatePropertyNameAlias
  updatePropertyValueAlias
  updateQuantityLog
  updateReason
  updateReasonCategory
  updateRequestState
  updateRole
  updateSegmentDependency
  updateSegmentInvoiceSetting
  updateShipment
  updateShipmentItem
  updateStateEventRuleset
  updateTestResult
  updateTestSpecification
  updateTransitionEventRuleset
  updateUnitOfMeasure
  updateUnitOfMeasureConversion
  updateUser
  updateUserRole
  updateWorkCalendar
  updateWorkCalendarDefinitionEntry
  updateWorkCalendarEntry
  updateWorkflowConnection
  updateWorkflowConnectionType
  updateWorkflowInstance
  updateWorkflowNode
  updateWorkflowNodeEvent
  updateWorkflowNodeInstance
  updateWorkflowNodeType
  updateWorkflowProperty
  updateWorkflowPropertyInstance
  updateWorkflowPropertyValue
  updateWorkflowSpecification
}

input AccessRights_hash {
  eq: AccessRights
  in: [AccessRights]
}

type ACL {
  grants(filter: RoleFilter): Role
  id: ID!
  isActive: Boolean
  level: AccessLevel
}

type ACLAggregateResult {
  count: Int
}

input ACLFilter {
  and: [ACLFilter]
  has: [ACLHasFilter]
  id: [ID!]
  isActive: Boolean
  not: ACLFilter
  or: [ACLFilter]
}

enum ACLHasFilter {
  grants
  isActive
  level
}

input ACLPatch {
  grants: RoleRef
  isActive: Boolean
  level: AccessLevel
}

input ACLRef {
  grants: RoleRef
  id: ID
  isActive: Boolean
  level: AccessLevel
}

input AddAccessRightInput {
  forRole: RoleRef
  isActive: Boolean
  name: AccessRights
}

type AddAccessRightPayload {
  accessRight(filter: AccessRightFilter, first: Int, offset: Int): [AccessRight]
  numUids: Int
}

input AddACLInput {
  grants: RoleRef
  isActive: Boolean
  level: AccessLevel
}

type AddACLPayload {
  aCL(filter: ACLFilter, first: Int, offset: Int): [ACL]
  numUids: Int
}

input AddAddressInput {
  city: String
  countryCode: String
  isActive: Boolean
  name: String
  number: String
  postCode: String
  state: String
  street1: String
  street2: String
}

type AddAddressPayload {
  address(
    filter: AddressFilter
    first: Int
    offset: Int
    order: AddressOrder
  ): [Address]
  numUids: Int
}

input AddBillOfMaterialInput {
  description: String
  isActive: Boolean
  materialSpecifications: [MaterialSpecificationRef]
  name: String!
  operationsDefinition: OperationsDefinitionRef
  version: String!
}

type AddBillOfMaterialPayload {
  billOfMaterial(
    filter: BillOfMaterialFilter
    first: Int
    offset: Int
    order: BillOfMaterialOrder
  ): [BillOfMaterial]
  numUids: Int
}

input AddBoxInput {
  name: String
  sizeDepthCm: Int
  sizeHeightCm: Int
  sizeWidthCm: Int
}

type AddBoxPayload {
  box(filter: BoxFilter, first: Int, offset: Int, order: BoxOrder): [Box]
  numUids: Int
}

input AddCarrierInput {
  barcodeImage: String
  code: String!
  isActive: Boolean
  owner: PartnerRef
  status: MaterialStatusRef!
  storageLocation: EquipmentRef!
}

type AddCarrierPayload {
  carrier(
    filter: CarrierFilter
    first: Int
    offset: Int
    order: CarrierOrder
  ): [Carrier]
  numUids: Int
}

input AddDashboardConfigInput {
  isActive: Boolean
  name: String!
  panels: [DashboardPanelConfigRef]
}

type AddDashboardConfigPayload {
  dashboardConfig(
    filter: DashboardConfigFilter
    first: Int
    offset: Int
    order: DashboardConfigOrder
  ): [DashboardConfig]
  numUids: Int
}

input AddDashboardPanelConfigInput {
  dashboard: DashboardConfigRef
  h: Int
  properties: [DashboardWidgetConfigPropertyRef]
  w: Int
  widgetName: String
  x: Int
  y: Int
}

type AddDashboardPanelConfigPayload {
  dashboardPanelConfig(
    filter: DashboardPanelConfigFilter
    first: Int
    offset: Int
    order: DashboardPanelConfigOrder
  ): [DashboardPanelConfig]
  numUids: Int
}

input AddDashboardWidgetConfigPropertyInput {
  key: String!
  panel: DashboardPanelConfigRef
  value: String!
}

type AddDashboardWidgetConfigPropertyPayload {
  dashboardWidgetConfigProperty(
    filter: DashboardWidgetConfigPropertyFilter
    first: Int
    offset: Int
    order: DashboardWidgetConfigPropertyOrder
  ): [DashboardWidgetConfigProperty]
  numUids: Int
}

input AddDeliveryInput {
  dateTime: DateTime!
  location: EquipmentRef
  operator: UserRef
  partner: PartnerRef
  shipments: [ShipmentRef]
  transportCompany: TransportCompany
  transportCompanyDeliveryId: String
}

type AddDeliveryPayload {
  delivery(
    filter: DeliveryFilter
    first: Int
    offset: Int
    order: DeliveryOrder
  ): [Delivery]
  numUids: Int
}

input AddEquipmentActualInput {
  equipment: EquipmentRef
  isActive: Boolean
  jobResponse: JobResponseRef!
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type AddEquipmentActualPayload {
  equipmentActual(
    filter: EquipmentActualFilter
    first: Int
    offset: Int
    order: EquipmentActualOrder
  ): [EquipmentActual]
  numUids: Int
}

input AddEquipmentClassInput {
  addressTemplate: String
  children: [EquipmentClassRef]
  dashboardConfig: DashboardConfigRef
  description: String
  displayName: String
  equipmentLevel: EquipmentElementLevel
  equipmentSpecifications: [EquipmentSpecificationRef]
  equipments: [EquipmentRef]
  eventDefinitions: [EventDefinitionRef]
  image: String
  isActive: Boolean
  label: String
  name: String!
  parent: EquipmentClassRef
  properties: [PropertyRef]
  reasons: [ReasonRef]
}

type AddEquipmentClassPayload {
  equipmentClass(
    filter: EquipmentClassFilter
    first: Int
    offset: Int
    order: EquipmentClassOrder
  ): [EquipmentClass]
  numUids: Int
}

input AddEquipmentInput {
  addressTemplate: String
  allowAdhocWorklog: Boolean
  carriers: [CarrierRef]
  children: [EquipmentRef]
  dataProvider: DataProvider
  dataProviderConnection: String
  description: String
  displayName: String
  equipmentActual: [EquipmentActualRef]
  equipmentClass: EquipmentClassRef
  equipmentLevel: EquipmentElementLevel
  erpAssetID: String
  events: [EventLogRef]
  inflows: [EquipmentRelationRef]
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  isActive: Boolean
  jobOrders: [JobOrderRef]
  jobResponses: [JobResponseRef]
  label: String
  materialSubLots: [MaterialSubLotRef]
  mpmAutoIdentMatchSource: String
  mpmEnableAutoIdentMatching: Boolean
  mpmEnableCallMaintenanceEvent: Boolean
  mpmEnableJobInterlock: Boolean
  mpmEnableMaintenanceHandover: Boolean
  mpmEnableManualBreak: Boolean
  mpmEnableManualPlannedMaint: Boolean
  mpmEnableManualShiftEnd: Boolean
  mpmEnableManualShiftStart: Boolean
  mpmEnableORCBlockNextOrder: Boolean
  mpmEnableORCRevokePermissive: Boolean
  mpmEnableORCWarning: Boolean
  mpmEnableSetupCloseDetection: Boolean
  mpmEnableSetupStartDetection: Boolean
  mpmORCRevokePermissiveTrigger: mpmORCRevokeTriggers
  mpmORCWarnTrigger: mpmORCWarnTriggers
  mpmPermissiveOutputName: String
  name: String!
  ocsChosenStopTime: DateTime
  ocsEnabled: Boolean
  ocsPageState: String
  ocsWorkflowSelector: String
  operationsRequests: [OperationsRequestRef]
  orders: [OrderRef]
  outflows: [EquipmentRelationRef]
  parent: EquipmentRef
  properties: [PropertyRef]
  propertyNameAliases: [PropertyNameAliasRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  quantities: [QuantityLogRef]
  reasonOverrides: [EquipmentReasonOverrideRef]
  reasons: [ReasonRef]
  shipmentItems: [ShipmentItemRef]
  shipments: [ShipmentRef]
  timeZoneName: String
  userRoles: [UserRoleRef]
  workCalendar: WorkCalendarRef
  workSpecifications: [EquipmentSpecificationRef]
  workflowInstances: [WorkflowInstanceRef]
}

input AddEquipmentNameAliasInput {
  alias: String!
  equipment: EquipmentRef!
  system: String!
}

type AddEquipmentNameAliasPayload {
  equipmentNameAlias(
    filter: EquipmentNameAliasFilter
    first: Int
    offset: Int
    order: EquipmentNameAliasOrder
  ): [EquipmentNameAlias]
  numUids: Int
}

type AddEquipmentPayload {
  equipment(
    filter: EquipmentFilter
    first: Int
    offset: Int
    order: EquipmentOrder
  ): [Equipment]
  numUids: Int
}

input AddEquipmentPropertyOverrideInput {
  address: String
  equipment: EquipmentRef!
  expression: String
  ignore: Boolean
  isActive: Boolean
  property: PropertyRef!
  storeHistory: Boolean
  value: String
}

type AddEquipmentPropertyOverridePayload {
  equipmentPropertyOverride(
    filter: EquipmentPropertyOverrideFilter
    first: Int
    offset: Int
    order: EquipmentPropertyOverrideOrder
  ): [EquipmentPropertyOverride]
  numUids: Int
}

input AddEquipmentReasonOverrideInput {
  equipment: EquipmentRef
  ignore: Boolean
  isActive: Boolean
  reason: ReasonRef
  standardValue: Float
}

type AddEquipmentReasonOverridePayload {
  equipmentReasonOverride(
    filter: EquipmentReasonOverrideFilter
    first: Int
    offset: Int
    order: EquipmentReasonOverrideOrder
  ): [EquipmentReasonOverride]
  numUids: Int
}

input AddEquipmentRelationInput {
  from: EquipmentRef!
  isActive: Boolean
  to: EquipmentRef
  type: EquipmentRelationshipType!
}

type AddEquipmentRelationPayload {
  equipmentRelation(
    filter: EquipmentRelationFilter
    first: Int
    offset: Int
  ): [EquipmentRelation]
  numUids: Int
}

input AddEquipmentSpecificationInput {
  description: String
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

type AddEquipmentSpecificationPayload {
  equipmentSpecification(
    filter: EquipmentSpecificationFilter
    first: Int
    offset: Int
    order: EquipmentSpecificationOrder
  ): [EquipmentSpecification]
  numUids: Int
}

input AddEventDefinitionInput {
  delayOption: Boolean
  delayTime: Int
  equipmentClass: EquipmentClassRef
  isActive: Boolean
  materialEventRuleset: MaterialEventRulesetRef
  messageClass: MessageClass!
  name: String!
  orderStartRuleset: OrderStartRulesetRef
  payloadFields: [PayloadFieldDefinitionRef]
  payloadProperties: [PropertyRef]
  stateEventRuleset: StateEventRulesetRef
  transitionEventRuleset: TransitionEventRulesetRef
  triggerExpression: String!
  triggerProperties: [PropertyRef]
}

type AddEventDefinitionPayload {
  eventDefinition(
    filter: EventDefinitionFilter
    first: Int
    offset: Int
    order: EventDefinitionOrder
  ): [EventDefinition]
  numUids: Int
}

input AddEventLogInput {
  comments: String
  duration: Float
  endDateTime: DateTime
  equipment: EquipmentRef
  isActive: Boolean
  jobResponse: JobResponseRef!
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: UnitOfMeasureRef
  startDateTime: DateTime
}

type AddEventLogPayload {
  eventLog(
    filter: EventLogFilter
    first: Int
    offset: Int
    order: EventLogOrder
  ): [EventLog]
  numUids: Int
}

input AddFormInput {
  isActive: Boolean
  jsonSchema: String
  name: String!
  uiSchema: String
  workflowNodes: [WorkflowNodeRef]
}

type AddFormPayload {
  form(filter: FormFilter, first: Int, offset: Int, order: FormOrder): [Form]
  numUids: Int
}

input AddGeneralLedgerAccountInput {
  code: String!
  name: String
  type: String
}

type AddGeneralLedgerAccountPayload {
  generalLedgerAccount(
    filter: GeneralLedgerAccountFilter
    first: Int
    offset: Int
    order: GeneralLedgerAccountOrder
  ): [GeneralLedgerAccount]
  numUids: Int
}

input AddInterfaceMessageLogInput {
  component: String
  createdDateTime: DateTime
  errorMessage: String
  level: String
  message: String
  payload: String
  status: String
}

type AddInterfaceMessageLogPayload {
  interfaceMessageLog(
    filter: InterfaceMessageLogFilter
    first: Int
    offset: Int
    order: InterfaceMessageLogOrder
  ): [InterfaceMessageLog]
  numUids: Int
}

input AddInventoryActualInput {
  carrier: ExtCarrierRef
  isActive: Boolean
  jobResponse: ExtJobResponseRef!
  materialDefinition: ExtMaterialDefinitionRef
  materialLot: ExtMaterialLotRef
  materialStatus: ExtMaterialStatusRef
  materialSubLot: ExtMaterialSubLotRef
  materialUse: MaterialUse
  quantity: Float
  quantityUoM: ExtUnitOfMeasureRef
}

type AddInventoryActualPayload {
  carrier: Carrier
  isActive: Boolean
  jobResponse: JobResponse!
  materialDefinition: MaterialDefinition
  materialLot: MaterialLot
  materialStatus: MaterialStatus
  materialSubLot: MaterialSubLot
  materialUse: MaterialUse
  quantity: Float
  quantityUoM: UnitOfMeasure
}

input AddInventoryHandlingPolicyInput {
  isActive: Boolean
  materialClass: [MaterialClassRef]
  name: String!
  rules: [InventoryHandlingRuleRef]
  trackByCarrier: Boolean
  trackBySerialNumber: Boolean
  verifySerialNumberOnPacking: Boolean
  verifySerialNumberOnReceipt: Boolean
}

type AddInventoryHandlingPolicyPayload {
  inventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
    first: Int
    offset: Int
    order: InventoryHandlingPolicyOrder
  ): [InventoryHandlingPolicy]
  numUids: Int
}

input AddInventoryHandlingRuleInput {
  customer: PartnerRef!
  inventoryHandlingPolicy: InventoryHandlingPolicyRef!
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
  stateModel: MaterialStateModelRef!
  stockType: StockType!
  warehouse: [EquipmentRef!]!
}

type AddInventoryHandlingRulePayload {
  inventoryHandlingRule(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  numUids: Int
}

input AddInventoryHoldingPolicyInput {
  inventoryHandlingRule: InventoryHandlingRuleRef!
  inventoryMax: Int
  inventoryMin: Int
  isActive: Boolean
  material: MaterialDefinitionRef!
  materialStatus: MaterialStatusRef!
}

type AddInventoryHoldingPolicyPayload {
  inventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    first: Int
    offset: Int
    order: InventoryHoldingPolicyOrder
  ): [InventoryHoldingPolicy]
  numUids: Int
}

input AddJobOrderDependencyInput {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM: UnitOfMeasureRef
  from: JobOrderRef!
  isActive: Boolean
  segmentDependency: SegmentDependencyRef
  to: JobOrderRef!
}

type AddJobOrderDependencyPayload {
  jobOrderDependency(
    filter: JobOrderDependencyFilter
    first: Int
    offset: Int
    order: JobOrderDependencyOrder
  ): [JobOrderDependency]
  numUids: Int
}

input AddJobOrderDispatchStateModelInput {
  allowedTransition: [DispatchStatus]
  fromStatus: DispatchStatus!
}

type AddJobOrderDispatchStateModelPayload {
  jobOrderDispatchStateModel(
    filter: JobOrderDispatchStateModelFilter
    first: Int
    offset: Int
  ): [JobOrderDispatchStateModel]
  numUids: Int
}

input AddJobOrderInput {
  children: [JobOrderRef]
  createdDateTime: DateTime
  description: String
  dispatchStatus: DispatchStatus
  duration: Float
  durationUoM: UnitOfMeasureRef
  equipment: EquipmentRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  hierarchyScope: String
  inflows: [JobOrderDependencyRef]
  isActive: Boolean
  jobOrderNotes: [JobOrderNoteRef]
  jobResponses: [JobResponseRef]
  materialSpecifications: [MaterialSpecificationRef]
  name: String!
  next: [JobOrderRef]
  operationsRequest: OperationsRequestRef
  operationsSegment: OperationsSegmentRef
  outflows: [JobOrderDependencyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  parent: JobOrderRef
  personnelSpecifications: [PersonnelSpecificationRef]
  previous: [JobOrderRef]
  priority: Int
  properties: [PropertyRef]
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  scheduledDuration: Float
  scheduledEndDateTime: DateTime
  scheduledStartDateTime: DateTime
  version: String
  workDefinitionType: String
  workType: WorkType
}

input AddJobOrderNoteInput {
  comment: String
  createdBy: UserRef
  createdDateTime: DateTime
  editedDateTime: DateTime
  isActive: Boolean
  jobOrder: JobOrderRef
  modifiedBy: UserRef
}

type AddJobOrderNotePayload {
  jobOrderNote(
    filter: JobOrderNoteFilter
    first: Int
    offset: Int
    order: JobOrderNoteOrder
  ): [JobOrderNote]
  numUids: Int
}

type AddJobOrderPayload {
  jobOrder(
    filter: JobOrderFilter
    first: Int
    offset: Int
    order: JobOrderOrder
  ): [JobOrder]
  numUids: Int
}

input AddJobResponseInput {
  actualDuration: Float
  createdDateTime: DateTime
  endDateTime: DateTime
  equipment: EquipmentRef
  equipmentActual: [EquipmentActualRef]
  events: [EventLogRef]
  isActive: Boolean
  jobOrder: JobOrderRef
  materialActual: [MaterialActualRef]
  modifiedDateTime: DateTime
  operator: UserRef
  personnelActual: [PersonnelActualRef]
  productionDate: String
  properties: [PropertyRef]
  quantities: [QuantityLogRef]
  startDateTime: DateTime
}

type AddJobResponsePayload {
  jobResponse(
    filter: JobResponseFilter
    first: Int
    offset: Int
    order: JobResponseOrder
  ): [JobResponse]
  numUids: Int
}

input AddLibreServiceInput {
  heartbeat: DateTime
  name: String!
}

type AddLibreServicePayload {
  libreService(
    filter: LibreServiceFilter
    first: Int
    offset: Int
    order: LibreServiceOrder
  ): [LibreService]
  numUids: Int
}

input AddMaterialActualInput {
  isActive: Boolean
  jobResponse: JobResponseRef!
  materialDefinition: MaterialDefinitionRef
  materialLot: MaterialLotRef
  materialSubLot: MaterialSubLotRef
  materialUse: MaterialUse
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type AddMaterialActualPayload {
  materialActual(
    filter: MaterialActualFilter
    first: Int
    offset: Int
    order: MaterialActualOrder
  ): [MaterialActual]
  numUids: Int
}

input AddMaterialAlternateInput {
  alternateMaterial: MaterialDefinitionRef!
  effectiveDateTime: DateTime!
  isActive: Boolean
  material: MaterialDefinitionRef!
  priorityOrder: Int!
}

type AddMaterialAlternatePayload {
  materialAlternate(
    filter: MaterialAlternateFilter
    first: Int
    offset: Int
    order: MaterialAlternateOrder
  ): [MaterialAlternate]
  numUids: Int
}

input AddMaterialClassInput {
  children: [MaterialClassRef]
  code: String!
  description: String
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  isActive: Boolean
  parent: MaterialClassRef
  properties: [PropertyRef]
  scheduleSortOrder: Int
}

type AddMaterialClassPayload {
  materialClass(
    filter: MaterialClassFilter
    first: Int
    offset: Int
    order: MaterialClassOrder
  ): [MaterialClass]
  numUids: Int
}

input AddMaterialDefinitionInput {
  OrderLines: [OrderLineRef]
  alternates: [MaterialAlternateRef]
  baseUnitOfMeasure: UnitOfMeasureRef!
  code: String!
  customerMaterialCode: String
  description: String
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
  lots: [MaterialLotRef]
  materialActual: [MaterialActualRef]
  materialClass: MaterialClassRef
  name: String
  operationsDefinitions: [OperationsDefinitionRef]
  parameterSpecifications: [ParameterSpecificationRef]
  properties: [PropertyRef]
  scheduleSortOrder: Int
  serialMask: String
  shipmentItems: [ShipmentItemRef]
  sublots: [MaterialSubLotRef]
  supplier: String
  transferrableMaterials: [MaterialDefinitionRef]
  units: [MaterialUnitRef]
  uomConversions: [UnitOfMeasureConversionRef]
  value: Float
  valueCurrency: String
  weightKG: Float
  workSpecifications: [MaterialSpecificationRef]
}

type AddMaterialDefinitionPayload {
  materialDefinition(
    filter: MaterialDefinitionFilter
    first: Int
    offset: Int
    order: MaterialDefinitionOrder
  ): [MaterialDefinition]
  numUids: Int
}

input AddMaterialEventRulesetInput {
  eventDefs: [EventDefinitionRef]
  name: String!
  segment: OperationsSegmentRef
  targetMaterial: String!
  targetMaterialOp: String!
  triggerWhen: [RulesetTriggerOption]
}

type AddMaterialEventRulesetPayload {
  materialEventRuleset(
    filter: MaterialEventRulesetFilter
    first: Int
    offset: Int
    order: MaterialEventRulesetOrder
  ): [MaterialEventRuleset]
  numUids: Int
}

input AddMaterialLotInput {
  childSubLot: [MaterialSubLotRef]
  code: String!
  dataType: DataType
  description: String
  isActive: Boolean
  isAssembledFromLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  material: MaterialDefinitionRef!
  materialActual: [MaterialActualRef]
  properties: [PropertyRef]
  quantity: String
  unitOfMeasure: UnitOfMeasureRef
}

type AddMaterialLotPayload {
  materialLot(
    filter: MaterialLotFilter
    first: Int
    offset: Int
    order: MaterialLotOrder
  ): [MaterialLot]
  numUids: Int
}

input AddMaterialSpecificationInput {
  allowedStates: [MaterialStatusRef]
  backFlushFromLocation: EquipmentRef
  billOfMaterial: BillOfMaterialRef
  description: String
  isActive: Boolean
  isBackFlushed: Boolean
  isTracked: Boolean
  jobOrder: JobOrderRef
  material: MaterialDefinitionRef
  materialClass: MaterialClassRef
  materialUse: MaterialUse!
  operationsSegment: OperationsSegmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

type AddMaterialSpecificationPayload {
  materialSpecification(
    filter: MaterialSpecificationFilter
    first: Int
    offset: Int
    order: MaterialSpecificationOrder
  ): [MaterialSpecification]
  numUids: Int
}

input AddMaterialStateModelInput {
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  isActive: Boolean
  name: String!
  states: [MaterialStateTransitionRef!]!
}

type AddMaterialStateModelPayload {
  materialStateModel(
    filter: MaterialStateModelFilter
    first: Int
    offset: Int
    order: MaterialStateModelOrder
  ): [MaterialStateModel]
  numUids: Int
}

input AddMaterialStateTransitionInput {
  canPack: Boolean
  canReceive: Boolean
  isPlanned: Boolean
  status: MaterialStatusRef!
  to: [MaterialStatusRef]
}

type AddMaterialStateTransitionPayload {
  materialStateTransition(
    filter: MaterialStateTransitionFilter
    first: Int
    offset: Int
  ): [MaterialStateTransition]
  numUids: Int
}

input AddMaterialStatusInput {
  code: String!
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
}

type AddMaterialStatusPayload {
  materialStatus(
    filter: MaterialStatusFilter
    first: Int
    offset: Int
    order: MaterialStatusOrder
  ): [MaterialStatus]
  numUids: Int
}

input AddMaterialSubLotInput {
  childSubLot: MaterialSubLotRef
  code: String!
  dataType: DataType
  description: String
  isActive: Boolean
  isAssembledFromLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  material: MaterialDefinitionRef!
  materialActual: [MaterialActualRef]
  parentLot: MaterialLotRef
  parentSubLot: MaterialSubLotRef
  properties: [PropertyRef]
  quantity: String
  status: MaterialStatusRef!
  storageLocation: EquipmentRef
  unitOfMeasure: UnitOfMeasureRef
}

type AddMaterialSubLotPayload {
  materialSubLot(
    filter: MaterialSubLotFilter
    first: Int
    offset: Int
    order: MaterialSubLotOrder
  ): [MaterialSubLot]
  numUids: Int
}

input AddMaterialUnitInput {
  isActive: Boolean
  material: MaterialDefinitionRef!
  properties: [PropertyRef]
  serialNumber: String!
}

type AddMaterialUnitPayload {
  materialUnit(
    filter: MaterialUnitFilter
    first: Int
    offset: Int
    order: MaterialUnitOrder
  ): [MaterialUnit]
  numUids: Int
}

input AddMenuInput {
  access: [RoleRef!]!
  children: [MenuRef!]
  icon: String
  isPage: Boolean!
  isSection: Boolean!
  label: String!
  menuPage: String
  orderNumber: Int
  parent: MenuRef
}

type AddMenuPayload {
  menu(filter: MenuFilter, first: Int, offset: Int, order: MenuOrder): [Menu]
  numUids: Int
}

input AddOperationsDefinitionInput {
  billOfMaterial: BillOfMaterialRef
  description: String
  hierarchyScope: String
  isActive: Boolean
  material: MaterialDefinitionRef
  name: String!
  operationsType: WorkType!
  segments: [OperationsSegmentRef]
  version: String
}

type AddOperationsDefinitionPayload {
  numUids: Int
  operationsDefinition(
    filter: OperationsDefinitionFilter
    first: Int
    offset: Int
    order: OperationsDefinitionOrder
  ): [OperationsDefinition]
}

input AddOperationsRequestInput {
  code: String!
  equipment: EquipmentRef
  isActive: Boolean
  jobOrders: [JobOrderRef]
  operationsDefinition: OperationsDefinitionRef!
  operationsType: WorkType!
  plannedEndDateTime: DateTime
  plannedStartDateTime: DateTime
  priority: String
  properties: [PropertyRef]
  quantity: Float!
  quantityUoM: UnitOfMeasureRef!
  requestState: RequestStateRef!
}

type AddOperationsRequestPayload {
  numUids: Int
  operationsRequest(
    filter: OperationsRequestFilter
    first: Int
    offset: Int
    order: OperationsRequestOrder
  ): [OperationsRequest]
}

input AddOperationsSegmentInput {
  children: [OperationsSegmentRef]
  costAmountDirectLabourRate: Float
  costAmountFixedOverhead: Float
  costAmountVariableOverhead: Float
  costDriverFixedOverhead: CostDriver
  description: String
  duration: Float
  durationUoM: UnitOfMeasureRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  glAccountDirectLabour: String
  glAccountFixedOverhead: String
  glAccountVariableOverhead: String
  glAccountWIP: String
  glAccountWIPInvoice: String
  hierarchyScope: String
  inflows: [SegmentDependencyRef]
  invoiceSettings: [SegmentInvoiceSettingRef]
  isActive: Boolean
  jobOrders: [JobOrderRef]
  materialEventRuleset: MaterialEventRulesetRef
  materialSpecifications: [MaterialSpecificationRef]
  mpmAutoIdentMatchCode: PropertyRef
  mpmChangeoverFamily: String
  mpmEnableAutoIdent: Boolean
  mpmEnableSmartChangeover: Boolean
  mpmIdealChangeoverTime: Float
  mpmIdealSetupTime: Float
  mpmPlanRate: Float
  mpmThresholdMicrostopDuration: Float
  mpmThresholdRunDuration: Float
  mpmThresholdRunRate: Float
  mpmThresholdSlowDuration: Float
  mpmThresholdSlowRate: Float
  name: String!
  operationsDefinition: OperationsDefinitionRef
  orderStartRuleset: OrderStartRulesetRef
  outflows: [SegmentDependencyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  parent: OperationsSegmentRef
  personnelSpecifications: [PersonnelSpecificationRef]
  positionX: Int
  positionY: Int
  stateEventRuleset: StateEventRulesetRef
  type: SegmentType
  uiComponent: String
  version: String
  workDefinitionType: String
  workType: WorkType
}

type AddOperationsSegmentPayload {
  numUids: Int
  operationsSegment(
    filter: OperationsSegmentFilter
    first: Int
    offset: Int
    order: OperationsSegmentOrder
  ): [OperationsSegment]
}

input AddOrderInput {
  createdDateTime: DateTime
  customerOrderNumber: String
  customerReference: String
  deliveryTerms: IncoTerms
  invoiceFromPartner: PartnerRef
  invoiceToPartner: PartnerRef
  isActive: Boolean
  lines: [OrderLineRef]
  notes: String
  orderType: OrderType!
  shipFromPartner: PartnerRef
  shipToPartner: PartnerRef
  shipments: [ShipmentRef]
  status: OrderStatus!
  warehouse: EquipmentRef
}

input AddOrderLineInput {
  defectiveSerialNumbers: String
  isActive: Boolean
  isReturn: Boolean
  material: MaterialDefinitionRef!
  order: OrderRef
  orderLineNumber: Int!
  quantity: Int!
  workflowInstance: WorkflowInstanceRef
}

type AddOrderLinePayload {
  numUids: Int
  orderLine(
    filter: OrderLineFilter
    first: Int
    offset: Int
    order: OrderLineOrder
  ): [OrderLine]
}

type AddOrderPayload {
  numUids: Int
  order(
    filter: OrderFilter
    first: Int
    offset: Int
    order: OrderOrder
  ): [Order]
}

input AddOrderStartRulesetInput {
  eventDefs: [EventDefinitionRef]
  name: String!
  segment: OperationsSegmentRef
}

type AddOrderStartRulesetPayload {
  numUids: Int
  orderStartRuleset(
    filter: OrderStartRulesetFilter
    first: Int
    offset: Int
    order: OrderStartRulesetOrder
  ): [OrderStartRuleset]
}

input AddParameterSpecificationInput {
  isActive: Boolean
  jobOrder: JobOrderRef
  material: MaterialDefinitionRef
  operationsSegment: OperationsSegmentRef
  property: PropertyRef!
  valueDefault: String
  valueLowerControlLimit: Float
  valueLowerSpecLimit: Float
  valueSetPoint: String
  valueUpperControlLimit: Float
  valueUpperSpecLimit: Float
}

type AddParameterSpecificationPayload {
  numUids: Int
  parameterSpecification(
    filter: ParameterSpecificationFilter
    first: Int
    offset: Int
    order: ParameterSpecificationOrder
  ): [ParameterSpecification]
}

input AddPartnerInput {
  billingAddress: AddressRef
  carriers: [CarrierRef]
  companyCode: String!
  contactEmail: String
  contactName: String
  contactPhone: String
  fromOrders: [OrderRef]
  isActive: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  name: String
  registrationNumber: String
  shippingAccounts: [ShippingAccountRef]
  shippingAddress: AddressRef
  toOrders: [OrderRef]
  vatNumber: String
}

type AddPartnerPayload {
  numUids: Int
  partner(
    filter: PartnerFilter
    first: Int
    offset: Int
    order: PartnerOrder
  ): [Partner]
}

input AddPayloadFieldDefinitionInput {
  expression: String!
  fieldType: PayloadFieldType
  isActive: Boolean
  name: String!
}

type AddPayloadFieldDefinitionPayload {
  numUids: Int
  payloadFieldDefinition(
    filter: PayloadFieldDefinitionFilter
    first: Int
    offset: Int
    order: PayloadFieldDefinitionOrder
  ): [PayloadFieldDefinition]
}

input AddPersonInput {
  description: String
  isActive: Boolean
  memberOf: [PersonnelClassRef]
  name: String!
  personnelActual: [PersonnelActualRef]
  properties: [PropertyRef]
}

input AddPersonnelActualInput {
  isActive: Boolean
  jobResponse: JobResponseRef!
  person: PersonRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type AddPersonnelActualPayload {
  numUids: Int
  personnelActual(
    filter: PersonnelActualFilter
    first: Int
    offset: Int
    order: PersonnelActualOrder
  ): [PersonnelActual]
}

input AddPersonnelClassInput {
  description: String
  isActive: Boolean
  isTestedBy: [TestSpecificationRef]
  name: String!
  persons: [PersonRef]
  properties: [PropertyRef]
}

type AddPersonnelClassPayload {
  numUids: Int
  personnelClass(
    filter: PersonnelClassFilter
    first: Int
    offset: Int
    order: PersonnelClassOrder
  ): [PersonnelClass]
}

input AddPersonnelSpecificationInput {
  description: String
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  person: PersonRef
  personnelClass: PersonnelClassRef
  personnelUse: String
  quantity: Float
  uom: UnitOfMeasureRef
}

type AddPersonnelSpecificationPayload {
  numUids: Int
  personnelSpecification(
    filter: PersonnelSpecificationFilter
    first: Int
    offset: Int
    order: PersonnelSpecificationOrder
  ): [PersonnelSpecification]
}

type AddPersonPayload {
  numUids: Int
  person(
    filter: PersonFilter
    first: Int
    offset: Int
    order: PersonOrder
  ): [Person]
}

input AddPropertyInput {
  address: String
  dataType: DataType
  definedBy: PropertyRef
  description: String!
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  eventPayloads: [EventDefinitionRef]
  eventTriggers: [EventDefinitionRef]
  expression: String
  isActive: Boolean
  isTestedBy: [TestSpecificationRef]
  jobOrder: JobOrderRef
  jobResponse: JobResponseRef
  materialClass: MaterialClassRef
  name: String!
  operationsRequest: OperationsRequestRef
  parameterSpecifications: [ParameterSpecificationRef]
  propertyNameAliases: [PropertyNameAliasRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  storeHistory: Boolean
  type: PropertyType
  unitOfMeasure: UnitOfMeasureRef
  value: String
}

input AddPropertyNameAliasInput {
  alias: String!
  equipment: EquipmentRef!
  property: PropertyRef!
  system: String!
}

type AddPropertyNameAliasPayload {
  numUids: Int
  propertyNameAlias(
    filter: PropertyNameAliasFilter
    first: Int
    offset: Int
    order: PropertyNameAliasOrder
  ): [PropertyNameAlias]
}

type AddPropertyPayload {
  numUids: Int
  property(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
}

input AddPropertyValueAliasInput {
  alias: String!
  property: PropertyRef!
  system: String!
  value: String!
}

type AddPropertyValueAliasPayload {
  numUids: Int
  propertyValueAlias(
    filter: PropertyValueAliasFilter
    first: Int
    offset: Int
    order: PropertyValueAliasOrder
  ): [PropertyValueAlias]
}

input AddQuantityLogInput {
  comments: String
  equipment: EquipmentRef
  isActive: Boolean
  jobResponse: JobResponseRef!
  quantity: Float!
  reasonCode: String
  reasonText: String
  timestamp: DateTime
  type: MaterialUse!
}

type AddQuantityLogPayload {
  numUids: Int
  quantityLog(
    filter: QuantityLogFilter
    first: Int
    offset: Int
    order: QuantityLogOrder
  ): [QuantityLog]
}

input AddReasonCategoryInput {
  code: String!
  isActive: Boolean
  reason: [ReasonRef]
  timeCategory: TimeCategory!
}

type AddReasonCategoryPayload {
  numUids: Int
  reasonCategory(
    filter: ReasonCategoryFilter
    first: Int
    offset: Int
    order: ReasonCategoryOrder
  ): [ReasonCategory]
}

input AddReasonInput {
  category: ReasonCategoryRef
  children: [ReasonRef]
  class: ReasonClass!
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  equipmentOverrides: [EquipmentReasonOverrideRef]
  erpCode: String!
  isActive: Boolean
  label: String!
  parent: ReasonRef
  standardValue: Float
  text: String!
  valueUoM: UnitOfMeasureRef
}

type AddReasonPayload {
  numUids: Int
  reason(
    filter: ReasonFilter
    first: Int
    offset: Int
    order: ReasonOrder
  ): [Reason]
}

input AddRequestStateInput {
  description: String
  isActive: Boolean
  name: String!
}

type AddRequestStatePayload {
  numUids: Int
  requestState(
    filter: RequestStateFilter
    first: Int
    offset: Int
    order: RequestStateOrder
  ): [RequestState]
}

type Address {
  city: String
  countryCode: String
  id: ID!
  isActive: Boolean
  name: String
  number: String
  postCode: String
  state: String
  street1: String
  street2: String
}

type AddressAggregateResult {
  cityMax: String
  cityMin: String
  count: Int
  countryCodeMax: String
  countryCodeMin: String
  nameMax: String
  nameMin: String
  numberMax: String
  numberMin: String
  postCodeMax: String
  postCodeMin: String
  stateMax: String
  stateMin: String
  street1Max: String
  street1Min: String
  street2Max: String
  street2Min: String
}

input AddressFilter {
  and: [AddressFilter]
  has: [AddressHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: AddressFilter
  or: [AddressFilter]
}

enum AddressHasFilter {
  city
  countryCode
  isActive
  name
  number
  postCode
  state
  street1
  street2
}

input AddressOrder {
  asc: AddressOrderable
  desc: AddressOrderable
  then: AddressOrder
}

enum AddressOrderable {
  city
  countryCode
  name
  number
  postCode
  state
  street1
  street2
}

input AddressPatch {
  city: String
  countryCode: String
  isActive: Boolean
  name: String
  number: String
  postCode: String
  state: String
  street1: String
  street2: String
}

input AddressRef {
  city: String
  countryCode: String
  id: ID
  isActive: Boolean
  name: String
  number: String
  postCode: String
  state: String
  street1: String
  street2: String
}

input AddRoleInput {
  hasGrantedRights: [AccessRightRef]
  hasMembers: [UserRoleRef]
  isActive: Boolean
  name: String!
  workflowNodes: [WorkflowNodeRef]
}

type AddRolePayload {
  numUids: Int
  role(filter: RoleFilter, first: Int, offset: Int, order: RoleOrder): [Role]
}

input AddSegmentDependencyInput {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM: UnitOfMeasureRef
  from: OperationsSegmentRef!
  isActive: Boolean
  jobOrderDependencies: [JobOrderDependencyRef]
  to: OperationsSegmentRef!
  transitionEventRuleset: TransitionEventRulesetRef
}

type AddSegmentDependencyPayload {
  numUids: Int
  segmentDependency(
    filter: SegmentDependencyFilter
    first: Int
    offset: Int
    order: SegmentDependencyOrder
  ): [SegmentDependency]
}

input AddSegmentInvoiceSettingInput {
  costPerHour: Float
  costPerUnit: Float
  partner: PartnerRef
}

type AddSegmentInvoiceSettingPayload {
  numUids: Int
  segmentInvoiceSetting(
    filter: SegmentInvoiceSettingFilter
    first: Int
    offset: Int
    order: SegmentInvoiceSettingOrder
  ): [SegmentInvoiceSetting]
}

input AddShipmentInput {
  consignmentNumber: String
  customerReference: String
  dateTimeCreatedUTC: DateTime
  dateTimeDeliveredUTC: DateTime
  dateTimePackedUTC: DateTime
  dateTimeReceivedUTC: DateTime
  delivered: DeliveryRef
  emailTrackingEnabled: Boolean
  from: AddressRef
  isActive: Boolean
  items: [ShipmentItemRef]
  order: OrderRef!
  properties: [PropertyRef]
  reference: String
  status: ShipmentStatus
  to: AddressRef
  transportCompany: TransportCompany
  transportCompanyProductCode: String
  transportCompanyShipmentId: String
  type: ShipmentType!
  warehouse: EquipmentRef!
}

input AddShipmentItemInput {
  bin: EquipmentRef
  box: BoxRef
  isActive: Boolean
  isParcel: Boolean
  material: MaterialDefinitionRef
  plannedQuantity: Int
  shipment: ShipmentRef
  status: ShipmentItemStatus!
  trackingDetailsArticleId: String
  trackingDetailsBarcodeId: String
  trackingDetailsConsignmentId: String
  transportCompanyItemId: String
  transportCompanyItemReference: String
  weightKg: Float
}

type AddShipmentItemPayload {
  numUids: Int
  shipmentItem(
    filter: ShipmentItemFilter
    first: Int
    offset: Int
    order: ShipmentItemOrder
  ): [ShipmentItem]
}

type AddShipmentPayload {
  numUids: Int
  shipment(
    filter: ShipmentFilter
    first: Int
    offset: Int
    order: ShipmentOrder
  ): [Shipment]
}

input AddShippingAccountInput {
  accountNumber: String
  isActive: Boolean
  partner: PartnerRef
  secret: String
  transportCompany: TransportCompany
  username: String
  warehouse: EquipmentRef
}

type AddShippingAccountPayload {
  numUids: Int
  shippingAccount(
    filter: ShippingAccountFilter
    first: Int
    offset: Int
    order: ShippingAccountOrder
  ): [ShippingAccount]
}

input AddStateEventRulesetInput {
  eventDefs: [EventDefinitionRef]
  name: String!
  segment: OperationsSegmentRef
  targetState: String!
  triggerWhen: [RulesetTriggerOption]
}

type AddStateEventRulesetPayload {
  numUids: Int
  stateEventRuleset(
    filter: StateEventRulesetFilter
    first: Int
    offset: Int
    order: StateEventRulesetOrder
  ): [StateEventRuleset]
}

input AddTestResultInput {
  description: String
  isActive: Boolean
  result: String
  testDateTime: DateTime
  uom: UnitOfMeasureRef
}

type AddTestResultPayload {
  numUids: Int
  testResult(
    filter: TestResultFilter
    first: Int
    offset: Int
    order: TestResultOrder
  ): [TestResult]
}

input AddTestSpecificationInput {
  description: String
  isActive: Boolean
  version: String
}

type AddTestSpecificationPayload {
  numUids: Int
  testSpecification(
    filter: TestSpecificationFilter
    first: Int
    offset: Int
    order: TestSpecificationOrder
  ): [TestSpecification]
}

input AddTransitionEventRulesetInput {
  eventDefs: [EventDefinitionRef]
  name: String!
  segmentDependency: SegmentDependencyRef
}

type AddTransitionEventRulesetPayload {
  numUids: Int
  transitionEventRuleset(
    filter: TransitionEventRulesetFilter
    first: Int
    offset: Int
    order: TransitionEventRulesetOrder
  ): [TransitionEventRuleset]
}

input AddUnitOfMeasureConversionInput {
  denominator: Float!
  fromUoM: UnitOfMeasureRef!
  isActive: Boolean
  material: MaterialDefinitionRef!
  numerator: Float!
  toUoM: UnitOfMeasureRef!
}

type AddUnitOfMeasureConversionPayload {
  numUids: Int
  unitOfMeasureConversion(
    filter: UnitOfMeasureConversionFilter
    first: Int
    offset: Int
    order: UnitOfMeasureConversionOrder
  ): [UnitOfMeasureConversion]
}

input AddUnitOfMeasureInput {
  code: String!
  dataType: DataType
  isActive: Boolean
}

type AddUnitOfMeasurePayload {
  numUids: Int
  unitOfMeasure(
    filter: UnitOfMeasureFilter
    first: Int
    offset: Int
    order: UnitOfMeasureOrder
  ): [UnitOfMeasure]
}

input AddUserInput {
  hasRole: [UserRoleRef]
  isActive: Boolean
  isType: UserType!
  name: String
  tasks: [WorkflowNodeInstanceRef]
  username: String!
}

type AddUserPayload {
  numUids: Int
  user(filter: UserFilter, first: Int, offset: Int, order: UserOrder): [User]
}

input AddUserRoleInput {
  isActive: Boolean
  responsibilities: [EquipmentRef]!
  role: RoleRef!
  user: UserRef!
}

type AddUserRolePayload {
  numUids: Int
  userRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
}

input AddWorkCalendarDefinitionEntryInput {
  byHour: [Int]
  byMinute: [Int]
  byMonth: [Int]
  byMonthDay: [Int]
  bySecond: [Int]
  bySetPos: [Int]
  byWeekDay: [Weekday]
  byWeekNo: [Int]
  byYearDay: [Int]
  calendarEntries: [WorkCalendarEntryRef]
  count: Int
  description: String
  duration: String
  endDateTime: DateTime
  entryType: WorkCalendarEntryType!
  freq: Frequency!
  hierarchyScope: EquipmentRef
  interval: Int
  isActive: Boolean
  properties: [PropertyRef]
  startDateTime: DateTime!
  wkst: Weekday
  workCalendar: WorkCalendarRef
}

type AddWorkCalendarDefinitionEntryPayload {
  numUids: Int
  workCalendarDefinitionEntry(
    filter: WorkCalendarDefinitionEntryFilter
    first: Int
    offset: Int
    order: WorkCalendarDefinitionEntryOrder
  ): [WorkCalendarDefinitionEntry]
}

input AddWorkCalendarEntryInput {
  definition: WorkCalendarDefinitionEntryRef
  description: String
  entryType: WorkCalendarEntryType!
  finishDateTime: DateTime!
  hierarchyScope: EquipmentRef
  isActive: Boolean
  properties: [PropertyRef]
  startDateTime: DateTime!
  workCalendar: WorkCalendarRef
}

type AddWorkCalendarEntryPayload {
  numUids: Int
  workCalendarEntry(
    filter: WorkCalendarEntryFilter
    first: Int
    offset: Int
    order: WorkCalendarEntryOrder
  ): [WorkCalendarEntry]
}

input AddWorkCalendarInput {
  definition: [WorkCalendarDefinitionEntryRef]
  description: String
  entries: [WorkCalendarEntryRef]
  equipment: [EquipmentRef]
  isActive: Boolean
  name: String!
}

type AddWorkCalendarPayload {
  numUids: Int
  workCalendar(
    filter: WorkCalendarFilter
    first: Int
    offset: Int
    order: WorkCalendarOrder
  ): [WorkCalendar]
}

input AddWorkflowConnectionInput {
  access: [ACLRef]
  condition: String
  connectionType: WorkflowConnectionTypeRef!
  createdBy: UserRef
  createdDateTime: DateTime
  from: WorkflowNodeRef!
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  properties: [WorkflowPropertyRef]
  to: WorkflowNodeRef!
  workflowSpecification: WorkflowSpecificationRef!
}

type AddWorkflowConnectionPayload {
  numUids: Int
  workflowConnection(
    filter: WorkflowConnectionFilter
    first: Int
    offset: Int
    order: WorkflowConnectionOrder
  ): [WorkflowConnection]
}

input AddWorkflowConnectionTypeInput {
  access: [ACLRef]
  connections: [WorkflowConnectionRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String!
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String!
  properties: [WorkflowPropertyRef]
}

type AddWorkflowConnectionTypePayload {
  numUids: Int
  workflowConnectionType(
    filter: WorkflowConnectionTypeFilter
    first: Int
    offset: Int
    order: WorkflowConnectionTypeOrder
  ): [WorkflowConnectionType]
}

input AddWorkflowInstanceInput {
  children: [WorkflowInstanceRef]
  createdBy: UserRef
  createdDateTime: DateTime
  equipment: EquipmentRef
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  nodeInstances: [WorkflowNodeInstanceRef]
  orderLines: [OrderLineRef]
  parent: WorkflowInstanceRef
  properties: [WorkflowInstancePropertyRef]
  propertyInstances: [WorkflowPropertyInstanceRef]
  status: WorkflowNodeStatus
  workflowSpecification: WorkflowSpecificationRef
}

type AddWorkflowInstancePayload {
  numUids: Int
  workflowInstance(
    filter: WorkflowInstanceFilter
    first: Int
    offset: Int
    order: WorkflowInstanceOrder
  ): [WorkflowInstance]
}

input AddWorkflowInstancePropertyInput {
  key: String!
  name: String!
  values: [WorkflowPropertyValueRef]
  workflowInstance: WorkflowInstanceRef
}

type AddWorkflowInstancePropertyPayload {
  numUids: Int
  workflowInstanceProperty(
    filter: WorkflowInstancePropertyFilter
    first: Int
    offset: Int
    order: WorkflowInstancePropertyOrder
  ): [WorkflowInstanceProperty]
}

input AddWorkflowNodeEventInput {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  isActive: Boolean
  isProcessed: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  next: WorkflowNodeEventRef
  nodeInstance: WorkflowNodeInstanceRef
  previous: WorkflowNodeEventRef
  status: WorkflowNodeStatus
  value: String
}

type AddWorkflowNodeEventPayload {
  numUids: Int
  workflowNodeEvent(
    filter: WorkflowNodeEventFilter
    first: Int
    offset: Int
    order: WorkflowNodeEventOrder
  ): [WorkflowNodeEvent]
}

input AddWorkflowNodeInput {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String!
  form: FormRef
  height: Int
  inflows: [WorkflowConnectionRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String!
  nodeInstances: [WorkflowNodeInstanceRef]
  nodeType: WorkflowNodeTypeRef!
  outflows: [WorkflowConnectionRef]
  positionX: Int
  positionY: Int
  properties: [WorkflowPropertyRef]
  role: RoleRef
  uiComponent: String
  width: Int
  workflowSpecification: WorkflowSpecificationRef!
}

input AddWorkflowNodeInstanceInput {
  access: [ACLRef]
  assignedUser: UserRef
  createdBy: UserRef
  createdDateTime: DateTime
  events: [WorkflowNodeEventRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  node: WorkflowNodeRef!
  status: WorkflowNodeStatus
  workflowInstance: WorkflowInstanceRef!
}

type AddWorkflowNodeInstancePayload {
  numUids: Int
  workflowNodeInstance(
    filter: WorkflowNodeInstanceFilter
    first: Int
    offset: Int
    order: WorkflowNodeInstanceOrder
  ): [WorkflowNodeInstance]
}

type AddWorkflowNodePayload {
  numUids: Int
  workflowNode(
    filter: WorkflowNodeFilter
    first: Int
    offset: Int
    order: WorkflowNodeOrder
  ): [WorkflowNode]
}

input AddWorkflowNodeTypeInput {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String!
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String!
  nodeClass: WorkflowNodeClass!
  nodes: [WorkflowNodeRef]
  properties: [WorkflowPropertyRef]
}

type AddWorkflowNodeTypePayload {
  numUids: Int
  workflowNodeType(
    filter: WorkflowNodeTypeFilter
    first: Int
    offset: Int
    order: WorkflowNodeTypeOrder
  ): [WorkflowNodeType]
}

input AddWorkflowPropertyInput {
  access: [ACLRef]
  connection: WorkflowConnectionRef
  connectionType: WorkflowConnectionTypeRef
  createdBy: UserRef
  createdDateTime: DateTime
  dataType: DataType
  definedBy: WorkflowPropertyRef
  description: String!
  instances: [WorkflowPropertyInstanceRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String!
  node: WorkflowNodeRef
  nodeType: WorkflowNodeTypeRef
  propertyType: WorkflowPropertyType!
  unitOfMeasure: UnitOfMeasureRef
  value: String
}

input AddWorkflowPropertyInstanceInput {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  values: [WorkflowPropertyValueRef]
  workflowInstance: WorkflowInstanceRef
  workflowProperty: WorkflowPropertyRef
}

type AddWorkflowPropertyInstancePayload {
  numUids: Int
  workflowPropertyInstance(
    filter: WorkflowPropertyInstanceFilter
    first: Int
    offset: Int
    order: WorkflowPropertyInstanceOrder
  ): [WorkflowPropertyInstance]
}

type AddWorkflowPropertyPayload {
  numUids: Int
  workflowProperty(
    filter: WorkflowPropertyFilter
    first: Int
    offset: Int
    order: WorkflowPropertyOrder
  ): [WorkflowProperty]
}

input AddWorkflowPropertyValueInput {
  createdBy: UserRef
  createdDateTime: DateTime
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  next: WorkflowPropertyValueRef
  previous: WorkflowPropertyValueRef
  propertyInstance: WorkflowPropertyInstanceRef!
  value: String
}

type AddWorkflowPropertyValuePayload {
  numUids: Int
  workflowPropertyValue(
    filter: WorkflowPropertyValueFilter
    first: Int
    offset: Int
    order: WorkflowPropertyValueOrder
  ): [WorkflowPropertyValue]
}

input AddWorkflowSpecificationInput {
  access: [ACLRef]
  connections: [WorkflowConnectionRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String!
  instances: [WorkflowInstanceRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String!
  nodes: [WorkflowNodeRef]
}

type AddWorkflowSpecificationPayload {
  numUids: Int
  workflowSpecification(
    filter: WorkflowSpecificationFilter
    first: Int
    offset: Int
    order: WorkflowSpecificationOrder
  ): [WorkflowSpecification]
}

input AllEventsInTimeRangeFilter {
  From: DateTime!
  To: DateTime
}

type ASNStaging {
  errorList: [String]
  isValid: Boolean
  materialCode: String!
  orderNumber: String!
  quantity: Int!
  serialNumber: String
}

input ASNStagingInput {
  materialCode: String!
  orderNumber: String!
  quantity: Int!
  serialNumber: String
}

input AuthRule {
  and: [AuthRule]
  not: AuthRule
  or: [AuthRule]
  rule: String
}

input BackfillCancelRequest {
  requestId: String!
}

input BackfillRequest {
  equipment: [String!]!
  startDateTime: DateTime!
  username: String!
}

type BackfillResponse {
  message: String
  status: BackfillStatus!
  topic: String
}

enum BackfillStatus {
  CANCELED
  CREATED
  REJECTED
}

type BillOfMaterial {
  description: String
  id: ID!
  isActive: Boolean
  materialSpecifications(
    filter: MaterialSpecificationFilter
    first: Int
    offset: Int
    order: MaterialSpecificationOrder
  ): [MaterialSpecification]
  materialSpecificationsAggregate(
    filter: MaterialSpecificationFilter
  ): MaterialSpecificationAggregateResult
  name: String!
  operationsDefinition(filter: OperationsDefinitionFilter): OperationsDefinition
  version: String!
}

type BillOfMaterialAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  nameMax: String
  nameMin: String
  versionMax: String
  versionMin: String
}

input BillOfMaterialFilter {
  and: [BillOfMaterialFilter]
  has: [BillOfMaterialHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: BillOfMaterialFilter
  or: [BillOfMaterialFilter]
}

enum BillOfMaterialHasFilter {
  description
  isActive
  materialSpecifications
  name
  operationsDefinition
  version
}

input BillOfMaterialOrder {
  asc: BillOfMaterialOrderable
  desc: BillOfMaterialOrderable
  then: BillOfMaterialOrder
}

enum BillOfMaterialOrderable {
  description
  name
  version
}

input BillOfMaterialPatch {
  description: String
  isActive: Boolean
  materialSpecifications: [MaterialSpecificationRef]
  operationsDefinition: OperationsDefinitionRef
  version: String
}

input BillOfMaterialRef {
  description: String
  id: ID
  isActive: Boolean
  materialSpecifications: [MaterialSpecificationRef]
  name: String
  operationsDefinition: OperationsDefinitionRef
  version: String
}

type Box {
  id: ID!
  name: String
  sizeDepthCm: Int
  sizeHeightCm: Int
  sizeWidthCm: Int
}

type BoxAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
  sizeDepthCmAvg: Float
  sizeDepthCmMax: Int
  sizeDepthCmMin: Int
  sizeDepthCmSum: Int
  sizeHeightCmAvg: Float
  sizeHeightCmMax: Int
  sizeHeightCmMin: Int
  sizeHeightCmSum: Int
  sizeWidthCmAvg: Float
  sizeWidthCmMax: Int
  sizeWidthCmMin: Int
  sizeWidthCmSum: Int
}

input BoxFilter {
  and: [BoxFilter]
  has: [BoxHasFilter]
  id: [ID!]
  not: BoxFilter
  or: [BoxFilter]
}

enum BoxHasFilter {
  name
  sizeDepthCm
  sizeHeightCm
  sizeWidthCm
}

input BoxOrder {
  asc: BoxOrderable
  desc: BoxOrderable
  then: BoxOrder
}

enum BoxOrderable {
  name
  sizeDepthCm
  sizeHeightCm
  sizeWidthCm
}

input BoxPatch {
  name: String
  sizeDepthCm: Int
  sizeHeightCm: Int
  sizeWidthCm: Int
}

input BoxRef {
  id: ID
  name: String
  sizeDepthCm: Int
  sizeHeightCm: Int
  sizeWidthCm: Int
}

type Carrier {
  barcodeImage: String
  code: String!
  contents: [CarrierContents]
  id: ID!
  isActive: Boolean
  owner(filter: PartnerFilter): Partner
  status(filter: MaterialStatusFilter): MaterialStatus!
  storageLocation(filter: EquipmentFilter): Equipment!
  subLots: [CarrierSubLots]
}

type CarrierAggregateResult {
  barcodeImageMax: String
  barcodeImageMin: String
  codeMax: String
  codeMin: String
  count: Int
}

type CarrierContents {
  material: MaterialDefinition!
  owner: Partner
  quantity: Float
}

input CarrierFilter {
  and: [CarrierFilter]
  code: StringHashFilter
  has: [CarrierHasFilter]
  id: [ID!]
  isActive: Boolean
  not: CarrierFilter
  or: [CarrierFilter]
}

enum CarrierHasFilter {
  barcodeImage
  code
  isActive
  owner
  status
  storageLocation
}

input CarrierOrder {
  asc: CarrierOrderable
  desc: CarrierOrderable
  then: CarrierOrder
}

enum CarrierOrderable {
  barcodeImage
  code
}

input CarrierPatch {
  barcodeImage: String
  isActive: Boolean
  owner: PartnerRef
  status: MaterialStatusRef
  storageLocation: EquipmentRef
}

input CarrierRef {
  barcodeImage: String
  code: String
  id: ID
  isActive: Boolean
  owner: PartnerRef
  status: MaterialStatusRef
  storageLocation: EquipmentRef
}

type CarrierSubLots {
  material: MaterialDefinition!
  owner: Partner
  subLot: MaterialSubLot
}

input CompleteWorkflowTaskInput {
  properties: [ExtWorkflowPropertyRef]
  task: ExtWorkflowNodeInstanceRef!
  user: CoreUserRef!
}

input ConfirmASNInput {
  errorList: [String]
  isValid: Boolean
  materialCode: String!
  orderNumber: String!
  quantity: Int!
  serialNumber: String
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

input CoreUserRef {
  username: String!
}

enum CostDriver {
  PER_HOUR
  PER_UNIT
}

input CreateWorkflowInstanceInput {
  equipment: ExtEquipmentRef!
  properties: [ExtWorkflowPropertyRef]
  specification: ExtWorkflowSpecificationRef!
  user: CoreUserRef!
}

input CustomHTTP {
  body: String
  forwardHeaders: [String!]
  graphql: String
  introspectionHeaders: [String!]
  method: HTTPMethod!
  mode: Mode
  secretHeaders: [String!]
  skipIntrospection: Boolean
  url: String!
}

type DashboardConfig {
  id: ID!
  isActive: Boolean
  name: String!
  panels(
    filter: DashboardPanelConfigFilter
    first: Int
    offset: Int
    order: DashboardPanelConfigOrder
  ): [DashboardPanelConfig]
  panelsAggregate(
    filter: DashboardPanelConfigFilter
  ): DashboardPanelConfigAggregateResult
}

type DashboardConfigAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
}

input DashboardConfigFilter {
  and: [DashboardConfigFilter]
  has: [DashboardConfigHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: DashboardConfigFilter
  or: [DashboardConfigFilter]
}

enum DashboardConfigHasFilter {
  isActive
  name
  panels
}

input DashboardConfigOrder {
  asc: DashboardConfigOrderable
  desc: DashboardConfigOrderable
  then: DashboardConfigOrder
}

enum DashboardConfigOrderable {
  name
}

input DashboardConfigPatch {
  isActive: Boolean
  panels: [DashboardPanelConfigRef]
}

input DashboardConfigRef {
  id: ID
  isActive: Boolean
  name: String
  panels: [DashboardPanelConfigRef]
}

type DashboardPanelConfig {
  dashboard(filter: DashboardConfigFilter): DashboardConfig
  h: Int
  id: ID!
  properties(
    filter: DashboardWidgetConfigPropertyFilter
    first: Int
    offset: Int
    order: DashboardWidgetConfigPropertyOrder
  ): [DashboardWidgetConfigProperty]
  propertiesAggregate(
    filter: DashboardWidgetConfigPropertyFilter
  ): DashboardWidgetConfigPropertyAggregateResult
  w: Int
  widgetName: String
  x: Int
  y: Int
}

type DashboardPanelConfigAggregateResult {
  count: Int
  hAvg: Float
  hMax: Int
  hMin: Int
  hSum: Int
  wAvg: Float
  wMax: Int
  wMin: Int
  wSum: Int
  widgetNameMax: String
  widgetNameMin: String
  xAvg: Float
  xMax: Int
  xMin: Int
  xSum: Int
  yAvg: Float
  yMax: Int
  yMin: Int
  ySum: Int
}

input DashboardPanelConfigFilter {
  and: [DashboardPanelConfigFilter]
  has: [DashboardPanelConfigHasFilter]
  id: [ID!]
  not: DashboardPanelConfigFilter
  or: [DashboardPanelConfigFilter]
  widgetName: StringHashFilter
}

enum DashboardPanelConfigHasFilter {
  dashboard
  h
  properties
  w
  widgetName
  x
  y
}

input DashboardPanelConfigOrder {
  asc: DashboardPanelConfigOrderable
  desc: DashboardPanelConfigOrderable
  then: DashboardPanelConfigOrder
}

enum DashboardPanelConfigOrderable {
  h
  w
  widgetName
  x
  y
}

input DashboardPanelConfigPatch {
  dashboard: DashboardConfigRef
  h: Int
  properties: [DashboardWidgetConfigPropertyRef]
  w: Int
  widgetName: String
  x: Int
  y: Int
}

input DashboardPanelConfigRef {
  dashboard: DashboardConfigRef
  h: Int
  id: ID
  properties: [DashboardWidgetConfigPropertyRef]
  w: Int
  widgetName: String
  x: Int
  y: Int
}

type DashboardWidgetConfigProperty {
  id: ID!
  key: String!
  panel(filter: DashboardPanelConfigFilter): DashboardPanelConfig
  value: String!
}

type DashboardWidgetConfigPropertyAggregateResult {
  count: Int
  keyMax: String
  keyMin: String
  valueMax: String
  valueMin: String
}

input DashboardWidgetConfigPropertyFilter {
  and: [DashboardWidgetConfigPropertyFilter]
  has: [DashboardWidgetConfigPropertyHasFilter]
  id: [ID!]
  not: DashboardWidgetConfigPropertyFilter
  or: [DashboardWidgetConfigPropertyFilter]
}

enum DashboardWidgetConfigPropertyHasFilter {
  key
  panel
  value
}

input DashboardWidgetConfigPropertyOrder {
  asc: DashboardWidgetConfigPropertyOrderable
  desc: DashboardWidgetConfigPropertyOrderable
  then: DashboardWidgetConfigPropertyOrder
}

enum DashboardWidgetConfigPropertyOrderable {
  key
  value
}

input DashboardWidgetConfigPropertyPatch {
  key: String
  panel: DashboardPanelConfigRef
  value: String
}

input DashboardWidgetConfigPropertyRef {
  id: ID
  key: String
  panel: DashboardPanelConfigRef
  value: String
}

type DataError {
  message: String
}

# Data Providers are the client libraries that have been implemented in the edge agent.
# We need to make these plugins that that the library can be extended easily.
# At the moment, MQTT is all we have. We will add OPC-UA next
enum DataProvider {
  MQTT
  OPCUA
}

enum DataType {
  BOOL
  FLOAT
  FLOAT64
  INT
  INT32
  STRING
}

scalar DateTime

input DateTimeFilter {
  between: DateTimeRange
  eq: DateTime
  ge: DateTime
  gt: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
}

input DateTimeRange {
  max: DateTime!
  min: DateTime!
}

type DeleteAccessRightPayload {
  accessRight(filter: AccessRightFilter, first: Int, offset: Int): [AccessRight]
  msg: String
  numUids: Int
}

type DeleteACLPayload {
  aCL(filter: ACLFilter, first: Int, offset: Int): [ACL]
  msg: String
  numUids: Int
}

type DeleteAddressPayload {
  address(
    filter: AddressFilter
    first: Int
    offset: Int
    order: AddressOrder
  ): [Address]
  msg: String
  numUids: Int
}

type DeleteBillOfMaterialPayload {
  billOfMaterial(
    filter: BillOfMaterialFilter
    first: Int
    offset: Int
    order: BillOfMaterialOrder
  ): [BillOfMaterial]
  msg: String
  numUids: Int
}

type DeleteBoxPayload {
  box(filter: BoxFilter, first: Int, offset: Int, order: BoxOrder): [Box]
  msg: String
  numUids: Int
}

type DeleteCarrierPayload {
  carrier(
    filter: CarrierFilter
    first: Int
    offset: Int
    order: CarrierOrder
  ): [Carrier]
  msg: String
  numUids: Int
}

type DeleteDashboardConfigPayload {
  dashboardConfig(
    filter: DashboardConfigFilter
    first: Int
    offset: Int
    order: DashboardConfigOrder
  ): [DashboardConfig]
  msg: String
  numUids: Int
}

type DeleteDashboardPanelConfigPayload {
  dashboardPanelConfig(
    filter: DashboardPanelConfigFilter
    first: Int
    offset: Int
    order: DashboardPanelConfigOrder
  ): [DashboardPanelConfig]
  msg: String
  numUids: Int
}

type DeleteDashboardWidgetConfigPropertyPayload {
  dashboardWidgetConfigProperty(
    filter: DashboardWidgetConfigPropertyFilter
    first: Int
    offset: Int
    order: DashboardWidgetConfigPropertyOrder
  ): [DashboardWidgetConfigProperty]
  msg: String
  numUids: Int
}

type DeleteDeliveryPayload {
  delivery(
    filter: DeliveryFilter
    first: Int
    offset: Int
    order: DeliveryOrder
  ): [Delivery]
  msg: String
  numUids: Int
}

type DeleteEquipmentActualPayload {
  equipmentActual(
    filter: EquipmentActualFilter
    first: Int
    offset: Int
    order: EquipmentActualOrder
  ): [EquipmentActual]
  msg: String
  numUids: Int
}

type DeleteEquipmentClassPayload {
  equipmentClass(
    filter: EquipmentClassFilter
    first: Int
    offset: Int
    order: EquipmentClassOrder
  ): [EquipmentClass]
  msg: String
  numUids: Int
}

type DeleteEquipmentNameAliasPayload {
  equipmentNameAlias(
    filter: EquipmentNameAliasFilter
    first: Int
    offset: Int
    order: EquipmentNameAliasOrder
  ): [EquipmentNameAlias]
  msg: String
  numUids: Int
}

type DeleteEquipmentPayload {
  equipment(
    filter: EquipmentFilter
    first: Int
    offset: Int
    order: EquipmentOrder
  ): [Equipment]
  msg: String
  numUids: Int
}

type DeleteEquipmentPropertyOverridePayload {
  equipmentPropertyOverride(
    filter: EquipmentPropertyOverrideFilter
    first: Int
    offset: Int
    order: EquipmentPropertyOverrideOrder
  ): [EquipmentPropertyOverride]
  msg: String
  numUids: Int
}

type DeleteEquipmentReasonOverridePayload {
  equipmentReasonOverride(
    filter: EquipmentReasonOverrideFilter
    first: Int
    offset: Int
    order: EquipmentReasonOverrideOrder
  ): [EquipmentReasonOverride]
  msg: String
  numUids: Int
}

type DeleteEquipmentRelationPayload {
  equipmentRelation(
    filter: EquipmentRelationFilter
    first: Int
    offset: Int
  ): [EquipmentRelation]
  msg: String
  numUids: Int
}

type DeleteEquipmentSpecificationPayload {
  equipmentSpecification(
    filter: EquipmentSpecificationFilter
    first: Int
    offset: Int
    order: EquipmentSpecificationOrder
  ): [EquipmentSpecification]
  msg: String
  numUids: Int
}

type DeleteEventDefinitionPayload {
  eventDefinition(
    filter: EventDefinitionFilter
    first: Int
    offset: Int
    order: EventDefinitionOrder
  ): [EventDefinition]
  msg: String
  numUids: Int
}

type DeleteEventLogPayload {
  eventLog(
    filter: EventLogFilter
    first: Int
    offset: Int
    order: EventLogOrder
  ): [EventLog]
  msg: String
  numUids: Int
}

type DeleteFormPayload {
  form(filter: FormFilter, first: Int, offset: Int, order: FormOrder): [Form]
  msg: String
  numUids: Int
}

type DeleteGeneralLedgerAccountPayload {
  generalLedgerAccount(
    filter: GeneralLedgerAccountFilter
    first: Int
    offset: Int
    order: GeneralLedgerAccountOrder
  ): [GeneralLedgerAccount]
  msg: String
  numUids: Int
}

type DeleteInterfaceMessageLogPayload {
  interfaceMessageLog(
    filter: InterfaceMessageLogFilter
    first: Int
    offset: Int
    order: InterfaceMessageLogOrder
  ): [InterfaceMessageLog]
  msg: String
  numUids: Int
}

type DeleteInventoryHandlingPolicyPayload {
  inventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
    first: Int
    offset: Int
    order: InventoryHandlingPolicyOrder
  ): [InventoryHandlingPolicy]
  msg: String
  numUids: Int
}

type DeleteInventoryHandlingRulePayload {
  inventoryHandlingRule(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  msg: String
  numUids: Int
}

type DeleteInventoryHoldingPolicyPayload {
  inventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    first: Int
    offset: Int
    order: InventoryHoldingPolicyOrder
  ): [InventoryHoldingPolicy]
  msg: String
  numUids: Int
}

type DeleteJobOrderDependencyPayload {
  jobOrderDependency(
    filter: JobOrderDependencyFilter
    first: Int
    offset: Int
    order: JobOrderDependencyOrder
  ): [JobOrderDependency]
  msg: String
  numUids: Int
}

type DeleteJobOrderDispatchStateModelPayload {
  jobOrderDispatchStateModel(
    filter: JobOrderDispatchStateModelFilter
    first: Int
    offset: Int
  ): [JobOrderDispatchStateModel]
  msg: String
  numUids: Int
}

type DeleteJobOrderNotePayload {
  jobOrderNote(
    filter: JobOrderNoteFilter
    first: Int
    offset: Int
    order: JobOrderNoteOrder
  ): [JobOrderNote]
  msg: String
  numUids: Int
}

type DeleteJobOrderPayload {
  jobOrder(
    filter: JobOrderFilter
    first: Int
    offset: Int
    order: JobOrderOrder
  ): [JobOrder]
  msg: String
  numUids: Int
}

type DeleteJobResponsePayload {
  jobResponse(
    filter: JobResponseFilter
    first: Int
    offset: Int
    order: JobResponseOrder
  ): [JobResponse]
  msg: String
  numUids: Int
}

type DeleteLibreServicePayload {
  libreService(
    filter: LibreServiceFilter
    first: Int
    offset: Int
    order: LibreServiceOrder
  ): [LibreService]
  msg: String
  numUids: Int
}

type DeleteMaterialActualPayload {
  materialActual(
    filter: MaterialActualFilter
    first: Int
    offset: Int
    order: MaterialActualOrder
  ): [MaterialActual]
  msg: String
  numUids: Int
}

type DeleteMaterialAlternatePayload {
  materialAlternate(
    filter: MaterialAlternateFilter
    first: Int
    offset: Int
    order: MaterialAlternateOrder
  ): [MaterialAlternate]
  msg: String
  numUids: Int
}

type DeleteMaterialClassPayload {
  materialClass(
    filter: MaterialClassFilter
    first: Int
    offset: Int
    order: MaterialClassOrder
  ): [MaterialClass]
  msg: String
  numUids: Int
}

type DeleteMaterialDefinitionPayload {
  materialDefinition(
    filter: MaterialDefinitionFilter
    first: Int
    offset: Int
    order: MaterialDefinitionOrder
  ): [MaterialDefinition]
  msg: String
  numUids: Int
}

type DeleteMaterialEventRulesetPayload {
  materialEventRuleset(
    filter: MaterialEventRulesetFilter
    first: Int
    offset: Int
    order: MaterialEventRulesetOrder
  ): [MaterialEventRuleset]
  msg: String
  numUids: Int
}

type DeleteMaterialLotPayload {
  materialLot(
    filter: MaterialLotFilter
    first: Int
    offset: Int
    order: MaterialLotOrder
  ): [MaterialLot]
  msg: String
  numUids: Int
}

type DeleteMaterialSpecificationPayload {
  materialSpecification(
    filter: MaterialSpecificationFilter
    first: Int
    offset: Int
    order: MaterialSpecificationOrder
  ): [MaterialSpecification]
  msg: String
  numUids: Int
}

type DeleteMaterialStateModelPayload {
  materialStateModel(
    filter: MaterialStateModelFilter
    first: Int
    offset: Int
    order: MaterialStateModelOrder
  ): [MaterialStateModel]
  msg: String
  numUids: Int
}

type DeleteMaterialStateTransitionPayload {
  materialStateTransition(
    filter: MaterialStateTransitionFilter
    first: Int
    offset: Int
  ): [MaterialStateTransition]
  msg: String
  numUids: Int
}

type DeleteMaterialStatusPayload {
  materialStatus(
    filter: MaterialStatusFilter
    first: Int
    offset: Int
    order: MaterialStatusOrder
  ): [MaterialStatus]
  msg: String
  numUids: Int
}

type DeleteMaterialSubLotPayload {
  materialSubLot(
    filter: MaterialSubLotFilter
    first: Int
    offset: Int
    order: MaterialSubLotOrder
  ): [MaterialSubLot]
  msg: String
  numUids: Int
}

type DeleteMaterialUnitPayload {
  materialUnit(
    filter: MaterialUnitFilter
    first: Int
    offset: Int
    order: MaterialUnitOrder
  ): [MaterialUnit]
  msg: String
  numUids: Int
}

type DeleteMenuPayload {
  menu(filter: MenuFilter, first: Int, offset: Int, order: MenuOrder): [Menu]
  msg: String
  numUids: Int
}

type DeleteOperationsDefinitionPayload {
  msg: String
  numUids: Int
  operationsDefinition(
    filter: OperationsDefinitionFilter
    first: Int
    offset: Int
    order: OperationsDefinitionOrder
  ): [OperationsDefinition]
}

type DeleteOperationsRequestPayload {
  msg: String
  numUids: Int
  operationsRequest(
    filter: OperationsRequestFilter
    first: Int
    offset: Int
    order: OperationsRequestOrder
  ): [OperationsRequest]
}

type DeleteOperationsSegmentPayload {
  msg: String
  numUids: Int
  operationsSegment(
    filter: OperationsSegmentFilter
    first: Int
    offset: Int
    order: OperationsSegmentOrder
  ): [OperationsSegment]
}

type DeleteOrderLinePayload {
  msg: String
  numUids: Int
  orderLine(
    filter: OrderLineFilter
    first: Int
    offset: Int
    order: OrderLineOrder
  ): [OrderLine]
}

type DeleteOrderPayload {
  msg: String
  numUids: Int
  order(
    filter: OrderFilter
    first: Int
    offset: Int
    order: OrderOrder
  ): [Order]
}

type DeleteOrderStartRulesetPayload {
  msg: String
  numUids: Int
  orderStartRuleset(
    filter: OrderStartRulesetFilter
    first: Int
    offset: Int
    order: OrderStartRulesetOrder
  ): [OrderStartRuleset]
}

type DeleteParameterSpecificationPayload {
  msg: String
  numUids: Int
  parameterSpecification(
    filter: ParameterSpecificationFilter
    first: Int
    offset: Int
    order: ParameterSpecificationOrder
  ): [ParameterSpecification]
}

type DeletePartnerPayload {
  msg: String
  numUids: Int
  partner(
    filter: PartnerFilter
    first: Int
    offset: Int
    order: PartnerOrder
  ): [Partner]
}

type DeletePayloadFieldDefinitionPayload {
  msg: String
  numUids: Int
  payloadFieldDefinition(
    filter: PayloadFieldDefinitionFilter
    first: Int
    offset: Int
    order: PayloadFieldDefinitionOrder
  ): [PayloadFieldDefinition]
}

type DeletePersonnelActualPayload {
  msg: String
  numUids: Int
  personnelActual(
    filter: PersonnelActualFilter
    first: Int
    offset: Int
    order: PersonnelActualOrder
  ): [PersonnelActual]
}

type DeletePersonnelClassPayload {
  msg: String
  numUids: Int
  personnelClass(
    filter: PersonnelClassFilter
    first: Int
    offset: Int
    order: PersonnelClassOrder
  ): [PersonnelClass]
}

type DeletePersonnelSpecificationPayload {
  msg: String
  numUids: Int
  personnelSpecification(
    filter: PersonnelSpecificationFilter
    first: Int
    offset: Int
    order: PersonnelSpecificationOrder
  ): [PersonnelSpecification]
}

type DeletePersonPayload {
  msg: String
  numUids: Int
  person(
    filter: PersonFilter
    first: Int
    offset: Int
    order: PersonOrder
  ): [Person]
}

type DeletePropertyNameAliasPayload {
  msg: String
  numUids: Int
  propertyNameAlias(
    filter: PropertyNameAliasFilter
    first: Int
    offset: Int
    order: PropertyNameAliasOrder
  ): [PropertyNameAlias]
}

type DeletePropertyPayload {
  msg: String
  numUids: Int
  property(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
}

type DeletePropertyValueAliasPayload {
  msg: String
  numUids: Int
  propertyValueAlias(
    filter: PropertyValueAliasFilter
    first: Int
    offset: Int
    order: PropertyValueAliasOrder
  ): [PropertyValueAlias]
}

type DeleteQuantityLogPayload {
  msg: String
  numUids: Int
  quantityLog(
    filter: QuantityLogFilter
    first: Int
    offset: Int
    order: QuantityLogOrder
  ): [QuantityLog]
}

type DeleteReasonCategoryPayload {
  msg: String
  numUids: Int
  reasonCategory(
    filter: ReasonCategoryFilter
    first: Int
    offset: Int
    order: ReasonCategoryOrder
  ): [ReasonCategory]
}

type DeleteReasonPayload {
  msg: String
  numUids: Int
  reason(
    filter: ReasonFilter
    first: Int
    offset: Int
    order: ReasonOrder
  ): [Reason]
}

type DeleteRequestStatePayload {
  msg: String
  numUids: Int
  requestState(
    filter: RequestStateFilter
    first: Int
    offset: Int
    order: RequestStateOrder
  ): [RequestState]
}

type DeleteRolePayload {
  msg: String
  numUids: Int
  role(filter: RoleFilter, first: Int, offset: Int, order: RoleOrder): [Role]
}

type DeleteSegmentDependencyPayload {
  msg: String
  numUids: Int
  segmentDependency(
    filter: SegmentDependencyFilter
    first: Int
    offset: Int
    order: SegmentDependencyOrder
  ): [SegmentDependency]
}

type DeleteSegmentInvoiceSettingPayload {
  msg: String
  numUids: Int
  segmentInvoiceSetting(
    filter: SegmentInvoiceSettingFilter
    first: Int
    offset: Int
    order: SegmentInvoiceSettingOrder
  ): [SegmentInvoiceSetting]
}

type DeleteShipmentItemPayload {
  msg: String
  numUids: Int
  shipmentItem(
    filter: ShipmentItemFilter
    first: Int
    offset: Int
    order: ShipmentItemOrder
  ): [ShipmentItem]
}

type DeleteShipmentPayload {
  msg: String
  numUids: Int
  shipment(
    filter: ShipmentFilter
    first: Int
    offset: Int
    order: ShipmentOrder
  ): [Shipment]
}

type DeleteShippingAccountPayload {
  msg: String
  numUids: Int
  shippingAccount(
    filter: ShippingAccountFilter
    first: Int
    offset: Int
    order: ShippingAccountOrder
  ): [ShippingAccount]
}

type DeleteStateEventRulesetPayload {
  msg: String
  numUids: Int
  stateEventRuleset(
    filter: StateEventRulesetFilter
    first: Int
    offset: Int
    order: StateEventRulesetOrder
  ): [StateEventRuleset]
}

type DeleteTestResultPayload {
  msg: String
  numUids: Int
  testResult(
    filter: TestResultFilter
    first: Int
    offset: Int
    order: TestResultOrder
  ): [TestResult]
}

type DeleteTestSpecificationPayload {
  msg: String
  numUids: Int
  testSpecification(
    filter: TestSpecificationFilter
    first: Int
    offset: Int
    order: TestSpecificationOrder
  ): [TestSpecification]
}

type DeleteTransitionEventRulesetPayload {
  msg: String
  numUids: Int
  transitionEventRuleset(
    filter: TransitionEventRulesetFilter
    first: Int
    offset: Int
    order: TransitionEventRulesetOrder
  ): [TransitionEventRuleset]
}

type DeleteUnitOfMeasureConversionPayload {
  msg: String
  numUids: Int
  unitOfMeasureConversion(
    filter: UnitOfMeasureConversionFilter
    first: Int
    offset: Int
    order: UnitOfMeasureConversionOrder
  ): [UnitOfMeasureConversion]
}

type DeleteUnitOfMeasurePayload {
  msg: String
  numUids: Int
  unitOfMeasure(
    filter: UnitOfMeasureFilter
    first: Int
    offset: Int
    order: UnitOfMeasureOrder
  ): [UnitOfMeasure]
}

type DeleteUserPayload {
  msg: String
  numUids: Int
  user(filter: UserFilter, first: Int, offset: Int, order: UserOrder): [User]
}

type DeleteUserRolePayload {
  msg: String
  numUids: Int
  userRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
}

type DeleteWorkCalendarDefinitionEntryPayload {
  msg: String
  numUids: Int
  workCalendarDefinitionEntry(
    filter: WorkCalendarDefinitionEntryFilter
    first: Int
    offset: Int
    order: WorkCalendarDefinitionEntryOrder
  ): [WorkCalendarDefinitionEntry]
}

type DeleteWorkCalendarEntryPayload {
  msg: String
  numUids: Int
  workCalendarEntry(
    filter: WorkCalendarEntryFilter
    first: Int
    offset: Int
    order: WorkCalendarEntryOrder
  ): [WorkCalendarEntry]
}

type DeleteWorkCalendarPayload {
  msg: String
  numUids: Int
  workCalendar(
    filter: WorkCalendarFilter
    first: Int
    offset: Int
    order: WorkCalendarOrder
  ): [WorkCalendar]
}

type DeleteWorkflowConnectionPayload {
  msg: String
  numUids: Int
  workflowConnection(
    filter: WorkflowConnectionFilter
    first: Int
    offset: Int
    order: WorkflowConnectionOrder
  ): [WorkflowConnection]
}

type DeleteWorkflowConnectionTypePayload {
  msg: String
  numUids: Int
  workflowConnectionType(
    filter: WorkflowConnectionTypeFilter
    first: Int
    offset: Int
    order: WorkflowConnectionTypeOrder
  ): [WorkflowConnectionType]
}

type DeleteWorkflowInstancePayload {
  msg: String
  numUids: Int
  workflowInstance(
    filter: WorkflowInstanceFilter
    first: Int
    offset: Int
    order: WorkflowInstanceOrder
  ): [WorkflowInstance]
}

type DeleteWorkflowInstancePropertyPayload {
  msg: String
  numUids: Int
  workflowInstanceProperty(
    filter: WorkflowInstancePropertyFilter
    first: Int
    offset: Int
    order: WorkflowInstancePropertyOrder
  ): [WorkflowInstanceProperty]
}

type DeleteWorkflowNodeEventPayload {
  msg: String
  numUids: Int
  workflowNodeEvent(
    filter: WorkflowNodeEventFilter
    first: Int
    offset: Int
    order: WorkflowNodeEventOrder
  ): [WorkflowNodeEvent]
}

type DeleteWorkflowNodeInstancePayload {
  msg: String
  numUids: Int
  workflowNodeInstance(
    filter: WorkflowNodeInstanceFilter
    first: Int
    offset: Int
    order: WorkflowNodeInstanceOrder
  ): [WorkflowNodeInstance]
}

type DeleteWorkflowNodePayload {
  msg: String
  numUids: Int
  workflowNode(
    filter: WorkflowNodeFilter
    first: Int
    offset: Int
    order: WorkflowNodeOrder
  ): [WorkflowNode]
}

type DeleteWorkflowNodeTypePayload {
  msg: String
  numUids: Int
  workflowNodeType(
    filter: WorkflowNodeTypeFilter
    first: Int
    offset: Int
    order: WorkflowNodeTypeOrder
  ): [WorkflowNodeType]
}

type DeleteWorkflowPropertyInstancePayload {
  msg: String
  numUids: Int
  workflowPropertyInstance(
    filter: WorkflowPropertyInstanceFilter
    first: Int
    offset: Int
    order: WorkflowPropertyInstanceOrder
  ): [WorkflowPropertyInstance]
}

type DeleteWorkflowPropertyPayload {
  msg: String
  numUids: Int
  workflowProperty(
    filter: WorkflowPropertyFilter
    first: Int
    offset: Int
    order: WorkflowPropertyOrder
  ): [WorkflowProperty]
}

type DeleteWorkflowPropertyValuePayload {
  msg: String
  numUids: Int
  workflowPropertyValue(
    filter: WorkflowPropertyValueFilter
    first: Int
    offset: Int
    order: WorkflowPropertyValueOrder
  ): [WorkflowPropertyValue]
}

type DeleteWorkflowSpecificationPayload {
  msg: String
  numUids: Int
  workflowSpecification(
    filter: WorkflowSpecificationFilter
    first: Int
    offset: Int
    order: WorkflowSpecificationOrder
  ): [WorkflowSpecification]
}

type Delivery {
  dateTime: DateTime!
  id: ID!
  location(filter: EquipmentFilter): Equipment
  operator(filter: UserFilter): User
  partner(filter: PartnerFilter): Partner
  shipments(
    filter: ShipmentFilter
    first: Int
    offset: Int
    order: ShipmentOrder
  ): [Shipment]
  shipmentsAggregate(filter: ShipmentFilter): ShipmentAggregateResult
  transportCompany: TransportCompany
  transportCompanyDeliveryId: String
}

type DeliveryAggregateResult {
  count: Int
  dateTimeMax: DateTime
  dateTimeMin: DateTime
  transportCompanyDeliveryIdMax: String
  transportCompanyDeliveryIdMin: String
}

input DeliveryFilter {
  and: [DeliveryFilter]
  has: [DeliveryHasFilter]
  id: [ID!]
  not: DeliveryFilter
  or: [DeliveryFilter]
}

enum DeliveryHasFilter {
  dateTime
  location
  operator
  partner
  shipments
  transportCompany
  transportCompanyDeliveryId
}

input DeliveryOrder {
  asc: DeliveryOrderable
  desc: DeliveryOrderable
  then: DeliveryOrder
}

enum DeliveryOrderable {
  dateTime
  transportCompanyDeliveryId
}

input DeliveryPatch {
  dateTime: DateTime
  location: EquipmentRef
  operator: UserRef
  partner: PartnerRef
  shipments: [ShipmentRef]
  transportCompany: TransportCompany
  transportCompanyDeliveryId: String
}

input DeliveryRef {
  dateTime: DateTime
  id: ID
  location: EquipmentRef
  operator: UserRef
  partner: PartnerRef
  shipments: [ShipmentRef]
  transportCompany: TransportCompany
  transportCompanyDeliveryId: String
}

enum DependencyType {
  CanRunParallel
  CannotRunParallel
  EndAfterEnd
  EndAfterStart
  StartAfterEnd
  StartAfterStart
}

enum DgraphIndex {
  bool
  day
  exact
  float
  fulltext
  geo
  hash
  hour
  int
  int64
  month
  regexp
  term
  trigram
  year
}

enum DispatchStatus {
  ACTIVE
  CANCELED
  CLOSED
  COMPLETE
  CREATED
  PARKED
  PENDING
  RELEASED
}

input DispatchStatus_hash {
  eq: DispatchStatus
  in: [DispatchStatus]
}

type Equipment {
  addressTemplate: String
  allowAdhocWorklog: Boolean
  backfillStatus: EquipmentBackfillStatus
  carriers(
    filter: CarrierFilter
    first: Int
    offset: Int
    order: CarrierOrder
  ): [Carrier]
  carriersAggregate(filter: CarrierFilter): CarrierAggregateResult
  children(
    filter: EquipmentFilter
    first: Int
    offset: Int
    order: EquipmentOrder
  ): [Equipment]
  childrenAggregate(filter: EquipmentFilter): EquipmentAggregateResult
  currentStatus: EventsByField
  dataProvider: DataProvider
  dataProviderConnection: String
  description: String
  displayName: String
  equipmentActual(
    filter: EquipmentActualFilter
    first: Int
    offset: Int
    order: EquipmentActualOrder
  ): [EquipmentActual]
  equipmentActualAggregate(
    filter: EquipmentActualFilter
  ): EquipmentActualAggregateResult
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass
  equipmentLevel: EquipmentElementLevel
  erpAssetID: String
  eventSummaryByReason(
    filter: EventSummaryByReasonFilter
  ): [EventSummaryByReason]
  events(
    filter: EventLogFilter
    first: Int
    offset: Int
    order: EventLogOrder
  ): [EventLog]
  eventsAggregate(filter: EventLogFilter): EventLogAggregateResult
  eventsByField(filter: EventsByFieldFilter!): [EventsByField]

  # deprecated
  eventsByTimeRange(filter: TimeRangeFilter): [EventLog]
  id: ID!
  inflows(
    filter: EquipmentRelationFilter
    first: Int
    offset: Int
  ): [EquipmentRelation]
  inflowsAggregate(
    filter: EquipmentRelationFilter
  ): EquipmentRelationAggregateResult
  inventoryHandlingRules(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  inventoryHandlingRulesAggregate(
    filter: InventoryHandlingRuleFilter
  ): InventoryHandlingRuleAggregateResult
  isActive: Boolean
  jobOrders(
    filter: JobOrderFilter
    first: Int
    offset: Int
    order: JobOrderOrder
  ): [JobOrder]
  jobOrdersAggregate(filter: JobOrderFilter): JobOrderAggregateResult
  jobResponses(
    filter: JobResponseFilter
    first: Int
    offset: Int
    order: JobResponseOrder
  ): [JobResponse]
  jobResponsesAggregate(filter: JobResponseFilter): JobResponseAggregateResult
  jobResponsesByTimeRange(filter: TimeRangeFilter): [JobResponse]
  kpi(filter: TimeRangeFilter!): Kpi
  kpiByWorkCalendarEntry(filter: TimeRangeFilter!): [KpiByWorkCalendarEntry]
  label: String
  maintenanceCallsByTimeRange(filter: TimeRangeFilter!): [MaintenanceLog]
  materialEquipment(filter: MaterialEquipmentFilter): [MaterialEquipment]
  materialSubLots(
    filter: MaterialSubLotFilter
    first: Int
    offset: Int
    order: MaterialSubLotOrder
  ): [MaterialSubLot]
  materialSubLotsAggregate(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
  mpmAutoIdentMatchSource: String
  mpmEnableAutoIdentMatching: Boolean
  mpmEnableCallMaintenanceEvent: Boolean
  mpmEnableJobInterlock: Boolean
  mpmEnableMaintenanceHandover: Boolean
  mpmEnableManualBreak: Boolean
  mpmEnableManualPlannedMaint: Boolean
  mpmEnableManualShiftEnd: Boolean
  mpmEnableManualShiftStart: Boolean
  mpmEnableORCBlockNextOrder: Boolean
  mpmEnableORCRevokePermissive: Boolean
  mpmEnableORCWarning: Boolean
  mpmEnableSetupCloseDetection: Boolean
  mpmEnableSetupStartDetection: Boolean
  mpmORCRevokePermissiveTrigger: mpmORCRevokeTriggers
  mpmORCWarnTrigger: mpmORCWarnTriggers
  mpmPermissiveOutputName: String
  name: String!
  ocsChosenStopTime: DateTime
  ocsEnabled: Boolean
  ocsPageState: String
  ocsWorkflowSelector: String
  operationsRequests(
    filter: OperationsRequestFilter
    first: Int
    offset: Int
    order: OperationsRequestOrder
  ): [OperationsRequest]
  operationsRequestsAggregate(
    filter: OperationsRequestFilter
  ): OperationsRequestAggregateResult
  orders(
    filter: OrderFilter
    first: Int
    offset: Int
    order: OrderOrder
  ): [Order]
  ordersAggregate(filter: OrderFilter): OrderAggregateResult
  outflows(
    filter: EquipmentRelationFilter
    first: Int
    offset: Int
  ): [EquipmentRelation]
  outflowsAggregate(
    filter: EquipmentRelationFilter
  ): EquipmentRelationAggregateResult
  parent(filter: EquipmentFilter): Equipment
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  propertyList(filter: PropertyListFilter): [Property]
  propertyListWithOverrides(filter: PropertyListFilter): [Property]
  propertyNameAliases(
    filter: PropertyNameAliasFilter
    first: Int
    offset: Int
    order: PropertyNameAliasOrder
  ): [PropertyNameAlias]
  propertyNameAliasesAggregate(
    filter: PropertyNameAliasFilter
  ): PropertyNameAliasAggregateResult
  propertyOverrides(
    filter: EquipmentPropertyOverrideFilter
    first: Int
    offset: Int
    order: EquipmentPropertyOverrideOrder
  ): [EquipmentPropertyOverride]
  propertyOverridesAggregate(
    filter: EquipmentPropertyOverrideFilter
  ): EquipmentPropertyOverrideAggregateResult
  propertyValues(filter: PropertyValuesFilter!): [PropertyValue]
  quantities(
    filter: QuantityLogFilter
    first: Int
    offset: Int
    order: QuantityLogOrder
  ): [QuantityLog]
  quantitiesAggregate(filter: QuantityLogFilter): QuantityLogAggregateResult
  reasonList: [Reason]
  reasonListWithOverrides(filter: ReasonFilter): [Reason]
  reasonOverrides(
    filter: EquipmentReasonOverrideFilter
    first: Int
    offset: Int
    order: EquipmentReasonOverrideOrder
  ): [EquipmentReasonOverride]
  reasonOverridesAggregate(
    filter: EquipmentReasonOverrideFilter
  ): EquipmentReasonOverrideAggregateResult
  reasons(
    filter: ReasonFilter
    first: Int
    offset: Int
    order: ReasonOrder
  ): [Reason]
  reasonsAggregate(filter: ReasonFilter): ReasonAggregateResult
  shipmentItems(
    filter: ShipmentItemFilter
    first: Int
    offset: Int
    order: ShipmentItemOrder
  ): [ShipmentItem]
  shipmentItemsAggregate(
    filter: ShipmentItemFilter
  ): ShipmentItemAggregateResult
  shipments(
    filter: ShipmentFilter
    first: Int
    offset: Int
    order: ShipmentOrder
  ): [Shipment]
  shipmentsAggregate(filter: ShipmentFilter): ShipmentAggregateResult
  timeZoneName: String
  userRoles(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
  userRolesAggregate(filter: UserRoleFilter): UserRoleAggregateResult
  workCalendar(filter: WorkCalendarFilter): WorkCalendar
  workSpecifications(
    filter: EquipmentSpecificationFilter
    first: Int
    offset: Int
    order: EquipmentSpecificationOrder
  ): [EquipmentSpecification]
  workSpecificationsAggregate(
    filter: EquipmentSpecificationFilter
  ): EquipmentSpecificationAggregateResult
  workflowInstances(
    filter: WorkflowInstanceFilter
    first: Int
    offset: Int
    order: WorkflowInstanceOrder
  ): [WorkflowInstance]
  workflowInstancesAggregate(
    filter: WorkflowInstanceFilter
  ): WorkflowInstanceAggregateResult
}

type EquipmentActual {
  equipment(filter: EquipmentFilter): Equipment
  id: ID!
  isActive: Boolean
  jobResponse(filter: JobResponseFilter): JobResponse!
  quantity: Float
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type EquipmentActualAggregateResult {
  count: Int
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input EquipmentActualFilter {
  and: [EquipmentActualFilter]
  has: [EquipmentActualHasFilter]
  id: [ID!]
  isActive: Boolean
  not: EquipmentActualFilter
  or: [EquipmentActualFilter]
}

enum EquipmentActualHasFilter {
  equipment
  isActive
  jobResponse
  quantity
  quantityUoM
}

input EquipmentActualOrder {
  asc: EquipmentActualOrderable
  desc: EquipmentActualOrderable
  then: EquipmentActualOrder
}

enum EquipmentActualOrderable {
  quantity
}

input EquipmentActualPatch {
  equipment: EquipmentRef
  isActive: Boolean
  jobResponse: JobResponseRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

input EquipmentActualRef {
  equipment: EquipmentRef
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type EquipmentAggregateResult {
  addressTemplateMax: String
  addressTemplateMin: String
  count: Int
  dataProviderConnectionMax: String
  dataProviderConnectionMin: String
  descriptionMax: String
  descriptionMin: String
  displayNameMax: String
  displayNameMin: String
  erpAssetIDMax: String
  erpAssetIDMin: String
  labelMax: String
  labelMin: String
  mpmAutoIdentMatchSourceMax: String
  mpmAutoIdentMatchSourceMin: String
  mpmPermissiveOutputNameMax: String
  mpmPermissiveOutputNameMin: String
  nameMax: String
  nameMin: String
  ocsChosenStopTimeMax: DateTime
  ocsChosenStopTimeMin: DateTime
  ocsPageStateMax: String
  ocsPageStateMin: String
  ocsWorkflowSelectorMax: String
  ocsWorkflowSelectorMin: String
  timeZoneNameMax: String
  timeZoneNameMin: String
}

enum EquipmentBackfillStatus {
  CANCELED
  COMPLETE
  ERROR
  INITIALIZING
  READY
  RUNNING
}

# EquipmentClasses are used to manage configuration that is common to a number of similar equipment
# The data properties that an equipment is expected to have are defined on the equipment class
type EquipmentClass {
  addressTemplate: String
  children(
    filter: EquipmentClassFilter
    first: Int
    offset: Int
    order: EquipmentClassOrder
  ): [EquipmentClass]
  childrenAggregate(filter: EquipmentClassFilter): EquipmentClassAggregateResult
  dashboardConfig(filter: DashboardConfigFilter): DashboardConfig
  description: String
  displayName: String
  equipmentLevel: EquipmentElementLevel
  equipmentSpecifications(
    filter: EquipmentSpecificationFilter
    first: Int
    offset: Int
    order: EquipmentSpecificationOrder
  ): [EquipmentSpecification]
  equipmentSpecificationsAggregate(
    filter: EquipmentSpecificationFilter
  ): EquipmentSpecificationAggregateResult
  equipments(
    filter: EquipmentFilter
    first: Int
    offset: Int
    order: EquipmentOrder
  ): [Equipment]
  equipmentsAggregate(filter: EquipmentFilter): EquipmentAggregateResult
  eventDefinitions(
    filter: EventDefinitionFilter
    first: Int
    offset: Int
    order: EventDefinitionOrder
  ): [EventDefinition]
  eventDefinitionsAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
  id: ID!
  image: String
  isActive: Boolean
  label: String
  name: String!
  parent(filter: EquipmentClassFilter): EquipmentClass
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  propertyList(filter: PropertyListFilter): [Property]
  reasons(
    filter: ReasonFilter
    first: Int
    offset: Int
    order: ReasonOrder
  ): [Reason]
  reasonsAggregate(filter: ReasonFilter): ReasonAggregateResult
}

type EquipmentClassAggregateResult {
  addressTemplateMax: String
  addressTemplateMin: String
  count: Int
  descriptionMax: String
  descriptionMin: String
  displayNameMax: String
  displayNameMin: String
  imageMax: String
  imageMin: String
  labelMax: String
  labelMin: String
  nameMax: String
  nameMin: String
}

input EquipmentClassFilter {
  and: [EquipmentClassFilter]
  description: StringHashFilter
  displayName: StringHashFilter
  has: [EquipmentClassHasFilter]
  id: [ID!]
  isActive: Boolean
  label: StringHashFilter
  name: StringHashFilter
  not: EquipmentClassFilter
  or: [EquipmentClassFilter]
}

enum EquipmentClassHasFilter {
  addressTemplate
  children
  dashboardConfig
  description
  displayName
  equipmentLevel
  equipmentSpecifications
  equipments
  eventDefinitions
  image
  isActive
  label
  name
  parent
  properties
  reasons
}

input EquipmentClassOrder {
  asc: EquipmentClassOrderable
  desc: EquipmentClassOrderable
  then: EquipmentClassOrder
}

enum EquipmentClassOrderable {
  addressTemplate
  description
  displayName
  image
  label
  name
}

input EquipmentClassPatch {
  addressTemplate: String
  children: [EquipmentClassRef]
  dashboardConfig: DashboardConfigRef
  description: String
  displayName: String
  equipmentLevel: EquipmentElementLevel
  equipmentSpecifications: [EquipmentSpecificationRef]
  equipments: [EquipmentRef]
  eventDefinitions: [EventDefinitionRef]
  image: String
  isActive: Boolean
  label: String
  name: String
  parent: EquipmentClassRef
  properties: [PropertyRef]
  reasons: [ReasonRef]
}

input EquipmentClassRef {
  addressTemplate: String
  children: [EquipmentClassRef]
  dashboardConfig: DashboardConfigRef
  description: String
  displayName: String
  equipmentLevel: EquipmentElementLevel
  equipmentSpecifications: [EquipmentSpecificationRef]
  equipments: [EquipmentRef]
  eventDefinitions: [EventDefinitionRef]
  id: ID
  image: String
  isActive: Boolean
  label: String
  name: String
  parent: EquipmentClassRef
  properties: [PropertyRef]
  reasons: [ReasonRef]
}

enum EquipmentElementLevel {
  Area
  ControlModule
  Enterprise
  EquipmentModule
  Other
  ProcessCell
  ProductionLine
  ProductionUnit
  Site
  StorageUnit
  StorageZone
  Unit
  Warehouse
  WorkCell
  WorkCenter
  WorkUnit
}

input EquipmentElementLevel_hash {
  eq: EquipmentElementLevel
  in: [EquipmentElementLevel]
}

input EquipmentFilter {
  and: [EquipmentFilter]
  description: StringHashFilter
  displayName: StringHashFilter
  equipmentLevel: EquipmentElementLevel_hash
  erpAssetID: StringHashFilter
  has: [EquipmentHasFilter]
  id: [ID!]
  isActive: Boolean
  label: StringHashFilter
  name: StringHashFilter
  not: EquipmentFilter
  or: [EquipmentFilter]
}

enum EquipmentHasFilter {
  addressTemplate
  allowAdhocWorklog
  carriers
  children
  dataProvider
  dataProviderConnection
  description
  displayName
  equipmentActual
  equipmentClass
  equipmentLevel
  erpAssetID
  events
  inflows
  inventoryHandlingRules
  isActive
  jobOrders
  jobResponses
  label
  materialSubLots
  mpmAutoIdentMatchSource
  mpmEnableAutoIdentMatching
  mpmEnableCallMaintenanceEvent
  mpmEnableJobInterlock
  mpmEnableMaintenanceHandover
  mpmEnableManualBreak
  mpmEnableManualPlannedMaint
  mpmEnableManualShiftEnd
  mpmEnableManualShiftStart
  mpmEnableORCBlockNextOrder
  mpmEnableORCRevokePermissive
  mpmEnableORCWarning
  mpmEnableSetupCloseDetection
  mpmEnableSetupStartDetection
  mpmORCRevokePermissiveTrigger
  mpmORCWarnTrigger
  mpmPermissiveOutputName
  name
  ocsChosenStopTime
  ocsEnabled
  ocsPageState
  ocsWorkflowSelector
  operationsRequests
  orders
  outflows
  parent
  properties
  propertyNameAliases
  propertyOverrides
  quantities
  reasonOverrides
  reasons
  shipmentItems
  shipments
  timeZoneName
  userRoles
  workCalendar
  workSpecifications
  workflowInstances
}

type EquipmentNameAlias {
  alias: String!
  equipment(filter: EquipmentFilter): Equipment!
  id: ID!
  system: String!
}

type EquipmentNameAliasAggregateResult {
  aliasMax: String
  aliasMin: String
  count: Int
  systemMax: String
  systemMin: String
}

input EquipmentNameAliasFilter {
  alias: StringFullTextFilter
  and: [EquipmentNameAliasFilter]
  has: [EquipmentNameAliasHasFilter]
  id: [ID!]
  not: EquipmentNameAliasFilter
  or: [EquipmentNameAliasFilter]
  system: StringFullTextFilter
}

enum EquipmentNameAliasHasFilter {
  alias
  equipment
  system
}

input EquipmentNameAliasOrder {
  asc: EquipmentNameAliasOrderable
  desc: EquipmentNameAliasOrderable
  then: EquipmentNameAliasOrder
}

enum EquipmentNameAliasOrderable {
  alias
  system
}

input EquipmentNameAliasPatch {
  alias: String
  equipment: EquipmentRef
  system: String
}

input EquipmentNameAliasRef {
  alias: String
  equipment: EquipmentRef
  id: ID
  system: String
}

input EquipmentOrder {
  asc: EquipmentOrderable
  desc: EquipmentOrderable
  then: EquipmentOrder
}

enum EquipmentOrderable {
  addressTemplate
  dataProviderConnection
  description
  displayName
  erpAssetID
  label
  mpmAutoIdentMatchSource
  mpmPermissiveOutputName
  name
  ocsChosenStopTime
  ocsPageState
  ocsWorkflowSelector
  timeZoneName
}

input EquipmentPatch {
  addressTemplate: String
  allowAdhocWorklog: Boolean
  carriers: [CarrierRef]
  children: [EquipmentRef]
  dataProvider: DataProvider
  dataProviderConnection: String
  description: String
  displayName: String
  equipmentActual: [EquipmentActualRef]
  equipmentClass: EquipmentClassRef
  equipmentLevel: EquipmentElementLevel
  erpAssetID: String
  events: [EventLogRef]
  inflows: [EquipmentRelationRef]
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  isActive: Boolean
  jobOrders: [JobOrderRef]
  jobResponses: [JobResponseRef]
  label: String
  materialSubLots: [MaterialSubLotRef]
  mpmAutoIdentMatchSource: String
  mpmEnableAutoIdentMatching: Boolean
  mpmEnableCallMaintenanceEvent: Boolean
  mpmEnableJobInterlock: Boolean
  mpmEnableMaintenanceHandover: Boolean
  mpmEnableManualBreak: Boolean
  mpmEnableManualPlannedMaint: Boolean
  mpmEnableManualShiftEnd: Boolean
  mpmEnableManualShiftStart: Boolean
  mpmEnableORCBlockNextOrder: Boolean
  mpmEnableORCRevokePermissive: Boolean
  mpmEnableORCWarning: Boolean
  mpmEnableSetupCloseDetection: Boolean
  mpmEnableSetupStartDetection: Boolean
  mpmORCRevokePermissiveTrigger: mpmORCRevokeTriggers
  mpmORCWarnTrigger: mpmORCWarnTriggers
  mpmPermissiveOutputName: String
  name: String
  ocsChosenStopTime: DateTime
  ocsEnabled: Boolean
  ocsPageState: String
  ocsWorkflowSelector: String
  operationsRequests: [OperationsRequestRef]
  orders: [OrderRef]
  outflows: [EquipmentRelationRef]
  parent: EquipmentRef
  properties: [PropertyRef]
  propertyNameAliases: [PropertyNameAliasRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  quantities: [QuantityLogRef]
  reasonOverrides: [EquipmentReasonOverrideRef]
  reasons: [ReasonRef]
  shipmentItems: [ShipmentItemRef]
  shipments: [ShipmentRef]
  timeZoneName: String
  userRoles: [UserRoleRef]
  workCalendar: WorkCalendarRef
  workSpecifications: [EquipmentSpecificationRef]
  workflowInstances: [WorkflowInstanceRef]
}

type EquipmentPropertyOverride {
  address: String
  equipment(filter: EquipmentFilter): Equipment!
  expression: String
  id: ID!
  ignore: Boolean
  isActive: Boolean
  property(filter: PropertyFilter): Property!
  storeHistory: Boolean
  value: String
}

type EquipmentPropertyOverrideAggregateResult {
  addressMax: String
  addressMin: String
  count: Int
  expressionMax: String
  expressionMin: String
  valueMax: String
  valueMin: String
}

input EquipmentPropertyOverrideFilter {
  and: [EquipmentPropertyOverrideFilter]
  has: [EquipmentPropertyOverrideHasFilter]
  id: [ID!]
  isActive: Boolean
  not: EquipmentPropertyOverrideFilter
  or: [EquipmentPropertyOverrideFilter]
}

enum EquipmentPropertyOverrideHasFilter {
  address
  equipment
  expression
  ignore
  isActive
  property
  storeHistory
  value
}

input EquipmentPropertyOverrideOrder {
  asc: EquipmentPropertyOverrideOrderable
  desc: EquipmentPropertyOverrideOrderable
  then: EquipmentPropertyOverrideOrder
}

enum EquipmentPropertyOverrideOrderable {
  address
  expression
  value
}

input EquipmentPropertyOverridePatch {
  address: String
  equipment: EquipmentRef
  expression: String
  ignore: Boolean
  isActive: Boolean
  property: PropertyRef
  storeHistory: Boolean
  value: String
}

input EquipmentPropertyOverrideRef {
  address: String
  equipment: EquipmentRef
  expression: String
  id: ID
  ignore: Boolean
  isActive: Boolean
  property: PropertyRef
  storeHistory: Boolean
  value: String
}

# EquipmentReasonOverrides are used to make equipment specific changes to equipment class reasons.
# This allows 'Master Lists' of reasons to be defined on the equipment class and for overrides to the master
# reasons to be made at the equipment level
type EquipmentReasonOverride {
  equipment(filter: EquipmentFilter): Equipment
  id: ID!
  ignore: Boolean
  isActive: Boolean
  reason(filter: ReasonFilter): Reason
  standardValue: Float
}

type EquipmentReasonOverrideAggregateResult {
  count: Int
  standardValueAvg: Float
  standardValueMax: Float
  standardValueMin: Float
  standardValueSum: Float
}

input EquipmentReasonOverrideFilter {
  and: [EquipmentReasonOverrideFilter]
  has: [EquipmentReasonOverrideHasFilter]
  id: [ID!]
  isActive: Boolean
  not: EquipmentReasonOverrideFilter
  or: [EquipmentReasonOverrideFilter]
}

enum EquipmentReasonOverrideHasFilter {
  equipment
  ignore
  isActive
  reason
  standardValue
}

input EquipmentReasonOverrideOrder {
  asc: EquipmentReasonOverrideOrderable
  desc: EquipmentReasonOverrideOrderable
  then: EquipmentReasonOverrideOrder
}

enum EquipmentReasonOverrideOrderable {
  standardValue
}

input EquipmentReasonOverridePatch {
  equipment: EquipmentRef
  ignore: Boolean
  isActive: Boolean
  reason: ReasonRef
  standardValue: Float
}

input EquipmentReasonOverrideRef {
  equipment: EquipmentRef
  id: ID
  ignore: Boolean
  isActive: Boolean
  reason: ReasonRef
  standardValue: Float
}

input EquipmentRef {
  addressTemplate: String
  allowAdhocWorklog: Boolean
  carriers: [CarrierRef]
  children: [EquipmentRef]
  dataProvider: DataProvider
  dataProviderConnection: String
  description: String
  displayName: String
  equipmentActual: [EquipmentActualRef]
  equipmentClass: EquipmentClassRef
  equipmentLevel: EquipmentElementLevel
  erpAssetID: String
  events: [EventLogRef]
  id: ID
  inflows: [EquipmentRelationRef]
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  isActive: Boolean
  jobOrders: [JobOrderRef]
  jobResponses: [JobResponseRef]
  label: String
  materialSubLots: [MaterialSubLotRef]
  mpmAutoIdentMatchSource: String
  mpmEnableAutoIdentMatching: Boolean
  mpmEnableCallMaintenanceEvent: Boolean
  mpmEnableJobInterlock: Boolean
  mpmEnableMaintenanceHandover: Boolean
  mpmEnableManualBreak: Boolean
  mpmEnableManualPlannedMaint: Boolean
  mpmEnableManualShiftEnd: Boolean
  mpmEnableManualShiftStart: Boolean
  mpmEnableORCBlockNextOrder: Boolean
  mpmEnableORCRevokePermissive: Boolean
  mpmEnableORCWarning: Boolean
  mpmEnableSetupCloseDetection: Boolean
  mpmEnableSetupStartDetection: Boolean
  mpmORCRevokePermissiveTrigger: mpmORCRevokeTriggers
  mpmORCWarnTrigger: mpmORCWarnTriggers
  mpmPermissiveOutputName: String
  name: String
  ocsChosenStopTime: DateTime
  ocsEnabled: Boolean
  ocsPageState: String
  ocsWorkflowSelector: String
  operationsRequests: [OperationsRequestRef]
  orders: [OrderRef]
  outflows: [EquipmentRelationRef]
  parent: EquipmentRef
  properties: [PropertyRef]
  propertyNameAliases: [PropertyNameAliasRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  quantities: [QuantityLogRef]
  reasonOverrides: [EquipmentReasonOverrideRef]
  reasons: [ReasonRef]
  shipmentItems: [ShipmentItemRef]
  shipments: [ShipmentRef]
  timeZoneName: String
  userRoles: [UserRoleRef]
  workCalendar: WorkCalendarRef
  workSpecifications: [EquipmentSpecificationRef]
  workflowInstances: [WorkflowInstanceRef]
}

type EquipmentRelation {
  from(filter: EquipmentFilter): Equipment!
  id: ID!
  isActive: Boolean
  to(filter: EquipmentFilter): Equipment
  type: EquipmentRelationshipType!
}

type EquipmentRelationAggregateResult {
  count: Int
}

input EquipmentRelationFilter {
  and: [EquipmentRelationFilter]
  has: [EquipmentRelationHasFilter]
  id: [ID!]
  isActive: Boolean
  not: EquipmentRelationFilter
  or: [EquipmentRelationFilter]
}

enum EquipmentRelationHasFilter {
  from
  isActive
  to
  type
}

input EquipmentRelationPatch {
  from: EquipmentRef
  isActive: Boolean
  to: EquipmentRef
  type: EquipmentRelationshipType
}

input EquipmentRelationRef {
  from: EquipmentRef
  id: ID
  isActive: Boolean
  to: EquipmentRef
  type: EquipmentRelationshipType
}

enum EquipmentRelationshipType {
  PERMANENT
  TEMPORARY
}

type EquipmentSpecification {
  description: String
  equipment(filter: EquipmentFilter): Equipment
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass
  id: ID!
  isActive: Boolean
  jobOrder(filter: JobOrderFilter): JobOrder
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment
  quantity: Float
  uom(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type EquipmentSpecificationAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input EquipmentSpecificationFilter {
  and: [EquipmentSpecificationFilter]
  has: [EquipmentSpecificationHasFilter]
  id: [ID!]
  isActive: Boolean
  not: EquipmentSpecificationFilter
  or: [EquipmentSpecificationFilter]
}

enum EquipmentSpecificationHasFilter {
  description
  equipment
  equipmentClass
  isActive
  jobOrder
  operationsSegment
  quantity
  uom
}

input EquipmentSpecificationOrder {
  asc: EquipmentSpecificationOrderable
  desc: EquipmentSpecificationOrderable
  then: EquipmentSpecificationOrder
}

enum EquipmentSpecificationOrderable {
  description
  quantity
}

input EquipmentSpecificationPatch {
  description: String
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

input EquipmentSpecificationRef {
  description: String
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

# Multiple equipment events can be defined for an Equipment Template.
type EventDefinition {
  delayOption: Boolean
  delayTime: Int
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass
  id: ID!
  isActive: Boolean
  materialEventRuleset(filter: MaterialEventRulesetFilter): MaterialEventRuleset
  messageClass: MessageClass!
  name: String!
  orderStartRuleset(filter: OrderStartRulesetFilter): OrderStartRuleset
  payloadFields(
    filter: PayloadFieldDefinitionFilter
    first: Int
    offset: Int
    order: PayloadFieldDefinitionOrder
  ): [PayloadFieldDefinition]
  payloadFieldsAggregate(
    filter: PayloadFieldDefinitionFilter
  ): PayloadFieldDefinitionAggregateResult
  payloadProperties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  payloadPropertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  stateEventRuleset(filter: StateEventRulesetFilter): StateEventRuleset
  transitionEventRuleset(
    filter: TransitionEventRulesetFilter
  ): TransitionEventRuleset
  triggerExpression: String!
  triggerProperties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  triggerPropertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
}

type EventDefinitionAggregateResult {
  count: Int
  delayTimeAvg: Float
  delayTimeMax: Int
  delayTimeMin: Int
  delayTimeSum: Int
  nameMax: String
  nameMin: String
  triggerExpressionMax: String
  triggerExpressionMin: String
}

input EventDefinitionFilter {
  and: [EventDefinitionFilter]
  has: [EventDefinitionHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: EventDefinitionFilter
  or: [EventDefinitionFilter]
}

enum EventDefinitionHasFilter {
  delayOption
  delayTime
  equipmentClass
  isActive
  materialEventRuleset
  messageClass
  name
  orderStartRuleset
  payloadFields
  payloadProperties
  stateEventRuleset
  transitionEventRuleset
  triggerExpression
  triggerProperties
}

input EventDefinitionOrder {
  asc: EventDefinitionOrderable
  desc: EventDefinitionOrderable
  then: EventDefinitionOrder
}

enum EventDefinitionOrderable {
  delayTime
  name
  triggerExpression
}

input EventDefinitionPatch {
  delayOption: Boolean
  delayTime: Int
  equipmentClass: EquipmentClassRef
  isActive: Boolean
  materialEventRuleset: MaterialEventRulesetRef
  messageClass: MessageClass
  name: String
  orderStartRuleset: OrderStartRulesetRef
  payloadFields: [PayloadFieldDefinitionRef]
  payloadProperties: [PropertyRef]
  stateEventRuleset: StateEventRulesetRef
  transitionEventRuleset: TransitionEventRulesetRef
  triggerExpression: String
  triggerProperties: [PropertyRef]
}

input EventDefinitionRef {
  delayOption: Boolean
  delayTime: Int
  equipmentClass: EquipmentClassRef
  id: ID
  isActive: Boolean
  materialEventRuleset: MaterialEventRulesetRef
  messageClass: MessageClass
  name: String
  orderStartRuleset: OrderStartRulesetRef
  payloadFields: [PayloadFieldDefinitionRef]
  payloadProperties: [PropertyRef]
  stateEventRuleset: StateEventRulesetRef
  transitionEventRuleset: TransitionEventRulesetRef
  triggerExpression: String
  triggerProperties: [PropertyRef]
}

type EventLog {
  comments: String
  duration: Float
  endDateTime: DateTime
  equipment(filter: EquipmentFilter): Equipment
  id: ID!
  isActive: Boolean
  jobResponse(filter: JobResponseFilter): JobResponse!
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  startDateTime: DateTime
}

type EventLogAggregateResult {
  commentsMax: String
  commentsMin: String
  count: Int
  durationAvg: Float
  durationMax: Float
  durationMin: Float
  durationSum: Float
  endDateTimeMax: DateTime
  endDateTimeMin: DateTime
  reasonCategoryCodeMax: String
  reasonCategoryCodeMin: String
  reasonCodeMax: String
  reasonCodeMin: String
  reasonTextMax: String
  reasonTextMin: String
  reasonValueAvg: Float
  reasonValueMax: Float
  reasonValueMin: Float
  reasonValueSum: Float
  startDateTimeMax: DateTime
  startDateTimeMin: DateTime
}

input EventLogFilter {
  and: [EventLogFilter]
  comments: StringHashFilter
  endDateTime: DateTimeFilter
  has: [EventLogHasFilter]
  id: [ID!]
  isActive: Boolean
  not: EventLogFilter
  or: [EventLogFilter]
  reasonCategoryCode: StringHashFilter
  reasonCode: StringHashFilter
  reasonText: StringHashFilter
  startDateTime: DateTimeFilter
}

enum EventLogHasFilter {
  comments
  duration
  endDateTime
  equipment
  isActive
  jobResponse
  reasonCategoryCode
  reasonCode
  reasonText
  reasonValue
  reasonValueUoM
  startDateTime
}

input EventLogOrder {
  asc: EventLogOrderable
  desc: EventLogOrderable
  then: EventLogOrder
}

enum EventLogOrderable {
  comments
  duration
  endDateTime
  reasonCategoryCode
  reasonCode
  reasonText
  reasonValue
  startDateTime
}

input EventLogPatch {
  comments: String
  duration: Float
  endDateTime: DateTime
  equipment: EquipmentRef
  isActive: Boolean
  jobResponse: JobResponseRef
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: UnitOfMeasureRef
  startDateTime: DateTime
}

input EventLogRef {
  comments: String
  duration: Float
  endDateTime: DateTime
  equipment: EquipmentRef
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: UnitOfMeasureRef
  startDateTime: DateTime
}

type EventLogTs {
  ISO22400Status: String
  PackMLStatus: String
  comment: String
  equipment: Equipment
  eventTime: DateTime
  previousTime: DateTime
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: String
}

# input for splitEventLog or updateEventLog methods
input EventLogTsInput {
  comment: String

  # a reference to the equipment the event is on
  equipment: ExtEquipmentRef!

  # the start time of the inputted event
  eventStartTime: DateTime!
  packMLStatus: String
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: String
}

# An event from the eventLog
type EventsByField {
  # Returns the duration if packML is execute, otherwise returns 0. Useful for visualisation tools
  availability: Int
  comment: String

  # The elapsed time between startDateTime and endDateTime
  duration: Int

  # The end of the event
  endDateTime: DateTime
  packMLStatus: String
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: String

  # The description of the work calendar entry associated with this event
  shiftDescription: String
  shiftFinishDateTime: DateTime

  # The id of the work calendar entry associated with this event
  shiftId: String
  shiftStartDateTime: DateTime

  # The start of the event
  startDateTime: DateTime
}

# the filter for an eventsByField query
input EventsByFieldFilter {
  # when used with filterValue, returns all records except those that contain the value
  # specified by filterValue in the field specified by this variable
  filterField: String

  # when used with filterField, returns all records except those that contain the
  # value specified by this variable in the field specified by filterfield
  filterValue: String

  # if the the query result would be empty,
  # instead return the last result within the last 4 weeks of the start of the query
  findPreviousWhenEmpty: Boolean

  # returns all events between this timestamp and the timestamp specified by to.
  # If only from is specified, to defaults to the current time
  from: DateTime

  # when true, changes the start time of the first response in the event list to be the start of the job response,
  # or the filter's from field if the original time is earlier than the modified time
  interpolateAtRangeBoundary: Boolean

  # will associate and split events based on work calendar entries when set to true
  provideShiftInformation: Boolean

  # records will only return if the field specified by this variable is null
  returnUnassignedField: String

  # returns all events between this timestamp and the timestamp specified by from.
  # If only from is specified, this value defaults to the current time
  to: DateTime

  # limits the number of results that return
  topN: Int
}

# aggregated information about a group of events
type EventSummaryByReason {
  comment: String

  # the number of events in the group
  count: Int

  # the total duration of the group of events
  durationSum: Int
  iSO22400Status: String
  packMLStatus: String
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: String
}

# the filter for an eventSummaryByReason query
input EventSummaryByReasonFilter {
  # if set to true, will only perform grouping and aggregations on events that have
  # packmlStatus != execute
  downtimeOnly: Boolean
  from: DateTime

  # specifies the field that events will group on. the default value is reasonText
  groupBy: String

  # specifies whether the results should be sorted by duration or by count.
  # Valid inputs are 'duration' and 'count'
  sortBy: String
  to: DateTime

  # limits the number of results that return
  topN: Int
}

input ExtCarrierRef {
  id: ID
}

input ExtDeliveryRef {
  id: ID
}

input ExtEquipmentRef {
  id: ID
  name: String
}

input ExtJobResponseRef {
  id: ID
}

input ExtMaterialDefinitionRef {
  code: String
  id: ID
}

input ExtMaterialLotRef {
  id: ID
}

input ExtMaterialStatusRef {
  code: String
  id: ID
}

input ExtMaterialSubLotRef {
  code: String
  id: ID
}

input ExtPartnerRef {
  id: ID
}

input ExtShipmentItemRef {
  id: ID
}

input ExtShipmentRef {
  id: ID
}

input ExtUnitOfMeasureRef {
  id: ID
}

input ExtUserRef {
  id: ID
  username: String
}

input ExtWorkflowNodeInstanceRef {
  id: String!
}

input ExtWorkflowPropertyRef {
  name: String!
  value: String!
}

input ExtWorkflowSpecificationRef {
  id: String!
}

input FloatFilter {
  between: FloatRange
  eq: Float
  ge: Float
  gt: Float
  in: [Float]
  le: Float
  lt: Float
}

input FloatRange {
  max: Float!
  min: Float!
}

type Form {
  id: ID!
  isActive: Boolean
  jsonSchema: String
  name: String!
  uiSchema: String
  workflowNodes(
    filter: WorkflowNodeFilter
    first: Int
    offset: Int
    order: WorkflowNodeOrder
  ): [WorkflowNode]
  workflowNodesAggregate(
    filter: WorkflowNodeFilter
  ): WorkflowNodeAggregateResult
}

type FormAggregateResult {
  count: Int
  jsonSchemaMax: String
  jsonSchemaMin: String
  nameMax: String
  nameMin: String
  uiSchemaMax: String
  uiSchemaMin: String
}

input FormFilter {
  and: [FormFilter]
  has: [FormHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: FormFilter
  or: [FormFilter]
}

enum FormHasFilter {
  isActive
  jsonSchema
  name
  uiSchema
  workflowNodes
}

input FormOrder {
  asc: FormOrderable
  desc: FormOrderable
  then: FormOrder
}

enum FormOrderable {
  jsonSchema
  name
  uiSchema
}

input FormPatch {
  isActive: Boolean
  jsonSchema: String
  uiSchema: String
  workflowNodes: [WorkflowNodeRef]
}

input FormRef {
  id: ID
  isActive: Boolean
  jsonSchema: String
  name: String
  uiSchema: String
  workflowNodes: [WorkflowNodeRef]
}

enum Frequency {
  DAILY
  HOURLY
  MINUTELY
  MONTHLY
  SECONDLY
  WEEKLY
  YEARLY
}

type GeneralLedgerAccount {
  code: String!
  id: ID!
  name: String
  type: String
}

type GeneralLedgerAccountAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
  nameMax: String
  nameMin: String
  typeMax: String
  typeMin: String
}

input GeneralLedgerAccountFilter {
  and: [GeneralLedgerAccountFilter]
  code: StringHashFilter
  has: [GeneralLedgerAccountHasFilter]
  id: [ID!]
  not: GeneralLedgerAccountFilter
  or: [GeneralLedgerAccountFilter]
}

enum GeneralLedgerAccountHasFilter {
  code
  name
  type
}

input GeneralLedgerAccountOrder {
  asc: GeneralLedgerAccountOrderable
  desc: GeneralLedgerAccountOrderable
  then: GeneralLedgerAccountOrder
}

enum GeneralLedgerAccountOrderable {
  code
  name
  type
}

input GeneralLedgerAccountPatch {
  name: String
  type: String
}

input GeneralLedgerAccountRef {
  code: String
  id: ID
  name: String
  type: String
}

input GenerateMutationParams {
  add: Boolean
  delete: Boolean
  update: Boolean
}

input GenerateQueryParams {
  aggregate: Boolean
  get: Boolean
  password: Boolean
  query: Boolean
}

input GetPackingReturnInstructionsPDFInput {
  OrderNumber: String!
  SerialNumbers: [String!]!
}

enum HTTPMethod {
  DELETE
  GET
  PATCH
  POST
  PUT
}

enum IncoTerms {
  CPT
  DAP
  DDP
}

type InputError {
  message: String
}

# The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
# Int64 can represent values in range [-(2^63),(2^63 - 1)].
scalar Int64

input Int64Filter {
  between: Int64Range
  eq: Int64
  ge: Int64
  gt: Int64
  in: [Int64]
  le: Int64
  lt: Int64
}

input Int64Range {
  max: Int64!
  min: Int64!
}

type InterfaceMessageLog {
  component: String
  createdDateTime: DateTime
  errorMessage: String
  id: ID!
  level: String
  message: String
  payload: String
  status: String
}

type InterfaceMessageLogAggregateResult {
  componentMax: String
  componentMin: String
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  errorMessageMax: String
  errorMessageMin: String
  levelMax: String
  levelMin: String
  messageMax: String
  messageMin: String
  payloadMax: String
  payloadMin: String
  statusMax: String
  statusMin: String
}

input InterfaceMessageLogFilter {
  and: [InterfaceMessageLogFilter]
  component: StringTermFilter
  createdDateTime: DateTimeFilter
  has: [InterfaceMessageLogHasFilter]
  id: [ID!]
  level: StringTermFilter
  message: StringTermFilter
  not: InterfaceMessageLogFilter
  or: [InterfaceMessageLogFilter]
  status: StringTermFilter
}

enum InterfaceMessageLogHasFilter {
  component
  createdDateTime
  errorMessage
  level
  message
  payload
  status
}

input InterfaceMessageLogOrder {
  asc: InterfaceMessageLogOrderable
  desc: InterfaceMessageLogOrderable
  then: InterfaceMessageLogOrder
}

enum InterfaceMessageLogOrderable {
  component
  createdDateTime
  errorMessage
  level
  message
  payload
  status
}

input InterfaceMessageLogPatch {
  component: String
  createdDateTime: DateTime
  errorMessage: String
  level: String
  message: String
  payload: String
  status: String
}

input InterfaceMessageLogRef {
  component: String
  createdDateTime: DateTime
  errorMessage: String
  id: ID
  level: String
  message: String
  payload: String
  status: String
}

input IntersectsFilter {
  multiPolygon: MultiPolygonRef
  polygon: PolygonRef
}

input IntFilter {
  between: IntRange
  eq: Int
  ge: Int
  gt: Int
  in: [Int]
  le: Int
  lt: Int
}

input IntRange {
  max: Int!
  min: Int!
}

type InventoryHandlingPolicy {
  id: ID!
  isActive: Boolean
  materialClass(
    filter: MaterialClassFilter
    first: Int
    offset: Int
    order: MaterialClassOrder
  ): [MaterialClass]
  materialClassAggregate(
    filter: MaterialClassFilter
  ): MaterialClassAggregateResult
  name: String!
  rules(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  rulesAggregate(
    filter: InventoryHandlingRuleFilter
  ): InventoryHandlingRuleAggregateResult
  trackByCarrier: Boolean
  trackBySerialNumber: Boolean
  verifySerialNumberOnPacking: Boolean
  verifySerialNumberOnReceipt: Boolean
}

type InventoryHandlingPolicyAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
}

input InventoryHandlingPolicyFilter {
  and: [InventoryHandlingPolicyFilter]
  has: [InventoryHandlingPolicyHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: InventoryHandlingPolicyFilter
  or: [InventoryHandlingPolicyFilter]
}

enum InventoryHandlingPolicyHasFilter {
  isActive
  materialClass
  name
  rules
  trackByCarrier
  trackBySerialNumber
  verifySerialNumberOnPacking
  verifySerialNumberOnReceipt
}

input InventoryHandlingPolicyOrder {
  asc: InventoryHandlingPolicyOrderable
  desc: InventoryHandlingPolicyOrderable
  then: InventoryHandlingPolicyOrder
}

enum InventoryHandlingPolicyOrderable {
  name
}

input InventoryHandlingPolicyPatch {
  isActive: Boolean
  materialClass: [MaterialClassRef]
  rules: [InventoryHandlingRuleRef]
  trackByCarrier: Boolean
  trackBySerialNumber: Boolean
  verifySerialNumberOnPacking: Boolean
  verifySerialNumberOnReceipt: Boolean
}

input InventoryHandlingPolicyRef {
  id: ID
  isActive: Boolean
  materialClass: [MaterialClassRef]
  name: String
  rules: [InventoryHandlingRuleRef]
  trackByCarrier: Boolean
  trackBySerialNumber: Boolean
  verifySerialNumberOnPacking: Boolean
  verifySerialNumberOnReceipt: Boolean
}

type InventoryHandlingRule {
  customer(filter: PartnerFilter): Partner!
  id: ID!
  inventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
  ): InventoryHandlingPolicy!
  inventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    first: Int
    offset: Int
    order: InventoryHoldingPolicyOrder
  ): [InventoryHoldingPolicy]
  inventoryHoldingPolicyAggregate(
    filter: InventoryHoldingPolicyFilter
  ): InventoryHoldingPolicyAggregateResult
  isActive: Boolean
  stateModel(filter: MaterialStateModelFilter): MaterialStateModel!
  stockType: StockType!
  warehouse(
    filter: EquipmentFilter
    first: Int
    offset: Int
    order: EquipmentOrder
  ): [Equipment!]!
  warehouseAggregate(filter: EquipmentFilter): EquipmentAggregateResult
}

type InventoryHandlingRuleAggregateResult {
  count: Int
}

input InventoryHandlingRuleFilter {
  and: [InventoryHandlingRuleFilter]
  has: [InventoryHandlingRuleHasFilter]
  id: [ID!]
  isActive: Boolean
  not: InventoryHandlingRuleFilter
  or: [InventoryHandlingRuleFilter]
  stockType: StockType_hash
}

enum InventoryHandlingRuleHasFilter {
  customer
  inventoryHandlingPolicy
  inventoryHoldingPolicy
  isActive
  stateModel
  stockType
  warehouse
}

input InventoryHandlingRulePatch {
  customer: PartnerRef
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
  stateModel: MaterialStateModelRef
  stockType: StockType
  warehouse: [EquipmentRef!]
}

input InventoryHandlingRuleRef {
  customer: PartnerRef
  id: ID
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
  stateModel: MaterialStateModelRef
  stockType: StockType
  warehouse: [EquipmentRef!]
}

# The settings used to plan for when more material should be processed or purchased
type InventoryHoldingPolicy {
  id: ID!
  inventoryHandlingRule(
    filter: InventoryHandlingRuleFilter
  ): InventoryHandlingRule!
  inventoryMax: Int
  inventoryMin: Int
  isActive: Boolean
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
  materialStatus(filter: MaterialStatusFilter): MaterialStatus!
}

type InventoryHoldingPolicyAggregateResult {
  count: Int
  inventoryMaxAvg: Float
  inventoryMaxMax: Int
  inventoryMaxMin: Int
  inventoryMaxSum: Int
  inventoryMinAvg: Float
  inventoryMinMax: Int
  inventoryMinMin: Int
  inventoryMinSum: Int
}

input InventoryHoldingPolicyFilter {
  and: [InventoryHoldingPolicyFilter]
  has: [InventoryHoldingPolicyHasFilter]
  id: [ID!]
  isActive: Boolean
  not: InventoryHoldingPolicyFilter
  or: [InventoryHoldingPolicyFilter]
}

enum InventoryHoldingPolicyHasFilter {
  inventoryHandlingRule
  inventoryMax
  inventoryMin
  isActive
  material
  materialStatus
}

input InventoryHoldingPolicyOrder {
  asc: InventoryHoldingPolicyOrderable
  desc: InventoryHoldingPolicyOrderable
  then: InventoryHoldingPolicyOrder
}

enum InventoryHoldingPolicyOrderable {
  inventoryMax
  inventoryMin
}

input InventoryHoldingPolicyPatch {
  inventoryHandlingRule: InventoryHandlingRuleRef
  inventoryMax: Int
  inventoryMin: Int
  isActive: Boolean
  material: MaterialDefinitionRef
  materialStatus: MaterialStatusRef
}

input InventoryHoldingPolicyRef {
  id: ID
  inventoryHandlingRule: InventoryHandlingRuleRef
  inventoryMax: Int
  inventoryMin: Int
  isActive: Boolean
  material: MaterialDefinitionRef
  materialStatus: MaterialStatusRef
}

type InventoryTransaction {
  carrier: Carrier
  comment: String
  effectiveTimestamp: DateTime
  jobResponse: JobResponse
  material: MaterialDefinition
  materialLot: MaterialLot
  materialSubLot: MaterialSubLot
  materialUse: MaterialUse
  owner: Partner
  quantity: Float!
  reason: String
  shipment: Shipment
  shipmentItem: ShipmentItem
  status: MaterialStatus!
  storageLocation: Equipment
  timestamp: DateTime!
  user: User
}

input InventoryTransactionInput {
  carrier: ExtCarrierRef
  effectiveDateTime: DateTime
  material: ExtMaterialDefinitionRef
  materialSubLot: ExtMaterialSubLotRef
  materialUse: MaterialUse
  owner: ExtPartnerRef
  quantity: Float
  shipment: ExtShipmentRef
  shipmentItem: ExtShipmentItemRef
  status: ExtMaterialStatusRef
  storageLocation: ExtEquipmentRef
  user: ExtUserRef
}

input InventoryTransactionsRawFilter {
  carrier: ExtCarrierRef
  from: DateTime
  jobResponse: ExtJobResponseRef
  material: ExtMaterialDefinitionRef
  materialSubLot: ExtMaterialSubLotRef
  shipment: ExtShipmentRef
  shipmentItem: ExtShipmentItemRef
  status: ExtMaterialStatusRef
  storageLocation: ExtEquipmentRef
  to: DateTime
}

type JobOrder {
  children(
    filter: JobOrderFilter
    first: Int
    offset: Int
    order: JobOrderOrder
  ): [JobOrder]
  childrenAggregate(filter: JobOrderFilter): JobOrderAggregateResult
  createdDateTime: DateTime
  description: String
  dispatchStatus: DispatchStatus
  duration: Float
  durationUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  equipment(filter: EquipmentFilter): Equipment
  equipmentSpecifications(
    filter: EquipmentSpecificationFilter
    first: Int
    offset: Int
    order: EquipmentSpecificationOrder
  ): [EquipmentSpecification]
  equipmentSpecificationsAggregate(
    filter: EquipmentSpecificationFilter
  ): EquipmentSpecificationAggregateResult
  hierarchyScope: String
  id: ID!
  inflows(
    filter: JobOrderDependencyFilter
    first: Int
    offset: Int
    order: JobOrderDependencyOrder
  ): [JobOrderDependency]
  inflowsAggregate(
    filter: JobOrderDependencyFilter
  ): JobOrderDependencyAggregateResult
  isActive: Boolean
  jobOrderNotes(
    filter: JobOrderNoteFilter
    first: Int
    offset: Int
    order: JobOrderNoteOrder
  ): [JobOrderNote]
  jobOrderNotesAggregate(
    filter: JobOrderNoteFilter
  ): JobOrderNoteAggregateResult
  jobResponses(
    filter: JobResponseFilter
    first: Int
    offset: Int
    order: JobResponseOrder
  ): [JobResponse]
  jobResponsesAggregate(filter: JobResponseFilter): JobResponseAggregateResult
  lastEvent(filter: LastEventFilter): EventsByField
  materialSpecifications(
    filter: MaterialSpecificationFilter
    first: Int
    offset: Int
    order: MaterialSpecificationOrder
  ): [MaterialSpecification]
  materialSpecificationsAggregate(
    filter: MaterialSpecificationFilter
  ): MaterialSpecificationAggregateResult
  name: String!
  next(
    filter: JobOrderFilter
    first: Int
    offset: Int
    order: JobOrderOrder
  ): [JobOrder]
  nextAggregate(filter: JobOrderFilter): JobOrderAggregateResult
  operationsRequest(filter: OperationsRequestFilter): OperationsRequest
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment
  outflows(
    filter: JobOrderDependencyFilter
    first: Int
    offset: Int
    order: JobOrderDependencyOrder
  ): [JobOrderDependency]
  outflowsAggregate(
    filter: JobOrderDependencyFilter
  ): JobOrderDependencyAggregateResult
  parameterSpecifications(
    filter: ParameterSpecificationFilter
    first: Int
    offset: Int
    order: ParameterSpecificationOrder
  ): [ParameterSpecification]
  parameterSpecificationsAggregate(
    filter: ParameterSpecificationFilter
  ): ParameterSpecificationAggregateResult
  parent(filter: JobOrderFilter): JobOrder
  personnelSpecifications(
    filter: PersonnelSpecificationFilter
    first: Int
    offset: Int
    order: PersonnelSpecificationOrder
  ): [PersonnelSpecification]
  personnelSpecificationsAggregate(
    filter: PersonnelSpecificationFilter
  ): PersonnelSpecificationAggregateResult
  previous(
    filter: JobOrderFilter
    first: Int
    offset: Int
    order: JobOrderOrder
  ): [JobOrder]
  previousAggregate(filter: JobOrderFilter): JobOrderAggregateResult
  priority: Int
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  quantity: Float
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  scheduledDuration: Float
  scheduledEndDateTime: DateTime
  scheduledStartDateTime: DateTime
  version: String
  workDefinitionType: String
  workType: WorkType
}

type JobOrderAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  descriptionMax: String
  descriptionMin: String
  durationAvg: Float
  durationMax: Float
  durationMin: Float
  durationSum: Float
  hierarchyScopeMax: String
  hierarchyScopeMin: String
  nameMax: String
  nameMin: String
  priorityAvg: Float
  priorityMax: Int
  priorityMin: Int
  prioritySum: Int
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
  scheduledDurationAvg: Float
  scheduledDurationMax: Float
  scheduledDurationMin: Float
  scheduledDurationSum: Float
  scheduledEndDateTimeMax: DateTime
  scheduledEndDateTimeMin: DateTime
  scheduledStartDateTimeMax: DateTime
  scheduledStartDateTimeMin: DateTime
  versionMax: String
  versionMin: String
  workDefinitionTypeMax: String
  workDefinitionTypeMin: String
}

#  Defines the planned relationship between JobOrders. The JobOrderDependency is created from a copy
# of the SegmentDependency during the production dispatch activity
type JobOrderDependency {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  from(filter: JobOrderFilter): JobOrder!
  id: ID!
  isActive: Boolean
  segmentDependency(filter: SegmentDependencyFilter): SegmentDependency
  to(filter: JobOrderFilter): JobOrder!
}

type JobOrderDependencyAggregateResult {
  conditionMax: String
  conditionMin: String
  count: Int
  dependencyFactorAvg: Float
  dependencyFactorMax: Float
  dependencyFactorMin: Float
  dependencyFactorSum: Float
  descriptionMax: String
  descriptionMin: String
}

input JobOrderDependencyFilter {
  and: [JobOrderDependencyFilter]
  has: [JobOrderDependencyHasFilter]
  id: [ID!]
  isActive: Boolean
  not: JobOrderDependencyFilter
  or: [JobOrderDependencyFilter]
}

enum JobOrderDependencyHasFilter {
  condition
  dependencyFactor
  dependencyType
  description
  factorUoM
  from
  isActive
  segmentDependency
  to
}

input JobOrderDependencyOrder {
  asc: JobOrderDependencyOrderable
  desc: JobOrderDependencyOrderable
  then: JobOrderDependencyOrder
}

enum JobOrderDependencyOrderable {
  condition
  dependencyFactor
  description
}

input JobOrderDependencyPatch {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM: UnitOfMeasureRef
  from: JobOrderRef
  isActive: Boolean
  segmentDependency: SegmentDependencyRef
  to: JobOrderRef
}

input JobOrderDependencyRef {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM: UnitOfMeasureRef
  from: JobOrderRef
  id: ID
  isActive: Boolean
  segmentDependency: SegmentDependencyRef
  to: JobOrderRef
}

#  Define the allowable DispatchStatus transitions for JobOrder.dispatchStatus
type JobOrderDispatchStateModel {
  allowedTransition: [DispatchStatus]
  fromStatus: DispatchStatus!
}

type JobOrderDispatchStateModelAggregateResult {
  count: Int
}

input JobOrderDispatchStateModelFilter {
  and: [JobOrderDispatchStateModelFilter]
  has: [JobOrderDispatchStateModelHasFilter]
  not: JobOrderDispatchStateModelFilter
  or: [JobOrderDispatchStateModelFilter]
}

enum JobOrderDispatchStateModelHasFilter {
  allowedTransition
  fromStatus
}

input JobOrderDispatchStateModelPatch {
  allowedTransition: [DispatchStatus]
  fromStatus: DispatchStatus
}

input JobOrderDispatchStateModelRef {
  allowedTransition: [DispatchStatus]
  fromStatus: DispatchStatus
}

input JobOrderFilter {
  and: [JobOrderFilter]
  createdDateTime: DateTimeFilter
  description: StringHashFilter
  dispatchStatus: DispatchStatus_hash
  has: [JobOrderHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter_StringRegExpFilter
  not: JobOrderFilter
  or: [JobOrderFilter]
  scheduledEndDateTime: DateTimeFilter
  scheduledStartDateTime: DateTimeFilter
  workDefinitionType: StringHashFilter
  workType: WorkType_hash
}

enum JobOrderHasFilter {
  children
  createdDateTime
  description
  dispatchStatus
  duration
  durationUoM
  equipment
  equipmentSpecifications
  hierarchyScope
  inflows
  isActive
  jobOrderNotes
  jobResponses
  materialSpecifications
  name
  next
  operationsRequest
  operationsSegment
  outflows
  parameterSpecifications
  parent
  personnelSpecifications
  previous
  priority
  properties
  quantity
  quantityUoM
  scheduledDuration
  scheduledEndDateTime
  scheduledStartDateTime
  version
  workDefinitionType
  workType
}

type JobOrderNote {
  comment: String
  createdBy(filter: UserFilter): User
  createdDateTime: DateTime
  editedDateTime: DateTime
  id: ID!
  isActive: Boolean
  jobOrder(filter: JobOrderFilter): JobOrder
  modifiedBy(filter: UserFilter): User
}

type JobOrderNoteAggregateResult {
  commentMax: String
  commentMin: String
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  editedDateTimeMax: DateTime
  editedDateTimeMin: DateTime
}

input JobOrderNoteFilter {
  and: [JobOrderNoteFilter]
  has: [JobOrderNoteHasFilter]
  id: [ID!]
  not: JobOrderNoteFilter
  or: [JobOrderNoteFilter]
}

enum JobOrderNoteHasFilter {
  comment
  createdBy
  createdDateTime
  editedDateTime
  isActive
  jobOrder
  modifiedBy
}

input JobOrderNoteOrder {
  asc: JobOrderNoteOrderable
  desc: JobOrderNoteOrderable
  then: JobOrderNoteOrder
}

enum JobOrderNoteOrderable {
  comment
  createdDateTime
  editedDateTime
}

input JobOrderNotePatch {
  comment: String
  createdBy: UserRef
  createdDateTime: DateTime
  editedDateTime: DateTime
  isActive: Boolean
  jobOrder: JobOrderRef
  modifiedBy: UserRef
}

input JobOrderNoteRef {
  comment: String
  createdBy: UserRef
  createdDateTime: DateTime
  editedDateTime: DateTime
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  modifiedBy: UserRef
}

input JobOrderOrder {
  asc: JobOrderOrderable
  desc: JobOrderOrderable
  then: JobOrderOrder
}

enum JobOrderOrderable {
  createdDateTime
  description
  duration
  hierarchyScope
  name
  priority
  quantity
  scheduledDuration
  scheduledEndDateTime
  scheduledStartDateTime
  version
  workDefinitionType
}

input JobOrderPatch {
  children: [JobOrderRef]
  createdDateTime: DateTime
  description: String
  dispatchStatus: DispatchStatus
  duration: Float
  durationUoM: UnitOfMeasureRef
  equipment: EquipmentRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  hierarchyScope: String
  inflows: [JobOrderDependencyRef]
  isActive: Boolean
  jobOrderNotes: [JobOrderNoteRef]
  jobResponses: [JobResponseRef]
  materialSpecifications: [MaterialSpecificationRef]
  next: [JobOrderRef]
  operationsRequest: OperationsRequestRef
  operationsSegment: OperationsSegmentRef
  outflows: [JobOrderDependencyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  parent: JobOrderRef
  personnelSpecifications: [PersonnelSpecificationRef]
  previous: [JobOrderRef]
  priority: Int
  properties: [PropertyRef]
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  scheduledDuration: Float
  scheduledEndDateTime: DateTime
  scheduledStartDateTime: DateTime
  version: String
  workDefinitionType: String
  workType: WorkType
}

input JobOrderRef {
  children: [JobOrderRef]
  createdDateTime: DateTime
  description: String
  dispatchStatus: DispatchStatus
  duration: Float
  durationUoM: UnitOfMeasureRef
  equipment: EquipmentRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  hierarchyScope: String
  id: ID
  inflows: [JobOrderDependencyRef]
  isActive: Boolean
  jobOrderNotes: [JobOrderNoteRef]
  jobResponses: [JobResponseRef]
  materialSpecifications: [MaterialSpecificationRef]
  name: String
  next: [JobOrderRef]
  operationsRequest: OperationsRequestRef
  operationsSegment: OperationsSegmentRef
  outflows: [JobOrderDependencyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  parent: JobOrderRef
  personnelSpecifications: [PersonnelSpecificationRef]
  previous: [JobOrderRef]
  priority: Int
  properties: [PropertyRef]
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  scheduledDuration: Float
  scheduledEndDateTime: DateTime
  scheduledStartDateTime: DateTime
  version: String
  workDefinitionType: String
  workType: WorkType
}

type JobOrderStaging {
  equipment: String
  errList: [String]
  isValid: Boolean
  operationsRequest: String
  orderNo: String
  segment: String
}

input JobOrderStagingInput {
  operationsRequest: String!
  orderNo: String!
  segment: String!
}

input JobOrderStatusPatch {
  dispatchStatus: DispatchStatus
}

type JobResponse {
  actualDuration: Float
  createdDateTime: DateTime
  duration: Float
  endDateTime: DateTime
  equipment(filter: EquipmentFilter): Equipment
  equipmentActual(
    filter: EquipmentActualFilter
    first: Int
    offset: Int
    order: EquipmentActualOrder
  ): [EquipmentActual]
  equipmentActualAggregate(
    filter: EquipmentActualFilter
  ): EquipmentActualAggregateResult

  # deprecated
  eventList: [EventLog]
  eventSummaryByReason(
    filter: EventSummaryByReasonFilter
  ): [EventSummaryByReason]
  events(
    filter: EventLogFilter
    first: Int
    offset: Int
    order: EventLogOrder
  ): [EventLog]
  eventsAggregate(filter: EventLogFilter): EventLogAggregateResult
  eventsByField(filter: EventsByFieldFilter): [EventsByField]
  id: ID!
  isActive: Boolean
  jobOrder(filter: JobOrderFilter): JobOrder
  maintenanceCalls: [MaintenanceLog]
  materialActual(
    filter: MaterialActualFilter
    first: Int
    offset: Int
    order: MaterialActualOrder
  ): [MaterialActual]
  materialActualAggregate(
    filter: MaterialActualFilter
  ): MaterialActualAggregateResult
  modifiedDateTime: DateTime
  operator(filter: UserFilter): User
  personnelActual(
    filter: PersonnelActualFilter
    first: Int
    offset: Int
    order: PersonnelActualOrder
  ): [PersonnelActual]
  personnelActualAggregate(
    filter: PersonnelActualFilter
  ): PersonnelActualAggregateResult
  productionDate: String
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  quantities(
    filter: QuantityLogFilter
    first: Int
    offset: Int
    order: QuantityLogOrder
  ): [QuantityLog]
  quantitiesAggregate(filter: QuantityLogFilter): QuantityLogAggregateResult
  quantitySummary(filter: QuantitySummaryFilter): [QuantitySummary]
  runRateSummary(filter: RunRateFilter): RunRateSummary
  startDateTime: DateTime
}

type JobResponseAggregateResult {
  actualDurationAvg: Float
  actualDurationMax: Float
  actualDurationMin: Float
  actualDurationSum: Float
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  endDateTimeMax: DateTime
  endDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  productionDateMax: String
  productionDateMin: String
  startDateTimeMax: DateTime
  startDateTimeMin: DateTime
}

input JobResponseFilter {
  and: [JobResponseFilter]
  endDateTime: DateTimeFilter
  has: [JobResponseHasFilter]
  id: [ID!]
  isActive: Boolean
  not: JobResponseFilter
  or: [JobResponseFilter]
  productionDate: StringHashFilter
  startDateTime: DateTimeFilter
}

enum JobResponseHasFilter {
  actualDuration
  createdDateTime
  endDateTime
  equipment
  equipmentActual
  events
  isActive
  jobOrder
  materialActual
  modifiedDateTime
  operator
  personnelActual
  productionDate
  properties
  quantities
  startDateTime
}

input JobResponseOrder {
  asc: JobResponseOrderable
  desc: JobResponseOrderable
  then: JobResponseOrder
}

enum JobResponseOrderable {
  actualDuration
  createdDateTime
  endDateTime
  modifiedDateTime
  productionDate
  startDateTime
}

input JobResponsePatch {
  actualDuration: Float
  createdDateTime: DateTime
  endDateTime: DateTime
  equipment: EquipmentRef
  equipmentActual: [EquipmentActualRef]
  events: [EventLogRef]
  isActive: Boolean
  jobOrder: JobOrderRef
  materialActual: [MaterialActualRef]
  modifiedDateTime: DateTime
  operator: UserRef
  personnelActual: [PersonnelActualRef]
  productionDate: String
  properties: [PropertyRef]
  quantities: [QuantityLogRef]
  startDateTime: DateTime
}

input JobResponseRef {
  actualDuration: Float
  createdDateTime: DateTime
  endDateTime: DateTime
  equipment: EquipmentRef
  equipmentActual: [EquipmentActualRef]
  events: [EventLogRef]
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  materialActual: [MaterialActualRef]
  modifiedDateTime: DateTime
  operator: UserRef
  personnelActual: [PersonnelActualRef]
  productionDate: String
  properties: [PropertyRef]
  quantities: [QuantityLogRef]
  startDateTime: DateTime
}

type Kpi {
  OEE: Float
  OEEUnit: String
  availability: Float
  availabilityUnit: String
  effectiveness: Float
  effectivenessUnit: String
  equipment: Equipment
  quality: Float
  qualityUnit: String
  rawData: RawKpi
}

type KpiByWorkCalendarEntry {
  OEE: Float
  OEEUnit: String
  availability: Float
  availabilityUnit: String
  effectiveness: Float
  effectivenessUnit: String
  equipment: Equipment
  quality: Float
  qualityUnit: String
  rawData: RawKpi
  workCalendarEntry: WorkCalendarEntry
}

input LastEventFilter {
  includeField: String
  includeValue: String
}

# Store the heartbeat timestamps of connected libre-services.
# microservices can subscribe to this entity to check the status of their subscription
type LibreService {
  heartbeat: DateTime
  id: ID!
  name: String!
}

type LibreServiceAggregateResult {
  count: Int
  heartbeatMax: DateTime
  heartbeatMin: DateTime
  nameMax: String
  nameMin: String
}

input LibreServiceFilter {
  and: [LibreServiceFilter]
  has: [LibreServiceHasFilter]
  id: [ID!]
  name: StringHashFilter
  not: LibreServiceFilter
  or: [LibreServiceFilter]
}

enum LibreServiceHasFilter {
  heartbeat
  name
}

input LibreServiceOrder {
  asc: LibreServiceOrderable
  desc: LibreServiceOrderable
  then: LibreServiceOrder
}

enum LibreServiceOrderable {
  heartbeat
  name
}

input LibreServicePatch {
  heartbeat: DateTime
}

input LibreServiceRef {
  heartbeat: DateTime
  id: ID
  name: String
}

enum MachineState {
  Aborted
  Aborting
  Clearing
  Complete
  Completing
  Execute
  Held
  Holding
  Idle
  Resetting
  Starting
  Stopped
  Stopping
  Suspended
  Suspending
  Unholding
  Unsuspending
}

# An event from the maintenanceLog
type MaintenanceLog {
  comment: String
  priority: String
  requestType: String
  state: String
  time: DateTime
  type: String
  workflowInstanceID: String
}

type MaterialActual {
  id: ID!
  isActive: Boolean
  jobResponse(filter: JobResponseFilter): JobResponse!
  materialDefinition(filter: MaterialDefinitionFilter): MaterialDefinition
  materialLot(filter: MaterialLotFilter): MaterialLot
  materialSubLot(filter: MaterialSubLotFilter): MaterialSubLot
  materialUse: MaterialUse
  quantity: Float
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type MaterialActualAggregateResult {
  count: Int
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input MaterialActualFilter {
  and: [MaterialActualFilter]
  has: [MaterialActualHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialActualFilter
  or: [MaterialActualFilter]
}

enum MaterialActualHasFilter {
  isActive
  jobResponse
  materialDefinition
  materialLot
  materialSubLot
  materialUse
  quantity
  quantityUoM
}

input MaterialActualOrder {
  asc: MaterialActualOrderable
  desc: MaterialActualOrderable
  then: MaterialActualOrder
}

enum MaterialActualOrderable {
  quantity
}

input MaterialActualPatch {
  isActive: Boolean
  jobResponse: JobResponseRef
  materialDefinition: MaterialDefinitionRef
  materialLot: MaterialLotRef
  materialSubLot: MaterialSubLotRef
  materialUse: MaterialUse
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

input MaterialActualRef {
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  materialDefinition: MaterialDefinitionRef
  materialLot: MaterialLotRef
  materialSubLot: MaterialSubLotRef
  materialUse: MaterialUse
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type MaterialAlternate {
  alternateMaterial(filter: MaterialDefinitionFilter): MaterialDefinition!
  effectiveDateTime: DateTime!
  id: ID!
  isActive: Boolean
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
  priorityOrder: Int!
}

type MaterialAlternateAggregateResult {
  count: Int
  effectiveDateTimeMax: DateTime
  effectiveDateTimeMin: DateTime
  priorityOrderAvg: Float
  priorityOrderMax: Int
  priorityOrderMin: Int
  priorityOrderSum: Int
}

input MaterialAlternateFilter {
  and: [MaterialAlternateFilter]
  has: [MaterialAlternateHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialAlternateFilter
  or: [MaterialAlternateFilter]
}

enum MaterialAlternateHasFilter {
  alternateMaterial
  effectiveDateTime
  isActive
  material
  priorityOrder
}

input MaterialAlternateOrder {
  asc: MaterialAlternateOrderable
  desc: MaterialAlternateOrderable
  then: MaterialAlternateOrder
}

enum MaterialAlternateOrderable {
  effectiveDateTime
  priorityOrder
}

input MaterialAlternatePatch {
  alternateMaterial: MaterialDefinitionRef
  effectiveDateTime: DateTime
  isActive: Boolean
  material: MaterialDefinitionRef
  priorityOrder: Int
}

input MaterialAlternateRef {
  alternateMaterial: MaterialDefinitionRef
  effectiveDateTime: DateTime
  id: ID
  isActive: Boolean
  material: MaterialDefinitionRef
  priorityOrder: Int
}

# A unique identification of a specific material class, within the scope
# of the information exchanged (production capability, production
# schedule, production performance, …)
# The ID shall be used in other parts of the model when the material
# class needs to be identified, such as the production capability for
# this material class, or a production response identifying the
# material class used.
type MaterialClass {
  children(
    filter: MaterialClassFilter
    first: Int
    offset: Int
    order: MaterialClassOrder
  ): [MaterialClass]
  childrenAggregate(filter: MaterialClassFilter): MaterialClassAggregateResult
  code: String!
  description: String
  id: ID!
  inventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
  ): InventoryHandlingPolicy
  isActive: Boolean
  parent(filter: MaterialClassFilter): MaterialClass
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  scheduleSortOrder: Int
}

type MaterialClassAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
  descriptionMax: String
  descriptionMin: String
  scheduleSortOrderAvg: Float
  scheduleSortOrderMax: Int
  scheduleSortOrderMin: Int
  scheduleSortOrderSum: Int
}

input MaterialClassFilter {
  and: [MaterialClassFilter]
  code: StringHashFilter
  has: [MaterialClassHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialClassFilter
  or: [MaterialClassFilter]
}

enum MaterialClassHasFilter {
  children
  code
  description
  inventoryHandlingPolicy
  isActive
  parent
  properties
  scheduleSortOrder
}

input MaterialClassOrder {
  asc: MaterialClassOrderable
  desc: MaterialClassOrderable
  then: MaterialClassOrder
}

enum MaterialClassOrderable {
  code
  description
  scheduleSortOrder
}

input MaterialClassPatch {
  children: [MaterialClassRef]
  description: String
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  isActive: Boolean
  parent: MaterialClassRef
  properties: [PropertyRef]
  scheduleSortOrder: Int
}

input MaterialClassRef {
  children: [MaterialClassRef]
  code: String
  description: String
  id: ID
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  isActive: Boolean
  parent: MaterialClassRef
  properties: [PropertyRef]
  scheduleSortOrder: Int
}

type MaterialDefinition {
  OrderLines(
    filter: OrderLineFilter
    first: Int
    offset: Int
    order: OrderLineOrder
  ): [OrderLine]
  OrderLinesAggregate(filter: OrderLineFilter): OrderLineAggregateResult
  alternates(
    filter: MaterialAlternateFilter
    first: Int
    offset: Int
    order: MaterialAlternateOrder
  ): [MaterialAlternate]
  alternatesAggregate(
    filter: MaterialAlternateFilter
  ): MaterialAlternateAggregateResult
  baseUnitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure!
  code: String!
  customerMaterialCode: String
  description: String
  id: ID!
  inventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
  ): InventoryHandlingPolicy
  inventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    first: Int
    offset: Int
    order: InventoryHoldingPolicyOrder
  ): [InventoryHoldingPolicy]
  inventoryHoldingPolicyAggregate(
    filter: InventoryHoldingPolicyFilter
  ): InventoryHoldingPolicyAggregateResult
  isActive: Boolean
  lots(
    filter: MaterialLotFilter
    first: Int
    offset: Int
    order: MaterialLotOrder
  ): [MaterialLot]
  lotsAggregate(filter: MaterialLotFilter): MaterialLotAggregateResult
  materialActual(
    filter: MaterialActualFilter
    first: Int
    offset: Int
    order: MaterialActualOrder
  ): [MaterialActual]
  materialActualAggregate(
    filter: MaterialActualFilter
  ): MaterialActualAggregateResult
  materialClass(filter: MaterialClassFilter): MaterialClass
  materialEquipment(filter: MaterialEquipmentFilter): [MaterialEquipment]
  name: String
  operationsDefinitions(
    filter: OperationsDefinitionFilter
    first: Int
    offset: Int
    order: OperationsDefinitionOrder
  ): [OperationsDefinition]
  operationsDefinitionsAggregate(
    filter: OperationsDefinitionFilter
  ): OperationsDefinitionAggregateResult
  parameterSpecifications(
    filter: ParameterSpecificationFilter
    first: Int
    offset: Int
    order: ParameterSpecificationOrder
  ): [ParameterSpecification]
  parameterSpecificationsAggregate(
    filter: ParameterSpecificationFilter
  ): ParameterSpecificationAggregateResult
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  scheduleSortOrder: Int
  serialMask: String
  shipmentItems(
    filter: ShipmentItemFilter
    first: Int
    offset: Int
    order: ShipmentItemOrder
  ): [ShipmentItem]
  shipmentItemsAggregate(
    filter: ShipmentItemFilter
  ): ShipmentItemAggregateResult
  sublots(
    filter: MaterialSubLotFilter
    first: Int
    offset: Int
    order: MaterialSubLotOrder
  ): [MaterialSubLot]
  sublotsAggregate(filter: MaterialSubLotFilter): MaterialSubLotAggregateResult
  supplier: String
  transferrableMaterials(
    filter: MaterialDefinitionFilter
    first: Int
    offset: Int
    order: MaterialDefinitionOrder
  ): [MaterialDefinition]
  transferrableMaterialsAggregate(
    filter: MaterialDefinitionFilter
  ): MaterialDefinitionAggregateResult
  units(
    filter: MaterialUnitFilter
    first: Int
    offset: Int
    order: MaterialUnitOrder
  ): [MaterialUnit]
  unitsAggregate(filter: MaterialUnitFilter): MaterialUnitAggregateResult
  uomConversions(
    filter: UnitOfMeasureConversionFilter
    first: Int
    offset: Int
    order: UnitOfMeasureConversionOrder
  ): [UnitOfMeasureConversion]
  uomConversionsAggregate(
    filter: UnitOfMeasureConversionFilter
  ): UnitOfMeasureConversionAggregateResult
  value: Float
  valueCurrency: String
  weightKG: Float
  workSpecifications(
    filter: MaterialSpecificationFilter
    first: Int
    offset: Int
    order: MaterialSpecificationOrder
  ): [MaterialSpecification]
  workSpecificationsAggregate(
    filter: MaterialSpecificationFilter
  ): MaterialSpecificationAggregateResult
}

type MaterialDefinitionAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
  customerMaterialCodeMax: String
  customerMaterialCodeMin: String
  descriptionMax: String
  descriptionMin: String
  nameMax: String
  nameMin: String
  scheduleSortOrderAvg: Float
  scheduleSortOrderMax: Int
  scheduleSortOrderMin: Int
  scheduleSortOrderSum: Int
  serialMaskMax: String
  serialMaskMin: String
  supplierMax: String
  supplierMin: String
  valueAvg: Float
  valueCurrencyMax: String
  valueCurrencyMin: String
  valueMax: Float
  valueMin: Float
  valueSum: Float
  weightKGAvg: Float
  weightKGMax: Float
  weightKGMin: Float
  weightKGSum: Float
}

input MaterialDefinitionFilter {
  and: [MaterialDefinitionFilter]
  code: StringHashFilter
  customerMaterialCode: StringHashFilter
  has: [MaterialDefinitionHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: MaterialDefinitionFilter
  or: [MaterialDefinitionFilter]
}

enum MaterialDefinitionHasFilter {
  OrderLines
  alternates
  baseUnitOfMeasure
  code
  customerMaterialCode
  description
  inventoryHandlingPolicy
  inventoryHoldingPolicy
  isActive
  lots
  materialActual
  materialClass
  name
  operationsDefinitions
  parameterSpecifications
  properties
  scheduleSortOrder
  serialMask
  shipmentItems
  sublots
  supplier
  transferrableMaterials
  units
  uomConversions
  value
  valueCurrency
  weightKG
  workSpecifications
}

input MaterialDefinitionOrder {
  asc: MaterialDefinitionOrderable
  desc: MaterialDefinitionOrderable
  then: MaterialDefinitionOrder
}

enum MaterialDefinitionOrderable {
  code
  customerMaterialCode
  description
  name
  scheduleSortOrder
  serialMask
  supplier
  value
  valueCurrency
  weightKG
}

input MaterialDefinitionPatch {
  OrderLines: [OrderLineRef]
  alternates: [MaterialAlternateRef]
  baseUnitOfMeasure: UnitOfMeasureRef
  customerMaterialCode: String
  description: String
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
  lots: [MaterialLotRef]
  materialActual: [MaterialActualRef]
  materialClass: MaterialClassRef
  name: String
  operationsDefinitions: [OperationsDefinitionRef]
  parameterSpecifications: [ParameterSpecificationRef]
  properties: [PropertyRef]
  scheduleSortOrder: Int
  serialMask: String
  shipmentItems: [ShipmentItemRef]
  sublots: [MaterialSubLotRef]
  supplier: String
  transferrableMaterials: [MaterialDefinitionRef]
  units: [MaterialUnitRef]
  uomConversions: [UnitOfMeasureConversionRef]
  value: Float
  valueCurrency: String
  weightKG: Float
  workSpecifications: [MaterialSpecificationRef]
}

input MaterialDefinitionRef {
  OrderLines: [OrderLineRef]
  alternates: [MaterialAlternateRef]
  baseUnitOfMeasure: UnitOfMeasureRef
  code: String
  customerMaterialCode: String
  description: String
  id: ID
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
  lots: [MaterialLotRef]
  materialActual: [MaterialActualRef]
  materialClass: MaterialClassRef
  name: String
  operationsDefinitions: [OperationsDefinitionRef]
  parameterSpecifications: [ParameterSpecificationRef]
  properties: [PropertyRef]
  scheduleSortOrder: Int
  serialMask: String
  shipmentItems: [ShipmentItemRef]
  sublots: [MaterialSubLotRef]
  supplier: String
  transferrableMaterials: [MaterialDefinitionRef]
  units: [MaterialUnitRef]
  uomConversions: [UnitOfMeasureConversionRef]
  value: Float
  valueCurrency: String
  weightKG: Float
  workSpecifications: [MaterialSpecificationRef]
}

type MaterialEquipment {
  equipment: Equipment
  material: MaterialDefinition
  planningSummaryByState(filter: StateFilter): [MaterialEquipmentState]
}

input MaterialEquipmentFilter {
  equipmentID: [String]
  materialID: [String]
  siteID: [String]
}

type MaterialEquipmentState {
  inventoryMax: Int
  inventoryMin: Int
  planQty: Float
  productionOrderQuantity: Float
  saleOrderQty: Float
  state: MaterialStateTransitionAttributes
  stockOnHand: Float
}

type MaterialEventRuleset {
  eventDefs(
    filter: EventDefinitionFilter
    first: Int
    offset: Int
    order: EventDefinitionOrder
  ): [EventDefinition]
  eventDefsAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
  id: ID!
  name: String!
  segment(filter: OperationsSegmentFilter): OperationsSegment
  targetMaterial: String!
  targetMaterialOp: String!
  triggerWhen: [RulesetTriggerOption]
}

type MaterialEventRulesetAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
  targetMaterialMax: String
  targetMaterialMin: String
  targetMaterialOpMax: String
  targetMaterialOpMin: String
}

input MaterialEventRulesetFilter {
  and: [MaterialEventRulesetFilter]
  has: [MaterialEventRulesetHasFilter]
  id: [ID!]
  not: MaterialEventRulesetFilter
  or: [MaterialEventRulesetFilter]
}

enum MaterialEventRulesetHasFilter {
  eventDefs
  name
  segment
  targetMaterial
  targetMaterialOp
  triggerWhen
}

input MaterialEventRulesetOrder {
  asc: MaterialEventRulesetOrderable
  desc: MaterialEventRulesetOrderable
  then: MaterialEventRulesetOrder
}

enum MaterialEventRulesetOrderable {
  name
  targetMaterial
  targetMaterialOp
}

input MaterialEventRulesetPatch {
  eventDefs: [EventDefinitionRef]
  name: String
  segment: OperationsSegmentRef
  targetMaterial: String
  targetMaterialOp: String
  triggerWhen: [RulesetTriggerOption]
}

input MaterialEventRulesetRef {
  eventDefs: [EventDefinitionRef]
  id: ID
  name: String
  segment: OperationsSegmentRef
  targetMaterial: String
  targetMaterialOp: String
  triggerWhen: [RulesetTriggerOption]
}

# A uniquely identified specific amount of material, either countable or weighable shall be presented as a material lot.
# A material lot describes the planned or actual total quantity or amount of material available, its current state
# and its specific property values.
# ref-IEC62264-2 5.4.6
type MaterialLot {
  childSubLot(
    filter: MaterialSubLotFilter
    first: Int
    offset: Int
    order: MaterialSubLotOrder
  ): [MaterialSubLot]
  childSubLotAggregate(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
  code: String!
  dataType: DataType
  description: String
  id: ID!
  isActive: Boolean
  isAssembledFromLot(
    filter: MaterialLotFilter
    first: Int
    offset: Int
    order: MaterialLotOrder
  ): [MaterialLot]
  isAssembledFromLotAggregate(
    filter: MaterialLotFilter
  ): MaterialLotAggregateResult
  isAssembledFromSubLot(
    filter: MaterialSubLotFilter
    first: Int
    offset: Int
    order: MaterialSubLotOrder
  ): [MaterialSubLot]
  isAssembledFromSubLotAggregate(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
  isComponentOfLot(
    filter: MaterialLotFilter
    first: Int
    offset: Int
    order: MaterialLotOrder
  ): [MaterialLot]
  isComponentOfLotAggregate(
    filter: MaterialLotFilter
  ): MaterialLotAggregateResult
  isComponentOfSubLot(
    filter: MaterialSubLotFilter
    first: Int
    offset: Int
    order: MaterialSubLotOrder
  ): [MaterialSubLot]
  isComponentOfSubLotAggregate(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
  materialActual(
    filter: MaterialActualFilter
    first: Int
    offset: Int
    order: MaterialActualOrder
  ): [MaterialActual]
  materialActualAggregate(
    filter: MaterialActualFilter
  ): MaterialActualAggregateResult
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  quantity: String
  unitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type MaterialLotAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
  descriptionMax: String
  descriptionMin: String
  quantityMax: String
  quantityMin: String
}

input MaterialLotFilter {
  and: [MaterialLotFilter]
  code: StringHashFilter
  has: [MaterialLotHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialLotFilter
  or: [MaterialLotFilter]
}

enum MaterialLotHasFilter {
  childSubLot
  code
  dataType
  description
  isActive
  isAssembledFromLot
  isAssembledFromSubLot
  isComponentOfLot
  isComponentOfSubLot
  material
  materialActual
  properties
  quantity
  unitOfMeasure
}

input MaterialLotOrder {
  asc: MaterialLotOrderable
  desc: MaterialLotOrderable
  then: MaterialLotOrder
}

enum MaterialLotOrderable {
  code
  description
  quantity
}

input MaterialLotPatch {
  childSubLot: [MaterialSubLotRef]
  dataType: DataType
  description: String
  isActive: Boolean
  isAssembledFromLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  material: MaterialDefinitionRef
  materialActual: [MaterialActualRef]
  properties: [PropertyRef]
  quantity: String
  unitOfMeasure: UnitOfMeasureRef
}

input MaterialLotRef {
  childSubLot: [MaterialSubLotRef]
  code: String
  dataType: DataType
  description: String
  id: ID
  isActive: Boolean
  isAssembledFromLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  material: MaterialDefinitionRef
  materialActual: [MaterialActualRef]
  properties: [PropertyRef]
  quantity: String
  unitOfMeasure: UnitOfMeasureRef
}

input MaterialQuantityMovement {
  materialDefinition: ExtMaterialDefinitionRef!
  quantity: Float!
}

type MaterialSpecification {
  allowedStates(
    filter: MaterialStatusFilter
    first: Int
    offset: Int
    order: MaterialStatusOrder
  ): [MaterialStatus]
  allowedStatesAggregate(
    filter: MaterialStatusFilter
  ): MaterialStatusAggregateResult
  backFlushFromLocation(filter: EquipmentFilter): Equipment
  billOfMaterial(filter: BillOfMaterialFilter): BillOfMaterial
  description: String
  id: ID!
  isActive: Boolean
  isBackFlushed: Boolean
  isTracked: Boolean
  jobOrder(filter: JobOrderFilter): JobOrder
  material(filter: MaterialDefinitionFilter): MaterialDefinition
  materialClass(filter: MaterialClassFilter): MaterialClass
  materialUse: MaterialUse!
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment
  quantity: Float
  uom(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type MaterialSpecificationAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input MaterialSpecificationFilter {
  and: [MaterialSpecificationFilter]
  has: [MaterialSpecificationHasFilter]
  id: [ID!]
  isActive: Boolean
  isBackFlushed: Boolean
  materialUse: MaterialUse_hash
  not: MaterialSpecificationFilter
  or: [MaterialSpecificationFilter]
}

enum MaterialSpecificationHasFilter {
  allowedStates
  backFlushFromLocation
  billOfMaterial
  description
  isActive
  isBackFlushed
  isTracked
  jobOrder
  material
  materialClass
  materialUse
  operationsSegment
  quantity
  uom
}

input MaterialSpecificationOrder {
  asc: MaterialSpecificationOrderable
  desc: MaterialSpecificationOrderable
  then: MaterialSpecificationOrder
}

enum MaterialSpecificationOrderable {
  description
  quantity
}

input MaterialSpecificationPatch {
  allowedStates: [MaterialStatusRef]
  backFlushFromLocation: EquipmentRef
  billOfMaterial: BillOfMaterialRef
  description: String
  isActive: Boolean
  isBackFlushed: Boolean
  isTracked: Boolean
  jobOrder: JobOrderRef
  material: MaterialDefinitionRef
  materialClass: MaterialClassRef
  materialUse: MaterialUse
  operationsSegment: OperationsSegmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

input MaterialSpecificationRef {
  allowedStates: [MaterialStatusRef]
  backFlushFromLocation: EquipmentRef
  billOfMaterial: BillOfMaterialRef
  description: String
  id: ID
  isActive: Boolean
  isBackFlushed: Boolean
  isTracked: Boolean
  jobOrder: JobOrderRef
  material: MaterialDefinitionRef
  materialClass: MaterialClassRef
  materialUse: MaterialUse
  operationsSegment: OperationsSegmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

type MaterialStateModel {
  id: ID!
  inventoryHandlingRules(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  inventoryHandlingRulesAggregate(
    filter: InventoryHandlingRuleFilter
  ): InventoryHandlingRuleAggregateResult
  isActive: Boolean
  name: String!
  states(
    filter: MaterialStateTransitionFilter
    first: Int
    offset: Int
  ): [MaterialStateTransition!]!
  statesAggregate(
    filter: MaterialStateTransitionFilter
  ): MaterialStateTransitionAggregateResult
}

type MaterialStateModelAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
}

input MaterialStateModelFilter {
  and: [MaterialStateModelFilter]
  has: [MaterialStateModelHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: MaterialStateModelFilter
  or: [MaterialStateModelFilter]
}

enum MaterialStateModelHasFilter {
  inventoryHandlingRules
  isActive
  name
  states
}

input MaterialStateModelOrder {
  asc: MaterialStateModelOrderable
  desc: MaterialStateModelOrderable
  then: MaterialStateModelOrder
}

enum MaterialStateModelOrderable {
  name
}

input MaterialStateModelPatch {
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  isActive: Boolean
  states: [MaterialStateTransitionRef!]
}

input MaterialStateModelRef {
  id: ID
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  isActive: Boolean
  name: String
  states: [MaterialStateTransitionRef!]
}

type MaterialStateTransition {
  canPack: Boolean
  canReceive: Boolean
  id: ID!
  isPlanned: Boolean
  status(filter: MaterialStatusFilter): MaterialStatus!
  to(
    filter: MaterialStatusFilter
    first: Int
    offset: Int
    order: MaterialStatusOrder
  ): [MaterialStatus]
  toAggregate(filter: MaterialStatusFilter): MaterialStatusAggregateResult
}

type MaterialStateTransitionAggregateResult {
  count: Int
}

type MaterialStateTransitionAttributes {
  canPack: Boolean
  canReceive: Boolean
  id: ID!
  isPlanned: Boolean
  status: MaterialStatus
}

input MaterialStateTransitionFilter {
  and: [MaterialStateTransitionFilter]
  canPack: Boolean
  canReceive: Boolean
  has: [MaterialStateTransitionHasFilter]
  id: [ID!]
  isPlanned: Boolean
  not: MaterialStateTransitionFilter
  or: [MaterialStateTransitionFilter]
}

enum MaterialStateTransitionHasFilter {
  canPack
  canReceive
  isPlanned
  status
  to
}

input MaterialStateTransitionPatch {
  canPack: Boolean
  canReceive: Boolean
  isPlanned: Boolean
  status: MaterialStatusRef
  to: [MaterialStatusRef]
}

input MaterialStateTransitionRef {
  canPack: Boolean
  canReceive: Boolean
  id: ID
  isPlanned: Boolean
  status: MaterialStatusRef
  to: [MaterialStatusRef]
}

type MaterialStatus {
  code: String!
  id: ID!
  inventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    first: Int
    offset: Int
    order: InventoryHoldingPolicyOrder
  ): [InventoryHoldingPolicy]
  inventoryHoldingPolicyAggregate(
    filter: InventoryHoldingPolicyFilter
  ): InventoryHoldingPolicyAggregateResult
  isActive: Boolean
}

type MaterialStatusAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
}

input MaterialStatusFilter {
  and: [MaterialStatusFilter]
  code: StringHashFilter
  has: [MaterialStatusHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialStatusFilter
  or: [MaterialStatusFilter]
}

enum MaterialStatusHasFilter {
  code
  inventoryHoldingPolicy
  isActive
}

input MaterialStatusOrder {
  asc: MaterialStatusOrderable
  desc: MaterialStatusOrderable
  then: MaterialStatusOrder
}

enum MaterialStatusOrderable {
  code
}

input MaterialStatusPatch {
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
}

input MaterialStatusRef {
  code: String
  id: ID
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
}

# Each separately identifiable quantity of the same material lot shall be presented as a material sublot.
# A material lot by be stored in separately identifiable quantities. All material sublots are part of the
# material lot, so they have the material lot's property values. A material sublot may be just a single item.
# ref-IEC62264-2 5.4.8
type MaterialSubLot {
  carrier: Carrier
  childSubLot(filter: MaterialSubLotFilter): MaterialSubLot
  code: String!
  dataType: DataType
  description: String
  id: ID!
  isActive: Boolean
  isAssembledFromLot(
    filter: MaterialLotFilter
    first: Int
    offset: Int
    order: MaterialLotOrder
  ): [MaterialLot]
  isAssembledFromLotAggregate(
    filter: MaterialLotFilter
  ): MaterialLotAggregateResult
  isAssembledFromSubLot(
    filter: MaterialSubLotFilter
    first: Int
    offset: Int
    order: MaterialSubLotOrder
  ): [MaterialSubLot]
  isAssembledFromSubLotAggregate(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
  isComponentOfLot(
    filter: MaterialLotFilter
    first: Int
    offset: Int
    order: MaterialLotOrder
  ): [MaterialLot]
  isComponentOfLotAggregate(
    filter: MaterialLotFilter
  ): MaterialLotAggregateResult
  isComponentOfSubLot(
    filter: MaterialSubLotFilter
    first: Int
    offset: Int
    order: MaterialSubLotOrder
  ): [MaterialSubLot]
  isComponentOfSubLotAggregate(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
  materialActual(
    filter: MaterialActualFilter
    first: Int
    offset: Int
    order: MaterialActualOrder
  ): [MaterialActual]
  materialActualAggregate(
    filter: MaterialActualFilter
  ): MaterialActualAggregateResult
  parentLot(filter: MaterialLotFilter): MaterialLot
  parentSubLot(filter: MaterialSubLotFilter): MaterialSubLot
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  quantity: String
  status(filter: MaterialStatusFilter): MaterialStatus!
  storageLocation(filter: EquipmentFilter): Equipment
  unitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type MaterialSubLotAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
  descriptionMax: String
  descriptionMin: String
  quantityMax: String
  quantityMin: String
}

input MaterialSubLotFilter {
  and: [MaterialSubLotFilter]
  code: StringHashFilter
  has: [MaterialSubLotHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialSubLotFilter
  or: [MaterialSubLotFilter]
}

enum MaterialSubLotHasFilter {
  childSubLot
  code
  dataType
  description
  isActive
  isAssembledFromLot
  isAssembledFromSubLot
  isComponentOfLot
  isComponentOfSubLot
  material
  materialActual
  parentLot
  parentSubLot
  properties
  quantity
  status
  storageLocation
  unitOfMeasure
}

input MaterialSubLotOrder {
  asc: MaterialSubLotOrderable
  desc: MaterialSubLotOrderable
  then: MaterialSubLotOrder
}

enum MaterialSubLotOrderable {
  code
  description
  quantity
}

input MaterialSubLotPatch {
  childSubLot: MaterialSubLotRef
  dataType: DataType
  description: String
  isActive: Boolean
  isAssembledFromLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  material: MaterialDefinitionRef
  materialActual: [MaterialActualRef]
  parentLot: MaterialLotRef
  parentSubLot: MaterialSubLotRef
  properties: [PropertyRef]
  quantity: String
  status: MaterialStatusRef
  storageLocation: EquipmentRef
  unitOfMeasure: UnitOfMeasureRef
}

input MaterialSubLotRef {
  childSubLot: MaterialSubLotRef
  code: String
  dataType: DataType
  description: String
  id: ID
  isActive: Boolean
  isAssembledFromLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  material: MaterialDefinitionRef
  materialActual: [MaterialActualRef]
  parentLot: MaterialLotRef
  parentSubLot: MaterialSubLotRef
  properties: [PropertyRef]
  quantity: String
  status: MaterialStatusRef
  storageLocation: EquipmentRef
  unitOfMeasure: UnitOfMeasureRef
}

type MaterialUnit {
  id: ID!
  isActive: Boolean
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  serialNumber: String!
}

type MaterialUnitAggregateResult {
  count: Int
  serialNumberMax: String
  serialNumberMin: String
}

input MaterialUnitFilter {
  and: [MaterialUnitFilter]
  has: [MaterialUnitHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialUnitFilter
  or: [MaterialUnitFilter]
  serialNumber: StringHashFilter
}

enum MaterialUnitHasFilter {
  isActive
  material
  properties
  serialNumber
}

input MaterialUnitOrder {
  asc: MaterialUnitOrderable
  desc: MaterialUnitOrderable
  then: MaterialUnitOrder
}

enum MaterialUnitOrderable {
  serialNumber
}

input MaterialUnitPatch {
  isActive: Boolean
  material: MaterialDefinitionRef
  properties: [PropertyRef]
}

input MaterialUnitRef {
  id: ID
  isActive: Boolean
  material: MaterialDefinitionRef
  properties: [PropertyRef]
  serialNumber: String
}

enum MaterialUse {
  ByProduct
  CoProduct
  Consumable
  Consumed
  Initial
  Packed
  Produced
  Received
  Rework
  Scrap
  Shipped
  Transferred
}

input MaterialUse_hash {
  eq: MaterialUse
  in: [MaterialUse]
}

type Menu {
  access(
    filter: RoleFilter
    first: Int
    offset: Int
    order: RoleOrder
  ): [Role!]!
  accessAggregate(filter: RoleFilter): RoleAggregateResult
  children(
    filter: MenuFilter
    first: Int
    offset: Int
    order: MenuOrder
  ): [Menu!]
  childrenAggregate(filter: MenuFilter): MenuAggregateResult
  icon: String
  id: ID!
  isPage: Boolean!
  isSection: Boolean!
  label: String!
  menuPage: String
  orderNumber: Int
  parent(filter: MenuFilter): Menu
}

type MenuAggregateResult {
  count: Int
  iconMax: String
  iconMin: String
  labelMax: String
  labelMin: String
  menuPageMax: String
  menuPageMin: String
  orderNumberAvg: Float
  orderNumberMax: Int
  orderNumberMin: Int
  orderNumberSum: Int
}

input MenuFilter {
  and: [MenuFilter]
  has: [MenuHasFilter]
  id: [ID!]
  label: StringHashFilter
  not: MenuFilter
  or: [MenuFilter]
}

enum MenuHasFilter {
  access
  children
  icon
  isPage
  isSection
  label
  menuPage
  orderNumber
  parent
}

input MenuOrder {
  asc: MenuOrderable
  desc: MenuOrderable
  then: MenuOrder
}

enum MenuOrderable {
  icon
  label
  menuPage
  orderNumber
}

input MenuPatch {
  access: [RoleRef!]
  children: [MenuRef!]
  icon: String
  isPage: Boolean
  isSection: Boolean
  label: String
  menuPage: String
  orderNumber: Int
  parent: MenuRef
}

input MenuRef {
  access: [RoleRef!]
  children: [MenuRef!]
  icon: String
  id: ID
  isPage: Boolean
  isSection: Boolean
  label: String
  menuPage: String
  orderNumber: Int
  parent: MenuRef
}

enum MessageClass {
  AttendanceLog
  EventLog
  JobOrderStateChange
  JobOrderTransition
  JobRequest
  JobResponse
  OperationsRequestStart
  PerformanceLog
  QuantityLog
}

enum Mode {
  BATCH
  SINGLE
}

input MoveMaterialQuantitiesBetweenCarriersInput {
  carrierDestination: ExtCarrierRef!
  carrierInitial: ExtCarrierRef!
  materialQuantities: [MaterialQuantityMovement]!
  user: ExtUserRef!
}

input MoveMaterialSubLotsInput {
  materialSubLots: [ExtMaterialSubLotRef!]!
  newLocation: ExtCarrierRef!
  user: ExtUserRef!
}

enum mpmORCRevokeTriggers {
  BREAK_TIME_END
  BREAK_TIME_START
  FIFTEEN_MINUTES
  FORTYFIVE_MINUTES
  ORDER_CLOSE
  SIXTY_MINUTES
  THIRTY_MINUTES
}

enum mpmORCWarnTriggers {
  BREAK_TIME_END
  BREAK_TIME_START
  FIFTEEN_MINUTES
  FORTYFIVE_MINUTES
  ORDER_CLOSE
  SIXTY_MINUTES
  THIRTY_MINUTES
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  addACL(input: [AddACLInput!]!): AddACLPayload
  addAccessRight(input: [AddAccessRightInput!]!): AddAccessRightPayload
  addAddress(input: [AddAddressInput!]!): AddAddressPayload

  #  Backfill iterates through the an equipment properties from the given timestamp until now, and evaulates
  # events and rulesets and re-recreates responses for the time period given. Any existing data is delete.
  # This is a long running process. Subscribe to the topic in the mqtt broker for updates.
  addBackfill(input: BackfillRequest!): BackfillResponse

  #  Cancel a running Backfill
  addBackfillCancel(input: BackfillCancelRequest!): BackfillResponse
  addBillOfMaterial(
    input: [AddBillOfMaterialInput!]!
    upsert: Boolean
  ): AddBillOfMaterialPayload
  addBox(input: [AddBoxInput!]!): AddBoxPayload
  addCarrier(input: [AddCarrierInput!]!, upsert: Boolean): AddCarrierPayload
  addDashboardConfig(
    input: [AddDashboardConfigInput!]!
    upsert: Boolean
  ): AddDashboardConfigPayload
  addDashboardPanelConfig(
    input: [AddDashboardPanelConfigInput!]!
  ): AddDashboardPanelConfigPayload
  addDashboardWidgetConfigProperty(
    input: [AddDashboardWidgetConfigPropertyInput!]!
  ): AddDashboardWidgetConfigPropertyPayload
  addDelivery(input: [AddDeliveryInput!]!): AddDeliveryPayload
  addEquipment(input: [AddEquipmentInput!]!): AddEquipmentPayload
  addEquipmentActual(
    input: [AddEquipmentActualInput!]!
  ): AddEquipmentActualPayload
  addEquipmentClass(input: [AddEquipmentClassInput!]!): AddEquipmentClassPayload
  addEquipmentNameAlias(
    input: [AddEquipmentNameAliasInput!]!
  ): AddEquipmentNameAliasPayload
  addEquipmentPropertyOverride(
    input: [AddEquipmentPropertyOverrideInput!]!
  ): AddEquipmentPropertyOverridePayload
  addEquipmentReasonOverride(
    input: [AddEquipmentReasonOverrideInput!]!
  ): AddEquipmentReasonOverridePayload
  addEquipmentRelation(
    input: [AddEquipmentRelationInput!]!
  ): AddEquipmentRelationPayload
  addEquipmentSpecification(
    input: [AddEquipmentSpecificationInput!]!
  ): AddEquipmentSpecificationPayload
  addEventDefinition(
    input: [AddEventDefinitionInput!]!
  ): AddEventDefinitionPayload
  addEventLog(input: [AddEventLogInput!]!): AddEventLogPayload
  addForm(input: [AddFormInput!]!, upsert: Boolean): AddFormPayload
  addGeneralLedgerAccount(
    input: [AddGeneralLedgerAccountInput!]!
    upsert: Boolean
  ): AddGeneralLedgerAccountPayload
  addInterfaceMessageLog(
    input: [AddInterfaceMessageLogInput!]!
  ): AddInterfaceMessageLogPayload

  # method assumes that any backflushed materials are not tracked by carrier
  addInventoryActual(
    input: [AddInventoryActualInput!]!
  ): [AddInventoryActualPayload]
  addInventoryHandlingPolicy(
    input: [AddInventoryHandlingPolicyInput!]!
    upsert: Boolean
  ): AddInventoryHandlingPolicyPayload
  addInventoryHandlingRule(
    input: [AddInventoryHandlingRuleInput!]!
  ): AddInventoryHandlingRulePayload
  addInventoryHoldingPolicy(
    input: [AddInventoryHoldingPolicyInput!]!
  ): AddInventoryHoldingPolicyPayload
  addInventoryTransactionReceive(
    input: [InventoryTransactionInput!]!
  ): [InventoryTransaction]
  addJobOrder(input: [AddJobOrderInput!]!, upsert: Boolean): AddJobOrderPayload
  addJobOrderDependency(
    input: [AddJobOrderDependencyInput!]!
  ): AddJobOrderDependencyPayload
  addJobOrderDispatchStateModel(
    input: [AddJobOrderDispatchStateModelInput!]!
  ): AddJobOrderDispatchStateModelPayload
  addJobOrderNote(input: [AddJobOrderNoteInput!]!): AddJobOrderNotePayload
  addJobResponse(input: [AddJobResponseInput!]!): AddJobResponsePayload
  addLibreService(
    input: [AddLibreServiceInput!]!
    upsert: Boolean
  ): AddLibreServicePayload
  addMaterialActual(input: [AddMaterialActualInput!]!): AddMaterialActualPayload
  addMaterialAlternate(
    input: [AddMaterialAlternateInput!]!
  ): AddMaterialAlternatePayload
  addMaterialClass(
    input: [AddMaterialClassInput!]!
    upsert: Boolean
  ): AddMaterialClassPayload
  addMaterialDefinition(
    input: [AddMaterialDefinitionInput!]!
    upsert: Boolean
  ): AddMaterialDefinitionPayload
  addMaterialEventRuleset(
    input: [AddMaterialEventRulesetInput!]!
  ): AddMaterialEventRulesetPayload
  addMaterialLot(
    input: [AddMaterialLotInput!]!
    upsert: Boolean
  ): AddMaterialLotPayload
  addMaterialSpecification(
    input: [AddMaterialSpecificationInput!]!
  ): AddMaterialSpecificationPayload
  addMaterialStateModel(
    input: [AddMaterialStateModelInput!]!
    upsert: Boolean
  ): AddMaterialStateModelPayload
  addMaterialStateTransition(
    input: [AddMaterialStateTransitionInput!]!
  ): AddMaterialStateTransitionPayload
  addMaterialStatus(
    input: [AddMaterialStatusInput!]!
    upsert: Boolean
  ): AddMaterialStatusPayload
  addMaterialSubLot(
    input: [AddMaterialSubLotInput!]!
    upsert: Boolean
  ): AddMaterialSubLotPayload
  addMaterialUnit(
    input: [AddMaterialUnitInput!]!
    upsert: Boolean
  ): AddMaterialUnitPayload
  addMenu(input: [AddMenuInput!]!): AddMenuPayload
  addOperationsDefinition(
    input: [AddOperationsDefinitionInput!]!
    upsert: Boolean
  ): AddOperationsDefinitionPayload
  addOperationsRequest(
    input: [AddOperationsRequestInput!]!
    upsert: Boolean
  ): AddOperationsRequestPayload
  addOperationsSegment(
    input: [AddOperationsSegmentInput!]!
  ): AddOperationsSegmentPayload
  addOrder(input: [AddOrderInput!]!): AddOrderPayload
  addOrderLine(input: [AddOrderLineInput!]!): AddOrderLinePayload
  addOrderStartRuleset(
    input: [AddOrderStartRulesetInput!]!
  ): AddOrderStartRulesetPayload
  addParameterSpecification(
    input: [AddParameterSpecificationInput!]!
  ): AddParameterSpecificationPayload
  addPartner(input: [AddPartnerInput!]!): AddPartnerPayload
  addPayloadFieldDefinition(
    input: [AddPayloadFieldDefinitionInput!]!
  ): AddPayloadFieldDefinitionPayload
  addPerson(input: [AddPersonInput!]!, upsert: Boolean): AddPersonPayload
  addPersonnelActual(
    input: [AddPersonnelActualInput!]!
  ): AddPersonnelActualPayload
  addPersonnelClass(
    input: [AddPersonnelClassInput!]!
    upsert: Boolean
  ): AddPersonnelClassPayload
  addPersonnelSpecification(
    input: [AddPersonnelSpecificationInput!]!
  ): AddPersonnelSpecificationPayload
  addProperty(input: [AddPropertyInput!]!): AddPropertyPayload
  addPropertyNameAlias(
    input: [AddPropertyNameAliasInput!]!
  ): AddPropertyNameAliasPayload
  addPropertyValueAlias(
    input: [AddPropertyValueAliasInput!]!
  ): AddPropertyValueAliasPayload
  addQuantityLog(input: [AddQuantityLogInput!]!): AddQuantityLogPayload
  addQuantityLogTs(input: QuantityLogTsInput!): QuantityLogTs
  addReason(input: [AddReasonInput!]!): AddReasonPayload
  addReasonCategory(
    input: [AddReasonCategoryInput!]!
    upsert: Boolean
  ): AddReasonCategoryPayload
  addRequestState(
    input: [AddRequestStateInput!]!
    upsert: Boolean
  ): AddRequestStatePayload
  addRole(input: [AddRoleInput!]!, upsert: Boolean): AddRolePayload
  addSegmentDependency(
    input: [AddSegmentDependencyInput!]!
  ): AddSegmentDependencyPayload
  addSegmentInvoiceSetting(
    input: [AddSegmentInvoiceSettingInput!]!
  ): AddSegmentInvoiceSettingPayload
  addShipment(input: [AddShipmentInput!]!): AddShipmentPayload
  addShipmentItem(input: [AddShipmentItemInput!]!): AddShipmentItemPayload

  # method used to add shipment items to a shipment for a delivery company
  addShipmentItemsToDeliveryShipment(
    shipment: ExtShipmentRef!
    shipmentItems: [ExtShipmentItemRef!]!
    shippingAccountData: ShippingAccountData!
  ): Shipment
  addShippingAccount(
    input: [AddShippingAccountInput!]!
  ): AddShippingAccountPayload
  addStateEventRuleset(
    input: [AddStateEventRulesetInput!]!
  ): AddStateEventRulesetPayload
  addTestResult(input: [AddTestResultInput!]!): AddTestResultPayload
  addTestSpecification(
    input: [AddTestSpecificationInput!]!
  ): AddTestSpecificationPayload
  addTransitionEventRuleset(
    input: [AddTransitionEventRulesetInput!]!
  ): AddTransitionEventRulesetPayload
  addUnitOfMeasure(
    input: [AddUnitOfMeasureInput!]!
    upsert: Boolean
  ): AddUnitOfMeasurePayload
  addUnitOfMeasureConversion(
    input: [AddUnitOfMeasureConversionInput!]!
  ): AddUnitOfMeasureConversionPayload
  addUser(input: [AddUserInput!]!, upsert: Boolean): AddUserPayload
  addUserRole(input: [AddUserRoleInput!]!): AddUserRolePayload
  addWorkCalendar(
    input: [AddWorkCalendarInput!]!
    upsert: Boolean
  ): AddWorkCalendarPayload
  addWorkCalendarDefinitionEntry(
    input: [AddWorkCalendarDefinitionEntryInput!]!
  ): AddWorkCalendarDefinitionEntryPayload
  addWorkCalendarEntry(
    input: [AddWorkCalendarEntryInput!]!
  ): AddWorkCalendarEntryPayload
  addWorkflowConnection(
    input: [AddWorkflowConnectionInput!]!
  ): AddWorkflowConnectionPayload
  addWorkflowConnectionType(
    input: [AddWorkflowConnectionTypeInput!]!
  ): AddWorkflowConnectionTypePayload
  addWorkflowInstance(
    input: [AddWorkflowInstanceInput!]!
  ): AddWorkflowInstancePayload
  addWorkflowInstanceProperty(
    input: [AddWorkflowInstancePropertyInput!]!
    upsert: Boolean
  ): AddWorkflowInstancePropertyPayload
  addWorkflowNode(input: [AddWorkflowNodeInput!]!): AddWorkflowNodePayload
  addWorkflowNodeEvent(
    input: [AddWorkflowNodeEventInput!]!
  ): AddWorkflowNodeEventPayload
  addWorkflowNodeInstance(
    input: [AddWorkflowNodeInstanceInput!]!
  ): AddWorkflowNodeInstancePayload
  addWorkflowNodeType(
    input: [AddWorkflowNodeTypeInput!]!
  ): AddWorkflowNodeTypePayload
  addWorkflowProperty(
    input: [AddWorkflowPropertyInput!]!
  ): AddWorkflowPropertyPayload
  addWorkflowPropertyInstance(
    input: [AddWorkflowPropertyInstanceInput!]!
  ): AddWorkflowPropertyInstancePayload
  addWorkflowPropertyValue(
    input: [AddWorkflowPropertyValueInput!]!
  ): AddWorkflowPropertyValuePayload
  addWorkflowSpecification(
    input: [AddWorkflowSpecificationInput!]!
  ): AddWorkflowSpecificationPayload

  #  Complete a workflow node instance. If the specification contains a next task, it will be started
  # otherwise the workflow instance will be completed.
  completeWorkflowTask(input: CompleteWorkflowTaskInput!): WorkflowNodeInstance
  confirmASN(input: [ConfirmASNInput!]!, siteID: String!): [Order]
  createDeliveryOrderFromShipments(
    shipments: [ExtShipmentRef!]!
    shippingAccountData: ShippingAccountData!
  ): Delivery
  createDeliveryShipmentItemLabel(
    item: ExtShipmentItemRef!
    shipment: ExtShipmentRef!
    shippingAccountData: ShippingAccountData!
  ): String

  # method used to create a shipment label to use with a delivery company
  createDeliveryShipmentLabel(
    shipment: ExtShipmentRef!
    shippingAccountData: ShippingAccountData!
  ): String

  # method used to create an empty outbbound shipment to use with a delivery company
  createEmptyDeliveryShipment(
    shipment: ExtShipmentRef!
    shippingAccountData: ShippingAccountData!
  ): Shipment

  #  Create a new instance of a given workflow specification and start the first task
  # in the specification after the "START_EVENT". Properties can be supplied.
  createWorkflowInstance(input: CreateWorkflowInstanceInput!): WorkflowInstance
  deleteACL(filter: ACLFilter!): DeleteACLPayload
  deleteAccessRight(filter: AccessRightFilter!): DeleteAccessRightPayload
  deleteAddress(filter: AddressFilter!): DeleteAddressPayload
  deleteBillOfMaterial(
    filter: BillOfMaterialFilter!
  ): DeleteBillOfMaterialPayload
  deleteBox(filter: BoxFilter!): DeleteBoxPayload
  deleteCarrier(filter: CarrierFilter!): DeleteCarrierPayload
  deleteDashboardConfig(
    filter: DashboardConfigFilter!
  ): DeleteDashboardConfigPayload
  deleteDashboardPanelConfig(
    filter: DashboardPanelConfigFilter!
  ): DeleteDashboardPanelConfigPayload
  deleteDashboardWidgetConfigProperty(
    filter: DashboardWidgetConfigPropertyFilter!
  ): DeleteDashboardWidgetConfigPropertyPayload
  deleteDelivery(filter: DeliveryFilter!): DeleteDeliveryPayload
  deleteDeliveryShipment(
    shipment: ExtShipmentRef!
    shippingAccountData: ShippingAccountData!
  ): Shipment
  deleteDeliveryShipmentItem(
    shipmentItem: ExtShipmentItemRef!
    shippingAccountData: ShippingAccountData!
  ): ShipmentItem
  deleteEquipment(filter: EquipmentFilter!): DeleteEquipmentPayload
  deleteEquipmentActual(
    filter: EquipmentActualFilter!
  ): DeleteEquipmentActualPayload
  deleteEquipmentClass(
    filter: EquipmentClassFilter!
  ): DeleteEquipmentClassPayload
  deleteEquipmentNameAlias(
    filter: EquipmentNameAliasFilter!
  ): DeleteEquipmentNameAliasPayload
  deleteEquipmentPropertyOverride(
    filter: EquipmentPropertyOverrideFilter!
  ): DeleteEquipmentPropertyOverridePayload
  deleteEquipmentReasonOverride(
    filter: EquipmentReasonOverrideFilter!
  ): DeleteEquipmentReasonOverridePayload
  deleteEquipmentRelation(
    filter: EquipmentRelationFilter!
  ): DeleteEquipmentRelationPayload
  deleteEquipmentSpecification(
    filter: EquipmentSpecificationFilter!
  ): DeleteEquipmentSpecificationPayload
  deleteEventDefinition(
    filter: EventDefinitionFilter!
  ): DeleteEventDefinitionPayload
  deleteEventLog(filter: EventLogFilter!): DeleteEventLogPayload
  deleteForm(filter: FormFilter!): DeleteFormPayload
  deleteGeneralLedgerAccount(
    filter: GeneralLedgerAccountFilter!
  ): DeleteGeneralLedgerAccountPayload
  deleteInterfaceMessageLog(
    filter: InterfaceMessageLogFilter!
  ): DeleteInterfaceMessageLogPayload
  deleteInventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter!
  ): DeleteInventoryHandlingPolicyPayload
  deleteInventoryHandlingRule(
    filter: InventoryHandlingRuleFilter!
  ): DeleteInventoryHandlingRulePayload
  deleteInventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter!
  ): DeleteInventoryHoldingPolicyPayload
  deleteJobOrder(filter: JobOrderFilter!): DeleteJobOrderPayload
  deleteJobOrderDependency(
    filter: JobOrderDependencyFilter!
  ): DeleteJobOrderDependencyPayload
  deleteJobOrderDispatchStateModel(
    filter: JobOrderDispatchStateModelFilter!
  ): DeleteJobOrderDispatchStateModelPayload
  deleteJobOrderNote(filter: JobOrderNoteFilter!): DeleteJobOrderNotePayload
  deleteJobResponse(filter: JobResponseFilter!): DeleteJobResponsePayload
  deleteLibreService(filter: LibreServiceFilter!): DeleteLibreServicePayload
  deleteMaterialActual(
    filter: MaterialActualFilter!
  ): DeleteMaterialActualPayload
  deleteMaterialAlternate(
    filter: MaterialAlternateFilter!
  ): DeleteMaterialAlternatePayload
  deleteMaterialClass(filter: MaterialClassFilter!): DeleteMaterialClassPayload
  deleteMaterialDefinition(
    filter: MaterialDefinitionFilter!
  ): DeleteMaterialDefinitionPayload
  deleteMaterialEventRuleset(
    filter: MaterialEventRulesetFilter!
  ): DeleteMaterialEventRulesetPayload
  deleteMaterialLot(filter: MaterialLotFilter!): DeleteMaterialLotPayload
  deleteMaterialSpecification(
    filter: MaterialSpecificationFilter!
  ): DeleteMaterialSpecificationPayload
  deleteMaterialStateModel(
    filter: MaterialStateModelFilter!
  ): DeleteMaterialStateModelPayload
  deleteMaterialStateTransition(
    filter: MaterialStateTransitionFilter!
  ): DeleteMaterialStateTransitionPayload
  deleteMaterialStatus(
    filter: MaterialStatusFilter!
  ): DeleteMaterialStatusPayload
  deleteMaterialSubLot(
    filter: MaterialSubLotFilter!
  ): DeleteMaterialSubLotPayload
  deleteMaterialUnit(filter: MaterialUnitFilter!): DeleteMaterialUnitPayload
  deleteMenu(filter: MenuFilter!): DeleteMenuPayload
  deleteOperationsDefinition(
    filter: OperationsDefinitionFilter!
  ): DeleteOperationsDefinitionPayload
  deleteOperationsRequest(
    filter: OperationsRequestFilter!
  ): DeleteOperationsRequestPayload
  deleteOperationsSegment(
    filter: OperationsSegmentFilter!
  ): DeleteOperationsSegmentPayload
  deleteOrder(filter: OrderFilter!): DeleteOrderPayload
  deleteOrderLine(filter: OrderLineFilter!): DeleteOrderLinePayload
  deleteOrderStartRuleset(
    filter: OrderStartRulesetFilter!
  ): DeleteOrderStartRulesetPayload
  deleteParameterSpecification(
    filter: ParameterSpecificationFilter!
  ): DeleteParameterSpecificationPayload
  deletePartner(filter: PartnerFilter!): DeletePartnerPayload
  deletePayloadFieldDefinition(
    filter: PayloadFieldDefinitionFilter!
  ): DeletePayloadFieldDefinitionPayload
  deletePerson(filter: PersonFilter!): DeletePersonPayload
  deletePersonnelActual(
    filter: PersonnelActualFilter!
  ): DeletePersonnelActualPayload
  deletePersonnelClass(
    filter: PersonnelClassFilter!
  ): DeletePersonnelClassPayload
  deletePersonnelSpecification(
    filter: PersonnelSpecificationFilter!
  ): DeletePersonnelSpecificationPayload
  deleteProperty(filter: PropertyFilter!): DeletePropertyPayload
  deletePropertyNameAlias(
    filter: PropertyNameAliasFilter!
  ): DeletePropertyNameAliasPayload
  deletePropertyValueAlias(
    filter: PropertyValueAliasFilter!
  ): DeletePropertyValueAliasPayload
  deleteQuantityLog(filter: QuantityLogFilter!): DeleteQuantityLogPayload
  deleteReason(filter: ReasonFilter!): DeleteReasonPayload
  deleteReasonCategory(
    filter: ReasonCategoryFilter!
  ): DeleteReasonCategoryPayload
  deleteRequestState(filter: RequestStateFilter!): DeleteRequestStatePayload
  deleteRole(filter: RoleFilter!): DeleteRolePayload
  deleteSegmentDependency(
    filter: SegmentDependencyFilter!
  ): DeleteSegmentDependencyPayload
  deleteSegmentInvoiceSetting(
    filter: SegmentInvoiceSettingFilter!
  ): DeleteSegmentInvoiceSettingPayload
  deleteShipment(filter: ShipmentFilter!): DeleteShipmentPayload
  deleteShipmentItem(filter: ShipmentItemFilter!): DeleteShipmentItemPayload
  deleteShippingAccount(
    filter: ShippingAccountFilter!
  ): DeleteShippingAccountPayload
  deleteStateEventRuleset(
    filter: StateEventRulesetFilter!
  ): DeleteStateEventRulesetPayload
  deleteTestResult(filter: TestResultFilter!): DeleteTestResultPayload
  deleteTestSpecification(
    filter: TestSpecificationFilter!
  ): DeleteTestSpecificationPayload
  deleteTransitionEventRuleset(
    filter: TransitionEventRulesetFilter!
  ): DeleteTransitionEventRulesetPayload
  deleteUnitOfMeasure(filter: UnitOfMeasureFilter!): DeleteUnitOfMeasurePayload
  deleteUnitOfMeasureConversion(
    filter: UnitOfMeasureConversionFilter!
  ): DeleteUnitOfMeasureConversionPayload
  deleteUser(filter: UserFilter!): DeleteUserPayload
  deleteUserRole(filter: UserRoleFilter!): DeleteUserRolePayload
  deleteWorkCalendar(filter: WorkCalendarFilter!): DeleteWorkCalendarPayload
  deleteWorkCalendarDefinitionEntry(
    filter: WorkCalendarDefinitionEntryFilter!
  ): DeleteWorkCalendarDefinitionEntryPayload
  deleteWorkCalendarEntry(
    filter: WorkCalendarEntryFilter!
  ): DeleteWorkCalendarEntryPayload
  deleteWorkflowConnection(
    filter: WorkflowConnectionFilter!
  ): DeleteWorkflowConnectionPayload
  deleteWorkflowConnectionType(
    filter: WorkflowConnectionTypeFilter!
  ): DeleteWorkflowConnectionTypePayload
  deleteWorkflowInstance(
    filter: WorkflowInstanceFilter!
  ): DeleteWorkflowInstancePayload
  deleteWorkflowInstanceProperty(
    filter: WorkflowInstancePropertyFilter!
  ): DeleteWorkflowInstancePropertyPayload
  deleteWorkflowNode(filter: WorkflowNodeFilter!): DeleteWorkflowNodePayload
  deleteWorkflowNodeEvent(
    filter: WorkflowNodeEventFilter!
  ): DeleteWorkflowNodeEventPayload
  deleteWorkflowNodeInstance(
    filter: WorkflowNodeInstanceFilter!
  ): DeleteWorkflowNodeInstancePayload
  deleteWorkflowNodeType(
    filter: WorkflowNodeTypeFilter!
  ): DeleteWorkflowNodeTypePayload
  deleteWorkflowProperty(
    filter: WorkflowPropertyFilter!
  ): DeleteWorkflowPropertyPayload
  deleteWorkflowPropertyInstance(
    filter: WorkflowPropertyInstanceFilter!
  ): DeleteWorkflowPropertyInstancePayload
  deleteWorkflowPropertyValue(
    filter: WorkflowPropertyValueFilter!
  ): DeleteWorkflowPropertyValuePayload
  deleteWorkflowSpecification(
    filter: WorkflowSpecificationFilter!
  ): DeleteWorkflowSpecificationPayload
  moveCarrierToBin(input: [InventoryTransactionInput!]!): [InventoryTransaction]
  moveMaterialQuantitiesBetweenCarriers(
    input: MoveMaterialQuantitiesBetweenCarriersInput!
  ): [InventoryTransaction]
  moveMaterialSubLots(input: MoveMaterialSubLotsInput!): [InventoryTransaction]
  packInventoryTransaction(
    input: [InventoryTransactionInput!]!
  ): [InventoryTransaction]
  receiveInboundShipments(input: [ReceiveInboundShipmentInput!]!): [Shipment]

  #  replay raw sensor history from an InfluxDB bucket and measure for a list of equipment and time range
  # Deletes the run-time data in dgraph and influxDB for that equipment and replays the raw events into MQTT
  replayRawData(input: ReplayRawDataInput!): String
  splitEventLogTs(input: [EventLogTsInput]!): [EventLogTs]
  updateACL(input: UpdateACLInput!): UpdateACLPayload
  updateAccessRight(input: UpdateAccessRightInput!): UpdateAccessRightPayload
  updateAddress(input: UpdateAddressInput!): UpdateAddressPayload
  updateBillOfMaterial(
    input: UpdateBillOfMaterialInput!
  ): UpdateBillOfMaterialPayload
  updateBox(input: UpdateBoxInput!): UpdateBoxPayload
  updateCarrier(input: UpdateCarrierInput!): UpdateCarrierPayload
  updateDashboardConfig(
    input: UpdateDashboardConfigInput!
  ): UpdateDashboardConfigPayload
  updateDashboardPanelConfig(
    input: UpdateDashboardPanelConfigInput!
  ): UpdateDashboardPanelConfigPayload
  updateDashboardWidgetConfigProperty(
    input: UpdateDashboardWidgetConfigPropertyInput!
  ): UpdateDashboardWidgetConfigPropertyPayload
  updateDelivery(input: UpdateDeliveryInput!): UpdateDeliveryPayload
  updateEquipment(input: UpdateEquipmentInput!): UpdateEquipmentPayload
  updateEquipmentActual(
    input: UpdateEquipmentActualInput!
  ): UpdateEquipmentActualPayload
  updateEquipmentClass(
    input: UpdateEquipmentClassInput!
  ): UpdateEquipmentClassPayload
  updateEquipmentNameAlias(
    input: UpdateEquipmentNameAliasInput!
  ): UpdateEquipmentNameAliasPayload
  updateEquipmentPropertyOverride(
    input: UpdateEquipmentPropertyOverrideInput!
  ): UpdateEquipmentPropertyOverridePayload
  updateEquipmentReasonOverride(
    input: UpdateEquipmentReasonOverrideInput!
  ): UpdateEquipmentReasonOverridePayload
  updateEquipmentRelation(
    input: UpdateEquipmentRelationInput!
  ): UpdateEquipmentRelationPayload
  updateEquipmentSpecification(
    input: UpdateEquipmentSpecificationInput!
  ): UpdateEquipmentSpecificationPayload
  updateEventDefinition(
    input: UpdateEventDefinitionInput!
  ): UpdateEventDefinitionPayload
  updateEventLog(input: UpdateEventLogInput!): UpdateEventLogPayload
  updateEventLogTs(input: [EventLogTsInput]!): [EventLogTs]
  updateForm(input: UpdateFormInput!): UpdateFormPayload
  updateGeneralLedgerAccount(
    input: UpdateGeneralLedgerAccountInput!
  ): UpdateGeneralLedgerAccountPayload
  updateInterfaceMessageLog(
    input: UpdateInterfaceMessageLogInput!
  ): UpdateInterfaceMessageLogPayload
  updateInventoryHandlingPolicy(
    input: UpdateInventoryHandlingPolicyInput!
  ): UpdateInventoryHandlingPolicyPayload
  updateInventoryHandlingRule(
    input: UpdateInventoryHandlingRuleInput!
  ): UpdateInventoryHandlingRulePayload
  updateInventoryHoldingPolicy(
    input: UpdateInventoryHoldingPolicyInput!
  ): UpdateInventoryHoldingPolicyPayload
  updateJobOrder(input: UpdateJobOrderInput!): UpdateJobOrderPayload
  updateJobOrderDependency(
    input: UpdateJobOrderDependencyInput!
  ): UpdateJobOrderDependencyPayload
  updateJobOrderDispatchStateModel(
    input: UpdateJobOrderDispatchStateModelInput!
  ): UpdateJobOrderDispatchStateModelPayload
  updateJobOrderNote(input: UpdateJobOrderNoteInput!): UpdateJobOrderNotePayload

  #  update the status of a JobOrder. If setting the status to active, update any existing active orders
  # for the same equipment to complete and update the associated JobResponse.endDateTime.
  # When setting the status to ACTIVE, if there is no open JobResponse, create one and set the jobResponse.startDateTime
  # If setting the status to complete, update the associated JobResponse.endDateTime
  updateJobOrderStatus(input: UpdateJobOrderStatusInput): [JobOrder]
  updateJobResponse(input: UpdateJobResponseInput!): UpdateJobResponsePayload
  updateLibreService(input: UpdateLibreServiceInput!): UpdateLibreServicePayload
  updateMaterialActual(
    input: UpdateMaterialActualInput!
  ): UpdateMaterialActualPayload
  updateMaterialAlternate(
    input: UpdateMaterialAlternateInput!
  ): UpdateMaterialAlternatePayload
  updateMaterialClass(
    input: UpdateMaterialClassInput!
  ): UpdateMaterialClassPayload
  updateMaterialDefinition(
    input: UpdateMaterialDefinitionInput!
  ): UpdateMaterialDefinitionPayload
  updateMaterialEventRuleset(
    input: UpdateMaterialEventRulesetInput!
  ): UpdateMaterialEventRulesetPayload
  updateMaterialLot(input: UpdateMaterialLotInput!): UpdateMaterialLotPayload
  updateMaterialSpecification(
    input: UpdateMaterialSpecificationInput!
  ): UpdateMaterialSpecificationPayload
  updateMaterialStateModel(
    input: UpdateMaterialStateModelInput!
  ): UpdateMaterialStateModelPayload
  updateMaterialStateTransition(
    input: UpdateMaterialStateTransitionInput!
  ): UpdateMaterialStateTransitionPayload
  updateMaterialStatus(
    input: UpdateMaterialStatusInput!
  ): UpdateMaterialStatusPayload
  updateMaterialSubLot(
    input: UpdateMaterialSubLotInput!
  ): UpdateMaterialSubLotPayload
  updateMaterialUnit(input: UpdateMaterialUnitInput!): UpdateMaterialUnitPayload
  updateMenu(input: UpdateMenuInput!): UpdateMenuPayload
  updateOperationsDefinition(
    input: UpdateOperationsDefinitionInput!
  ): UpdateOperationsDefinitionPayload
  updateOperationsRequest(
    input: UpdateOperationsRequestInput!
  ): UpdateOperationsRequestPayload
  updateOperationsSegment(
    input: UpdateOperationsSegmentInput!
  ): UpdateOperationsSegmentPayload
  updateOrder(input: UpdateOrderInput!): UpdateOrderPayload
  updateOrderLine(input: UpdateOrderLineInput!): UpdateOrderLinePayload
  updateOrderStartRuleset(
    input: UpdateOrderStartRulesetInput!
  ): UpdateOrderStartRulesetPayload
  updateOrderStatusRetroactively(
    input: UpdateOrderStatusInput
  ): UpdatedOrderStatus
  updateParameterSpecification(
    input: UpdateParameterSpecificationInput!
  ): UpdateParameterSpecificationPayload
  updatePartner(input: UpdatePartnerInput!): UpdatePartnerPayload
  updatePayloadFieldDefinition(
    input: UpdatePayloadFieldDefinitionInput!
  ): UpdatePayloadFieldDefinitionPayload
  updatePerson(input: UpdatePersonInput!): UpdatePersonPayload
  updatePersonnelActual(
    input: UpdatePersonnelActualInput!
  ): UpdatePersonnelActualPayload
  updatePersonnelClass(
    input: UpdatePersonnelClassInput!
  ): UpdatePersonnelClassPayload
  updatePersonnelSpecification(
    input: UpdatePersonnelSpecificationInput!
  ): UpdatePersonnelSpecificationPayload
  updateProperty(input: UpdatePropertyInput!): UpdatePropertyPayload
  updatePropertyNameAlias(
    input: UpdatePropertyNameAliasInput!
  ): UpdatePropertyNameAliasPayload
  updatePropertyValueAlias(
    input: UpdatePropertyValueAliasInput!
  ): UpdatePropertyValueAliasPayload
  updateQuantityLog(input: UpdateQuantityLogInput!): UpdateQuantityLogPayload
  updateReason(input: UpdateReasonInput!): UpdateReasonPayload
  updateReasonCategory(
    input: UpdateReasonCategoryInput!
  ): UpdateReasonCategoryPayload
  updateRequestState(input: UpdateRequestStateInput!): UpdateRequestStatePayload
  updateRole(input: UpdateRoleInput!): UpdateRolePayload
  updateSegmentDependency(
    input: UpdateSegmentDependencyInput!
  ): UpdateSegmentDependencyPayload
  updateSegmentInvoiceSetting(
    input: UpdateSegmentInvoiceSettingInput!
  ): UpdateSegmentInvoiceSettingPayload
  updateShipment(input: UpdateShipmentInput!): UpdateShipmentPayload
  updateShipmentItem(input: UpdateShipmentItemInput!): UpdateShipmentItemPayload
  updateShippingAccount(
    input: UpdateShippingAccountInput!
  ): UpdateShippingAccountPayload
  updateStateEventRuleset(
    input: UpdateStateEventRulesetInput!
  ): UpdateStateEventRulesetPayload
  updateTestResult(input: UpdateTestResultInput!): UpdateTestResultPayload
  updateTestSpecification(
    input: UpdateTestSpecificationInput!
  ): UpdateTestSpecificationPayload
  updateTransitionEventRuleset(
    input: UpdateTransitionEventRulesetInput!
  ): UpdateTransitionEventRulesetPayload
  updateUnitOfMeasure(
    input: UpdateUnitOfMeasureInput!
  ): UpdateUnitOfMeasurePayload
  updateUnitOfMeasureConversion(
    input: UpdateUnitOfMeasureConversionInput!
  ): UpdateUnitOfMeasureConversionPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  updateUserRole(input: UpdateUserRoleInput!): UpdateUserRolePayload
  updateWorkCalendar(input: UpdateWorkCalendarInput!): UpdateWorkCalendarPayload
  updateWorkCalendarDefinitionEntry(
    input: UpdateWorkCalendarDefinitionEntryInput!
  ): UpdateWorkCalendarDefinitionEntryPayload
  updateWorkCalendarEntry(
    input: UpdateWorkCalendarEntryInput!
  ): UpdateWorkCalendarEntryPayload
  updateWorkflowConnection(
    input: UpdateWorkflowConnectionInput!
  ): UpdateWorkflowConnectionPayload
  updateWorkflowConnectionType(
    input: UpdateWorkflowConnectionTypeInput!
  ): UpdateWorkflowConnectionTypePayload
  updateWorkflowInstance(
    input: UpdateWorkflowInstanceInput!
  ): UpdateWorkflowInstancePayload
  updateWorkflowInstanceProperty(
    input: UpdateWorkflowInstancePropertyInput!
  ): UpdateWorkflowInstancePropertyPayload
  updateWorkflowNode(input: UpdateWorkflowNodeInput!): UpdateWorkflowNodePayload
  updateWorkflowNodeEvent(
    input: UpdateWorkflowNodeEventInput!
  ): UpdateWorkflowNodeEventPayload
  updateWorkflowNodeInstance(
    input: UpdateWorkflowNodeInstanceInput!
  ): UpdateWorkflowNodeInstancePayload
  updateWorkflowNodeType(
    input: UpdateWorkflowNodeTypeInput!
  ): UpdateWorkflowNodeTypePayload
  updateWorkflowProperty(
    input: UpdateWorkflowPropertyInput!
  ): UpdateWorkflowPropertyPayload
  updateWorkflowPropertyInstance(
    input: UpdateWorkflowPropertyInstanceInput!
  ): UpdateWorkflowPropertyInstancePayload
  updateWorkflowPropertyValue(
    input: UpdateWorkflowPropertyValueInput!
  ): UpdateWorkflowPropertyValuePayload
  updateWorkflowSpecification(
    input: UpdateWorkflowSpecificationInput!
  ): UpdateWorkflowSpecificationPayload

  #  Update a workflow node instance. This can update the user, properties or status of the task
  updateWorkflowTask(input: UpdateWorkflowTaskInput!): WorkflowNodeInstance
  uploadProductionPlan(input: String!): [JobOrder]
  uploadSchedule(input: [UploadScheduleInput]!): UploadScheduleStaging
  uploadStagedSchedule(
    input: UploadStagedScheduleInput!
  ): UploadStagedScheduleOutput
}

input NearFilter {
  coordinate: PointRef!
  distance: Float!
}

type OperationsDefinition {
  billOfMaterial(filter: BillOfMaterialFilter): BillOfMaterial
  description: String
  hierarchyScope: String
  id: ID!
  isActive: Boolean
  material(filter: MaterialDefinitionFilter): MaterialDefinition
  name: String!
  operationsType: WorkType!
  segments(
    filter: OperationsSegmentFilter
    first: Int
    offset: Int
    order: OperationsSegmentOrder
  ): [OperationsSegment]
  segmentsAggregate(
    filter: OperationsSegmentFilter
  ): OperationsSegmentAggregateResult
  version: String
}

type OperationsDefinitionAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  hierarchyScopeMax: String
  hierarchyScopeMin: String
  nameMax: String
  nameMin: String
  versionMax: String
  versionMin: String
}

input OperationsDefinitionFilter {
  and: [OperationsDefinitionFilter]
  has: [OperationsDefinitionHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: OperationsDefinitionFilter
  or: [OperationsDefinitionFilter]
}

enum OperationsDefinitionHasFilter {
  billOfMaterial
  description
  hierarchyScope
  isActive
  material
  name
  operationsType
  segments
  version
}

input OperationsDefinitionOrder {
  asc: OperationsDefinitionOrderable
  desc: OperationsDefinitionOrderable
  then: OperationsDefinitionOrder
}

enum OperationsDefinitionOrderable {
  description
  hierarchyScope
  name
  version
}

input OperationsDefinitionPatch {
  billOfMaterial: BillOfMaterialRef
  description: String
  hierarchyScope: String
  isActive: Boolean
  material: MaterialDefinitionRef
  operationsType: WorkType
  segments: [OperationsSegmentRef]
  version: String
}

input OperationsDefinitionRef {
  billOfMaterial: BillOfMaterialRef
  description: String
  hierarchyScope: String
  id: ID
  isActive: Boolean
  material: MaterialDefinitionRef
  name: String
  operationsType: WorkType
  segments: [OperationsSegmentRef]
  version: String
}

# A request for operations to be performed is an operations schedule.
# The schedule may apply to operations, maintenance, quality or inventory operations
type OperationsRequest {
  actualProducedQuantity: Float
  actualStartDateTime: DateTime
  code: String!
  equipment(filter: EquipmentFilter): Equipment
  id: ID!
  isActive: Boolean
  jobOrders(
    filter: JobOrderFilter
    first: Int
    offset: Int
    order: JobOrderOrder
  ): [JobOrder]
  jobOrdersAggregate(filter: JobOrderFilter): JobOrderAggregateResult
  operationsDefinition(
    filter: OperationsDefinitionFilter
  ): OperationsDefinition!
  operationsType: WorkType!
  plannedEndDateTime: DateTime
  plannedStartDateTime: DateTime
  priority: String
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  quantity: Float!
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure!
  requestState(filter: RequestStateFilter): RequestState!
}

type OperationsRequestAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
  plannedEndDateTimeMax: DateTime
  plannedEndDateTimeMin: DateTime
  plannedStartDateTimeMax: DateTime
  plannedStartDateTimeMin: DateTime
  priorityMax: String
  priorityMin: String
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input OperationsRequestFilter {
  and: [OperationsRequestFilter]
  code: StringHashFilter
  has: [OperationsRequestHasFilter]
  id: [ID!]
  isActive: Boolean
  not: OperationsRequestFilter
  operationsType: WorkType_hash
  or: [OperationsRequestFilter]
  plannedEndDateTime: DateTimeFilter
  plannedStartDateTime: DateTimeFilter
}

enum OperationsRequestHasFilter {
  code
  equipment
  isActive
  jobOrders
  operationsDefinition
  operationsType
  plannedEndDateTime
  plannedStartDateTime
  priority
  properties
  quantity
  quantityUoM
  requestState
}

input OperationsRequestOrder {
  asc: OperationsRequestOrderable
  desc: OperationsRequestOrderable
  then: OperationsRequestOrder
}

enum OperationsRequestOrderable {
  code
  plannedEndDateTime
  plannedStartDateTime
  priority
  quantity
}

input OperationsRequestPatch {
  equipment: EquipmentRef
  isActive: Boolean
  jobOrders: [JobOrderRef]
  operationsDefinition: OperationsDefinitionRef
  operationsType: WorkType
  plannedEndDateTime: DateTime
  plannedStartDateTime: DateTime
  priority: String
  properties: [PropertyRef]
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  requestState: RequestStateRef
}

input OperationsRequestRef {
  code: String
  equipment: EquipmentRef
  id: ID
  isActive: Boolean
  jobOrders: [JobOrderRef]
  operationsDefinition: OperationsDefinitionRef
  operationsType: WorkType
  plannedEndDateTime: DateTime
  plannedStartDateTime: DateTime
  priority: String
  properties: [PropertyRef]
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  requestState: RequestStateRef
}

type OperationsRequestStaging {
  code: String
  errList: [String]
  isValid: Boolean
  materialNo: String
  operationsDefinition: String
  plannedEndDateTime: DateTime
  plannedStartDateTime: DateTime
  quantity: Float
  quantityUoM: String
}

input OperationsRequestStagingInput {
  code: String!
  operationsDefinition: String!
  plannedEndDateTime: DateTime!
  plannedStartDateTime: DateTime!
  quantity: Float!
  quantityUoM: String
}

type OperationsSegment {
  children(
    filter: OperationsSegmentFilter
    first: Int
    offset: Int
    order: OperationsSegmentOrder
  ): [OperationsSegment]
  childrenAggregate(
    filter: OperationsSegmentFilter
  ): OperationsSegmentAggregateResult
  costAmountDirectLabourRate: Float
  costAmountFixedOverhead: Float
  costAmountVariableOverhead: Float
  costDriverFixedOverhead: CostDriver
  description: String
  duration: Float
  durationUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  equipmentSpecifications(
    filter: EquipmentSpecificationFilter
    first: Int
    offset: Int
    order: EquipmentSpecificationOrder
  ): [EquipmentSpecification]
  equipmentSpecificationsAggregate(
    filter: EquipmentSpecificationFilter
  ): EquipmentSpecificationAggregateResult
  glAccountDirectLabour: String
  glAccountFixedOverhead: String
  glAccountVariableOverhead: String
  glAccountWIP: String
  glAccountWIPInvoice: String
  hierarchyScope: String
  id: ID!
  inflows(
    filter: SegmentDependencyFilter
    first: Int
    offset: Int
    order: SegmentDependencyOrder
  ): [SegmentDependency]
  inflowsAggregate(
    filter: SegmentDependencyFilter
  ): SegmentDependencyAggregateResult
  invoiceSettings(
    filter: SegmentInvoiceSettingFilter
    first: Int
    offset: Int
    order: SegmentInvoiceSettingOrder
  ): [SegmentInvoiceSetting]
  invoiceSettingsAggregate(
    filter: SegmentInvoiceSettingFilter
  ): SegmentInvoiceSettingAggregateResult
  isActive: Boolean
  jobOrders(
    filter: JobOrderFilter
    first: Int
    offset: Int
    order: JobOrderOrder
  ): [JobOrder]
  jobOrdersAggregate(filter: JobOrderFilter): JobOrderAggregateResult
  materialEventRuleset(filter: MaterialEventRulesetFilter): MaterialEventRuleset
  materialSpecifications(
    filter: MaterialSpecificationFilter
    first: Int
    offset: Int
    order: MaterialSpecificationOrder
  ): [MaterialSpecification]
  materialSpecificationsAggregate(
    filter: MaterialSpecificationFilter
  ): MaterialSpecificationAggregateResult
  mpmAutoIdentMatchCode(filter: PropertyFilter): Property
  mpmChangeoverFamily: String
  mpmEnableAutoIdent: Boolean
  mpmEnableSmartChangeover: Boolean
  mpmIdealChangeoverTime: Float
  mpmIdealSetupTime: Float
  mpmPlanRate: Float
  mpmThresholdMicrostopDuration: Float
  mpmThresholdRunDuration: Float
  mpmThresholdRunRate: Float
  mpmThresholdSlowDuration: Float
  mpmThresholdSlowRate: Float
  name: String!
  operationsDefinition(filter: OperationsDefinitionFilter): OperationsDefinition
  orderStartRuleset(filter: OrderStartRulesetFilter): OrderStartRuleset
  outflows(
    filter: SegmentDependencyFilter
    first: Int
    offset: Int
    order: SegmentDependencyOrder
  ): [SegmentDependency]
  outflowsAggregate(
    filter: SegmentDependencyFilter
  ): SegmentDependencyAggregateResult
  parameterSpecifications(
    filter: ParameterSpecificationFilter
    first: Int
    offset: Int
    order: ParameterSpecificationOrder
  ): [ParameterSpecification]
  parameterSpecificationsAggregate(
    filter: ParameterSpecificationFilter
  ): ParameterSpecificationAggregateResult
  parent(filter: OperationsSegmentFilter): OperationsSegment
  personnelSpecifications(
    filter: PersonnelSpecificationFilter
    first: Int
    offset: Int
    order: PersonnelSpecificationOrder
  ): [PersonnelSpecification]
  personnelSpecificationsAggregate(
    filter: PersonnelSpecificationFilter
  ): PersonnelSpecificationAggregateResult
  positionX: Int
  positionY: Int
  stateEventRuleset(filter: StateEventRulesetFilter): StateEventRuleset
  type: SegmentType
  uiComponent: String
  version: String
  workDefinitionType: String
  workType: WorkType
}

type OperationsSegmentAggregateResult {
  costAmountDirectLabourRateAvg: Float
  costAmountDirectLabourRateMax: Float
  costAmountDirectLabourRateMin: Float
  costAmountDirectLabourRateSum: Float
  costAmountFixedOverheadAvg: Float
  costAmountFixedOverheadMax: Float
  costAmountFixedOverheadMin: Float
  costAmountFixedOverheadSum: Float
  costAmountVariableOverheadAvg: Float
  costAmountVariableOverheadMax: Float
  costAmountVariableOverheadMin: Float
  costAmountVariableOverheadSum: Float
  count: Int
  descriptionMax: String
  descriptionMin: String
  durationAvg: Float
  durationMax: Float
  durationMin: Float
  durationSum: Float
  glAccountDirectLabourMax: String
  glAccountDirectLabourMin: String
  glAccountFixedOverheadMax: String
  glAccountFixedOverheadMin: String
  glAccountVariableOverheadMax: String
  glAccountVariableOverheadMin: String
  glAccountWIPInvoiceMax: String
  glAccountWIPInvoiceMin: String
  glAccountWIPMax: String
  glAccountWIPMin: String
  hierarchyScopeMax: String
  hierarchyScopeMin: String
  mpmChangeoverFamilyMax: String
  mpmChangeoverFamilyMin: String
  mpmIdealChangeoverTimeAvg: Float
  mpmIdealChangeoverTimeMax: Float
  mpmIdealChangeoverTimeMin: Float
  mpmIdealChangeoverTimeSum: Float
  mpmIdealSetupTimeAvg: Float
  mpmIdealSetupTimeMax: Float
  mpmIdealSetupTimeMin: Float
  mpmIdealSetupTimeSum: Float
  mpmPlanRateAvg: Float
  mpmPlanRateMax: Float
  mpmPlanRateMin: Float
  mpmPlanRateSum: Float
  mpmThresholdMicrostopDurationAvg: Float
  mpmThresholdMicrostopDurationMax: Float
  mpmThresholdMicrostopDurationMin: Float
  mpmThresholdMicrostopDurationSum: Float
  mpmThresholdRunDurationAvg: Float
  mpmThresholdRunDurationMax: Float
  mpmThresholdRunDurationMin: Float
  mpmThresholdRunDurationSum: Float
  mpmThresholdRunRateAvg: Float
  mpmThresholdRunRateMax: Float
  mpmThresholdRunRateMin: Float
  mpmThresholdRunRateSum: Float
  mpmThresholdSlowDurationAvg: Float
  mpmThresholdSlowDurationMax: Float
  mpmThresholdSlowDurationMin: Float
  mpmThresholdSlowDurationSum: Float
  mpmThresholdSlowRateAvg: Float
  mpmThresholdSlowRateMax: Float
  mpmThresholdSlowRateMin: Float
  mpmThresholdSlowRateSum: Float
  nameMax: String
  nameMin: String
  positionXAvg: Float
  positionXMax: Int
  positionXMin: Int
  positionXSum: Int
  positionYAvg: Float
  positionYMax: Int
  positionYMin: Int
  positionYSum: Int
  uiComponentMax: String
  uiComponentMin: String
  versionMax: String
  versionMin: String
  workDefinitionTypeMax: String
  workDefinitionTypeMin: String
}

input OperationsSegmentFilter {
  and: [OperationsSegmentFilter]
  description: StringHashFilter
  has: [OperationsSegmentHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: OperationsSegmentFilter
  or: [OperationsSegmentFilter]
  workDefinitionType: StringHashFilter
  workType: WorkType_hash
}

enum OperationsSegmentHasFilter {
  children
  costAmountDirectLabourRate
  costAmountFixedOverhead
  costAmountVariableOverhead
  costDriverFixedOverhead
  description
  duration
  durationUoM
  equipmentSpecifications
  glAccountDirectLabour
  glAccountFixedOverhead
  glAccountVariableOverhead
  glAccountWIP
  glAccountWIPInvoice
  hierarchyScope
  inflows
  invoiceSettings
  isActive
  jobOrders
  materialEventRuleset
  materialSpecifications
  mpmAutoIdentMatchCode
  mpmChangeoverFamily
  mpmEnableAutoIdent
  mpmEnableSmartChangeover
  mpmIdealChangeoverTime
  mpmIdealSetupTime
  mpmPlanRate
  mpmThresholdMicrostopDuration
  mpmThresholdRunDuration
  mpmThresholdRunRate
  mpmThresholdSlowDuration
  mpmThresholdSlowRate
  name
  operationsDefinition
  orderStartRuleset
  outflows
  parameterSpecifications
  parent
  personnelSpecifications
  positionX
  positionY
  stateEventRuleset
  type
  uiComponent
  version
  workDefinitionType
  workType
}

input OperationsSegmentOrder {
  asc: OperationsSegmentOrderable
  desc: OperationsSegmentOrderable
  then: OperationsSegmentOrder
}

enum OperationsSegmentOrderable {
  costAmountDirectLabourRate
  costAmountFixedOverhead
  costAmountVariableOverhead
  description
  duration
  glAccountDirectLabour
  glAccountFixedOverhead
  glAccountVariableOverhead
  glAccountWIP
  glAccountWIPInvoice
  hierarchyScope
  mpmChangeoverFamily
  mpmIdealChangeoverTime
  mpmIdealSetupTime
  mpmPlanRate
  mpmThresholdMicrostopDuration
  mpmThresholdRunDuration
  mpmThresholdRunRate
  mpmThresholdSlowDuration
  mpmThresholdSlowRate
  name
  positionX
  positionY
  uiComponent
  version
  workDefinitionType
}

input OperationsSegmentPatch {
  children: [OperationsSegmentRef]
  costAmountDirectLabourRate: Float
  costAmountFixedOverhead: Float
  costAmountVariableOverhead: Float
  costDriverFixedOverhead: CostDriver
  description: String
  duration: Float
  durationUoM: UnitOfMeasureRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  glAccountDirectLabour: String
  glAccountFixedOverhead: String
  glAccountVariableOverhead: String
  glAccountWIP: String
  glAccountWIPInvoice: String
  hierarchyScope: String
  inflows: [SegmentDependencyRef]
  invoiceSettings: [SegmentInvoiceSettingRef]
  isActive: Boolean
  jobOrders: [JobOrderRef]
  materialEventRuleset: MaterialEventRulesetRef
  materialSpecifications: [MaterialSpecificationRef]
  mpmAutoIdentMatchCode: PropertyRef
  mpmChangeoverFamily: String
  mpmEnableAutoIdent: Boolean
  mpmEnableSmartChangeover: Boolean
  mpmIdealChangeoverTime: Float
  mpmIdealSetupTime: Float
  mpmPlanRate: Float
  mpmThresholdMicrostopDuration: Float
  mpmThresholdRunDuration: Float
  mpmThresholdRunRate: Float
  mpmThresholdSlowDuration: Float
  mpmThresholdSlowRate: Float
  name: String
  operationsDefinition: OperationsDefinitionRef
  orderStartRuleset: OrderStartRulesetRef
  outflows: [SegmentDependencyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  parent: OperationsSegmentRef
  personnelSpecifications: [PersonnelSpecificationRef]
  positionX: Int
  positionY: Int
  stateEventRuleset: StateEventRulesetRef
  type: SegmentType
  uiComponent: String
  version: String
  workDefinitionType: String
  workType: WorkType
}

input OperationsSegmentRef {
  children: [OperationsSegmentRef]
  costAmountDirectLabourRate: Float
  costAmountFixedOverhead: Float
  costAmountVariableOverhead: Float
  costDriverFixedOverhead: CostDriver
  description: String
  duration: Float
  durationUoM: UnitOfMeasureRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  glAccountDirectLabour: String
  glAccountFixedOverhead: String
  glAccountVariableOverhead: String
  glAccountWIP: String
  glAccountWIPInvoice: String
  hierarchyScope: String
  id: ID
  inflows: [SegmentDependencyRef]
  invoiceSettings: [SegmentInvoiceSettingRef]
  isActive: Boolean
  jobOrders: [JobOrderRef]
  materialEventRuleset: MaterialEventRulesetRef
  materialSpecifications: [MaterialSpecificationRef]
  mpmAutoIdentMatchCode: PropertyRef
  mpmChangeoverFamily: String
  mpmEnableAutoIdent: Boolean
  mpmEnableSmartChangeover: Boolean
  mpmIdealChangeoverTime: Float
  mpmIdealSetupTime: Float
  mpmPlanRate: Float
  mpmThresholdMicrostopDuration: Float
  mpmThresholdRunDuration: Float
  mpmThresholdRunRate: Float
  mpmThresholdSlowDuration: Float
  mpmThresholdSlowRate: Float
  name: String
  operationsDefinition: OperationsDefinitionRef
  orderStartRuleset: OrderStartRulesetRef
  outflows: [SegmentDependencyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  parent: OperationsSegmentRef
  personnelSpecifications: [PersonnelSpecificationRef]
  positionX: Int
  positionY: Int
  stateEventRuleset: StateEventRulesetRef
  type: SegmentType
  uiComponent: String
  version: String
  workDefinitionType: String
  workType: WorkType
}

# An outbound Sales Order to be fulfilled
type Order {
  createdDateTime: DateTime
  customerOrderNumber: String
  customerReference: String
  deliveryTerms: IncoTerms
  id: ID!
  invoiceFromPartner(filter: PartnerFilter): Partner
  invoiceToPartner(filter: PartnerFilter): Partner
  isActive: Boolean
  lines(
    filter: OrderLineFilter
    first: Int
    offset: Int
    order: OrderLineOrder
  ): [OrderLine]
  linesAggregate(filter: OrderLineFilter): OrderLineAggregateResult
  linesWithAlternates: [OrderLine]
  materialList: [MaterialDefinition]
  notes: String
  orderType: OrderType!
  shipFromPartner(filter: PartnerFilter): Partner
  shipToPartner(filter: PartnerFilter): Partner
  shipments(
    filter: ShipmentFilter
    first: Int
    offset: Int
    order: ShipmentOrder
  ): [Shipment]
  shipmentsAggregate(filter: ShipmentFilter): ShipmentAggregateResult
  status: OrderStatus!
  warehouse(filter: EquipmentFilter): Equipment
}

type OrderAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  customerOrderNumberMax: String
  customerOrderNumberMin: String
  customerReferenceMax: String
  customerReferenceMin: String
  notesMax: String
  notesMin: String
}

input OrderFilter {
  and: [OrderFilter]
  customerOrderNumber: StringFullTextFilter_StringHashFilter
  has: [OrderHasFilter]
  id: [ID!]
  isActive: Boolean
  not: OrderFilter
  or: [OrderFilter]
  orderType: OrderType_hash
  status: OrderStatus_hash
}

enum OrderHasFilter {
  createdDateTime
  customerOrderNumber
  customerReference
  deliveryTerms
  invoiceFromPartner
  invoiceToPartner
  isActive
  lines
  notes
  orderType
  shipFromPartner
  shipToPartner
  shipments
  status
  warehouse
}

type OrderLine {
  defectiveSerialNumbers: String
  id: ID!
  isActive: Boolean
  isReturn: Boolean
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
  order(filter: OrderFilter): Order
  orderLineNumber: Int!
  packedQty: Float
  quantity: Int!
  stockOnHandQty: Float
  workflowInstance(filter: WorkflowInstanceFilter): WorkflowInstance
}

type OrderLineAggregateResult {
  count: Int
  defectiveSerialNumbersMax: String
  defectiveSerialNumbersMin: String
  orderLineNumberAvg: Float
  orderLineNumberMax: Int
  orderLineNumberMin: Int
  orderLineNumberSum: Int
  quantityAvg: Float
  quantityMax: Int
  quantityMin: Int
  quantitySum: Int
}

input OrderLineFilter {
  and: [OrderLineFilter]
  has: [OrderLineHasFilter]
  id: [ID!]
  isActive: Boolean
  not: OrderLineFilter
  or: [OrderLineFilter]
}

enum OrderLineHasFilter {
  defectiveSerialNumbers
  isActive
  isReturn
  material
  order
  orderLineNumber
  quantity
  workflowInstance
}

input OrderLineOrder {
  asc: OrderLineOrderable
  desc: OrderLineOrderable
  then: OrderLineOrder
}

enum OrderLineOrderable {
  defectiveSerialNumbers
  orderLineNumber
  quantity
}

input OrderLinePatch {
  defectiveSerialNumbers: String
  isActive: Boolean
  isReturn: Boolean
  material: MaterialDefinitionRef
  order: OrderRef
  orderLineNumber: Int
  quantity: Int
  workflowInstance: WorkflowInstanceRef
}

input OrderLineRef {
  defectiveSerialNumbers: String
  id: ID
  isActive: Boolean
  isReturn: Boolean
  material: MaterialDefinitionRef
  order: OrderRef
  orderLineNumber: Int
  quantity: Int
  workflowInstance: WorkflowInstanceRef
}

input OrderOrder {
  asc: OrderOrderable
  desc: OrderOrderable
  then: OrderOrder
}

enum OrderOrderable {
  createdDateTime
  customerOrderNumber
  customerReference
  notes
}

input OrderPatch {
  createdDateTime: DateTime
  customerOrderNumber: String
  customerReference: String
  deliveryTerms: IncoTerms
  invoiceFromPartner: PartnerRef
  invoiceToPartner: PartnerRef
  isActive: Boolean
  lines: [OrderLineRef]
  notes: String
  orderType: OrderType
  shipFromPartner: PartnerRef
  shipToPartner: PartnerRef
  shipments: [ShipmentRef]
  status: OrderStatus
  warehouse: EquipmentRef
}

input OrderRef {
  createdDateTime: DateTime
  customerOrderNumber: String
  customerReference: String
  deliveryTerms: IncoTerms
  id: ID
  invoiceFromPartner: PartnerRef
  invoiceToPartner: PartnerRef
  isActive: Boolean
  lines: [OrderLineRef]
  notes: String
  orderType: OrderType
  shipFromPartner: PartnerRef
  shipToPartner: PartnerRef
  shipments: [ShipmentRef]
  status: OrderStatus
  warehouse: EquipmentRef
}

type OrderStartRuleset {
  eventDefs(
    filter: EventDefinitionFilter
    first: Int
    offset: Int
    order: EventDefinitionOrder
  ): [EventDefinition]
  eventDefsAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
  id: ID!
  name: String!
  segment(filter: OperationsSegmentFilter): OperationsSegment
}

type OrderStartRulesetAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
}

input OrderStartRulesetFilter {
  and: [OrderStartRulesetFilter]
  has: [OrderStartRulesetHasFilter]
  id: [ID!]
  not: OrderStartRulesetFilter
  or: [OrderStartRulesetFilter]
}

enum OrderStartRulesetHasFilter {
  eventDefs
  name
  segment
}

input OrderStartRulesetOrder {
  asc: OrderStartRulesetOrderable
  desc: OrderStartRulesetOrderable
  then: OrderStartRulesetOrder
}

enum OrderStartRulesetOrderable {
  name
}

input OrderStartRulesetPatch {
  eventDefs: [EventDefinitionRef]
  name: String
  segment: OperationsSegmentRef
}

input OrderStartRulesetRef {
  eventDefs: [EventDefinitionRef]
  id: ID
  name: String
  segment: OperationsSegmentRef
}

enum OrderStatus {
  COMPLETE
  CREATED
  DELIVERED
  PACKED
  RECEIVED
  SHIPPED
}

input OrderStatus_hash {
  eq: OrderStatus
  in: [OrderStatus]
}

enum OrderType {
  PURCHASE_ORDER
  REPAIR_ORDER
  REPLACE_ORDER
  RETURN_ORDER
  SALES_ORDER
}

input OrderType_hash {
  eq: OrderType
  in: [OrderType]
}

type PackedItem {
  FromPlace: PackedItemFrom
  Qty: Float
  SerialNumber: String
  material: MaterialDefinition
}

type PackedItemFrom {
  carrier: Carrier
  materialSubLot: MaterialSubLot
  storageLocation: Equipment
}

input PackedItemsFilter {
  isAccessory: Boolean
  isTerminal: Boolean
}

type ParameterSpecification {
  id: ID!
  isActive: Boolean
  jobOrder(filter: JobOrderFilter): JobOrder
  material(filter: MaterialDefinitionFilter): MaterialDefinition
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment
  property(filter: PropertyFilter): Property!
  valueDefault: String
  valueLowerControlLimit: Float
  valueLowerSpecLimit: Float
  valueSetPoint: String
  valueUpperControlLimit: Float
  valueUpperSpecLimit: Float
}

type ParameterSpecificationAggregateResult {
  count: Int
  valueDefaultMax: String
  valueDefaultMin: String
  valueLowerControlLimitAvg: Float
  valueLowerControlLimitMax: Float
  valueLowerControlLimitMin: Float
  valueLowerControlLimitSum: Float
  valueLowerSpecLimitAvg: Float
  valueLowerSpecLimitMax: Float
  valueLowerSpecLimitMin: Float
  valueLowerSpecLimitSum: Float
  valueSetPointMax: String
  valueSetPointMin: String
  valueUpperControlLimitAvg: Float
  valueUpperControlLimitMax: Float
  valueUpperControlLimitMin: Float
  valueUpperControlLimitSum: Float
  valueUpperSpecLimitAvg: Float
  valueUpperSpecLimitMax: Float
  valueUpperSpecLimitMin: Float
  valueUpperSpecLimitSum: Float
}

input ParameterSpecificationFilter {
  and: [ParameterSpecificationFilter]
  has: [ParameterSpecificationHasFilter]
  id: [ID!]
  isActive: Boolean
  not: ParameterSpecificationFilter
  or: [ParameterSpecificationFilter]
}

enum ParameterSpecificationHasFilter {
  isActive
  jobOrder
  material
  operationsSegment
  property
  valueDefault
  valueLowerControlLimit
  valueLowerSpecLimit
  valueSetPoint
  valueUpperControlLimit
  valueUpperSpecLimit
}

input ParameterSpecificationOrder {
  asc: ParameterSpecificationOrderable
  desc: ParameterSpecificationOrderable
  then: ParameterSpecificationOrder
}

enum ParameterSpecificationOrderable {
  valueDefault
  valueLowerControlLimit
  valueLowerSpecLimit
  valueSetPoint
  valueUpperControlLimit
  valueUpperSpecLimit
}

input ParameterSpecificationPatch {
  isActive: Boolean
  jobOrder: JobOrderRef
  material: MaterialDefinitionRef
  operationsSegment: OperationsSegmentRef
  property: PropertyRef
  valueDefault: String
  valueLowerControlLimit: Float
  valueLowerSpecLimit: Float
  valueSetPoint: String
  valueUpperControlLimit: Float
  valueUpperSpecLimit: Float
}

input ParameterSpecificationRef {
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  material: MaterialDefinitionRef
  operationsSegment: OperationsSegmentRef
  property: PropertyRef
  valueDefault: String
  valueLowerControlLimit: Float
  valueLowerSpecLimit: Float
  valueSetPoint: String
  valueUpperControlLimit: Float
  valueUpperSpecLimit: Float
}

type Partner {
  billingAddress(filter: AddressFilter): Address
  carriers(
    filter: CarrierFilter
    first: Int
    offset: Int
    order: CarrierOrder
  ): [Carrier]
  carriersAggregate(filter: CarrierFilter): CarrierAggregateResult
  companyCode: String!
  contactEmail: String
  contactName: String
  contactPhone: String
  fromOrders(
    filter: OrderFilter
    first: Int
    offset: Int
    order: OrderOrder
  ): [Order]
  fromOrdersAggregate(filter: OrderFilter): OrderAggregateResult
  id: ID!
  isActive: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  name: String
  registrationNumber: String
  shippingAccounts(
    filter: ShippingAccountFilter
    first: Int
    offset: Int
    order: ShippingAccountOrder
  ): [ShippingAccount]
  shippingAccountsAggregate(
    filter: ShippingAccountFilter
  ): ShippingAccountAggregateResult
  shippingAddress(filter: AddressFilter): Address
  toOrders(
    filter: OrderFilter
    first: Int
    offset: Int
    order: OrderOrder
  ): [Order]
  toOrdersAggregate(filter: OrderFilter): OrderAggregateResult
  vatNumber: String
}

type PartnerAggregateResult {
  companyCodeMax: String
  companyCodeMin: String
  contactEmailMax: String
  contactEmailMin: String
  contactNameMax: String
  contactNameMin: String
  contactPhoneMax: String
  contactPhoneMin: String
  count: Int
  nameMax: String
  nameMin: String
  registrationNumberMax: String
  registrationNumberMin: String
  vatNumberMax: String
  vatNumberMin: String
}

input PartnerFilter {
  and: [PartnerFilter]
  companyCode: StringHashFilter
  has: [PartnerHasFilter]
  id: [ID!]
  isActive: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  name: StringHashFilter
  not: PartnerFilter
  or: [PartnerFilter]
}

enum PartnerHasFilter {
  billingAddress
  carriers
  companyCode
  contactEmail
  contactName
  contactPhone
  fromOrders
  isActive
  isCustomer
  isInventoryOwner
  isMerchant
  isRepairer
  isSupplier
  isTransport
  name
  registrationNumber
  shippingAccounts
  shippingAddress
  toOrders
  vatNumber
}

input PartnerOrder {
  asc: PartnerOrderable
  desc: PartnerOrderable
  then: PartnerOrder
}

enum PartnerOrderable {
  companyCode
  contactEmail
  contactName
  contactPhone
  name
  registrationNumber
  vatNumber
}

input PartnerPatch {
  billingAddress: AddressRef
  carriers: [CarrierRef]
  companyCode: String
  contactEmail: String
  contactName: String
  contactPhone: String
  fromOrders: [OrderRef]
  isActive: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  name: String
  registrationNumber: String
  shippingAccounts: [ShippingAccountRef]
  shippingAddress: AddressRef
  toOrders: [OrderRef]
  vatNumber: String
}

input PartnerRef {
  billingAddress: AddressRef
  carriers: [CarrierRef]
  companyCode: String
  contactEmail: String
  contactName: String
  contactPhone: String
  fromOrders: [OrderRef]
  id: ID
  isActive: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  name: String
  registrationNumber: String
  shippingAccounts: [ShippingAccountRef]
  shippingAddress: AddressRef
  toOrders: [OrderRef]
  vatNumber: String
}

type PayloadFieldDefinition {
  expression: String!
  fieldType: PayloadFieldType
  id: ID!
  isActive: Boolean
  name: String!
}

type PayloadFieldDefinitionAggregateResult {
  count: Int
  expressionMax: String
  expressionMin: String
  nameMax: String
  nameMin: String
}

input PayloadFieldDefinitionFilter {
  and: [PayloadFieldDefinitionFilter]
  has: [PayloadFieldDefinitionHasFilter]
  id: [ID!]
  isActive: Boolean
  not: PayloadFieldDefinitionFilter
  or: [PayloadFieldDefinitionFilter]
}

enum PayloadFieldDefinitionHasFilter {
  expression
  fieldType
  isActive
  name
}

input PayloadFieldDefinitionOrder {
  asc: PayloadFieldDefinitionOrderable
  desc: PayloadFieldDefinitionOrderable
  then: PayloadFieldDefinitionOrder
}

enum PayloadFieldDefinitionOrderable {
  expression
  name
}

input PayloadFieldDefinitionPatch {
  expression: String
  fieldType: PayloadFieldType
  isActive: Boolean
  name: String
}

input PayloadFieldDefinitionRef {
  expression: String
  fieldType: PayloadFieldType
  id: ID
  isActive: Boolean
  name: String
}

enum PayloadFieldType {
  Field
  Other
  Tag
}

type Person {
  description: String
  id: ID!
  isActive: Boolean
  memberOf(
    filter: PersonnelClassFilter
    first: Int
    offset: Int
    order: PersonnelClassOrder
  ): [PersonnelClass]
  memberOfAggregate(filter: PersonnelClassFilter): PersonnelClassAggregateResult
  name: String!
  personnelActual(
    filter: PersonnelActualFilter
    first: Int
    offset: Int
    order: PersonnelActualOrder
  ): [PersonnelActual]
  personnelActualAggregate(
    filter: PersonnelActualFilter
  ): PersonnelActualAggregateResult
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
}

type PersonAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  nameMax: String
  nameMin: String
}

input PersonFilter {
  and: [PersonFilter]
  has: [PersonHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: PersonFilter
  or: [PersonFilter]
}

enum PersonHasFilter {
  description
  isActive
  memberOf
  name
  personnelActual
  properties
}

type PersonnelActual {
  id: ID!
  isActive: Boolean
  jobResponse(filter: JobResponseFilter): JobResponse!
  person(filter: PersonFilter): Person
  quantity: Float
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type PersonnelActualAggregateResult {
  count: Int
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input PersonnelActualFilter {
  and: [PersonnelActualFilter]
  has: [PersonnelActualHasFilter]
  id: [ID!]
  isActive: Boolean
  not: PersonnelActualFilter
  or: [PersonnelActualFilter]
}

enum PersonnelActualHasFilter {
  isActive
  jobResponse
  person
  quantity
  quantityUoM
}

input PersonnelActualOrder {
  asc: PersonnelActualOrderable
  desc: PersonnelActualOrderable
  then: PersonnelActualOrder
}

enum PersonnelActualOrderable {
  quantity
}

input PersonnelActualPatch {
  isActive: Boolean
  jobResponse: JobResponseRef
  person: PersonRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

input PersonnelActualRef {
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  person: PersonRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

# Personnel Class represents a grouping of personnel with similar characteristics
type PersonnelClass {
  description: String
  id: ID!
  isActive: Boolean
  isTestedBy(
    filter: TestSpecificationFilter
    first: Int
    offset: Int
    order: TestSpecificationOrder
  ): [TestSpecification]
  isTestedByAggregate(
    filter: TestSpecificationFilter
  ): TestSpecificationAggregateResult
  name: String!
  persons(
    filter: PersonFilter
    first: Int
    offset: Int
    order: PersonOrder
  ): [Person]
  personsAggregate(filter: PersonFilter): PersonAggregateResult
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
}

type PersonnelClassAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  nameMax: String
  nameMin: String
}

input PersonnelClassFilter {
  and: [PersonnelClassFilter]
  has: [PersonnelClassHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: PersonnelClassFilter
  or: [PersonnelClassFilter]
}

enum PersonnelClassHasFilter {
  description
  isActive
  isTestedBy
  name
  persons
  properties
}

input PersonnelClassOrder {
  asc: PersonnelClassOrderable
  desc: PersonnelClassOrderable
  then: PersonnelClassOrder
}

enum PersonnelClassOrderable {
  description
  name
}

input PersonnelClassPatch {
  description: String
  isActive: Boolean
  isTestedBy: [TestSpecificationRef]
  persons: [PersonRef]
  properties: [PropertyRef]
}

input PersonnelClassRef {
  description: String
  id: ID
  isActive: Boolean
  isTestedBy: [TestSpecificationRef]
  name: String
  persons: [PersonRef]
  properties: [PropertyRef]
}

type PersonnelSpecification {
  description: String
  id: ID!
  isActive: Boolean
  jobOrder(filter: JobOrderFilter): JobOrder
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment
  person(filter: PersonFilter): Person
  personnelClass(filter: PersonnelClassFilter): PersonnelClass
  personnelUse: String
  quantity: Float
  uom(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type PersonnelSpecificationAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  personnelUseMax: String
  personnelUseMin: String
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input PersonnelSpecificationFilter {
  and: [PersonnelSpecificationFilter]
  has: [PersonnelSpecificationHasFilter]
  id: [ID!]
  isActive: Boolean
  not: PersonnelSpecificationFilter
  or: [PersonnelSpecificationFilter]
}

enum PersonnelSpecificationHasFilter {
  description
  isActive
  jobOrder
  operationsSegment
  person
  personnelClass
  personnelUse
  quantity
  uom
}

input PersonnelSpecificationOrder {
  asc: PersonnelSpecificationOrderable
  desc: PersonnelSpecificationOrderable
  then: PersonnelSpecificationOrder
}

enum PersonnelSpecificationOrderable {
  description
  personnelUse
  quantity
}

input PersonnelSpecificationPatch {
  description: String
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  person: PersonRef
  personnelClass: PersonnelClassRef
  personnelUse: String
  quantity: Float
  uom: UnitOfMeasureRef
}

input PersonnelSpecificationRef {
  description: String
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  person: PersonRef
  personnelClass: PersonnelClassRef
  personnelUse: String
  quantity: Float
  uom: UnitOfMeasureRef
}

input PersonOrder {
  asc: PersonOrderable
  desc: PersonOrderable
  then: PersonOrder
}

enum PersonOrderable {
  description
  name
}

input PersonPatch {
  description: String
  isActive: Boolean
  memberOf: [PersonnelClassRef]
  personnelActual: [PersonnelActualRef]
  properties: [PropertyRef]
}

input PersonRef {
  description: String
  id: ID
  isActive: Boolean
  memberOf: [PersonnelClassRef]
  name: String
  personnelActual: [PersonnelActualRef]
  properties: [PropertyRef]
}

input PlanningSummaryFilter {
  equipmentName: String!
  materialCode: String
}

type Point {
  latitude: Float!
  longitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  latitude: Float!
  longitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  contains: ContainsFilter
  intersects: IntersectsFilter
  near: NearFilter
  within: WithinFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

type Property {
  address: String
  dataType: DataType
  definedBy(filter: PropertyFilter): Property
  description: String!
  equipment(filter: EquipmentFilter): Equipment
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass
  eventPayloads(
    filter: EventDefinitionFilter
    first: Int
    offset: Int
    order: EventDefinitionOrder
  ): [EventDefinition]
  eventPayloadsAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
  eventTriggers(
    filter: EventDefinitionFilter
    first: Int
    offset: Int
    order: EventDefinitionOrder
  ): [EventDefinition]
  eventTriggersAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
  expression: String
  id: ID!
  isActive: Boolean
  isTestedBy(
    filter: TestSpecificationFilter
    first: Int
    offset: Int
    order: TestSpecificationOrder
  ): [TestSpecification]
  isTestedByAggregate(
    filter: TestSpecificationFilter
  ): TestSpecificationAggregateResult
  jobOrder(filter: JobOrderFilter): JobOrder
  jobResponse(filter: JobResponseFilter): JobResponse
  materialClass(filter: MaterialClassFilter): MaterialClass
  name: String!
  operationsRequest(filter: OperationsRequestFilter): OperationsRequest
  parameterSpecifications(
    filter: ParameterSpecificationFilter
    first: Int
    offset: Int
    order: ParameterSpecificationOrder
  ): [ParameterSpecification]
  parameterSpecificationsAggregate(
    filter: ParameterSpecificationFilter
  ): ParameterSpecificationAggregateResult
  propertyNameAliases(
    filter: PropertyNameAliasFilter
    first: Int
    offset: Int
    order: PropertyNameAliasOrder
  ): [PropertyNameAlias]
  propertyNameAliasesAggregate(
    filter: PropertyNameAliasFilter
  ): PropertyNameAliasAggregateResult
  propertyOverrides(
    filter: EquipmentPropertyOverrideFilter
    first: Int
    offset: Int
    order: EquipmentPropertyOverrideOrder
  ): [EquipmentPropertyOverride]
  propertyOverridesAggregate(
    filter: EquipmentPropertyOverrideFilter
  ): EquipmentPropertyOverrideAggregateResult
  storeHistory: Boolean
  type: PropertyType
  unitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure
  value: String
}

type PropertyAggregateResult {
  addressMax: String
  addressMin: String
  count: Int
  descriptionMax: String
  descriptionMin: String
  expressionMax: String
  expressionMin: String
  nameMax: String
  nameMin: String
  valueMax: String
  valueMin: String
}

input PropertyFilter {
  and: [PropertyFilter]
  description: StringHashFilter
  has: [PropertyHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: PropertyFilter
  or: [PropertyFilter]
  type: PropertyType_hash
}

enum PropertyHasFilter {
  address
  dataType
  definedBy
  description
  equipment
  equipmentClass
  eventPayloads
  eventTriggers
  expression
  isActive
  isTestedBy
  jobOrder
  jobResponse
  materialClass
  name
  operationsRequest
  parameterSpecifications
  propertyNameAliases
  propertyOverrides
  storeHistory
  type
  unitOfMeasure
  value
}

input PropertyListFilter {
  id: [ID!]
}

type PropertyNameAlias {
  alias: String!
  equipment(filter: EquipmentFilter): Equipment!
  id: ID!
  property(filter: PropertyFilter): Property!
  system: String!
}

type PropertyNameAliasAggregateResult {
  aliasMax: String
  aliasMin: String
  count: Int
  systemMax: String
  systemMin: String
}

input PropertyNameAliasFilter {
  alias: StringFullTextFilter_StringHashFilter
  and: [PropertyNameAliasFilter]
  has: [PropertyNameAliasHasFilter]
  id: [ID!]
  not: PropertyNameAliasFilter
  or: [PropertyNameAliasFilter]
  system: StringFullTextFilter_StringHashFilter
}

enum PropertyNameAliasHasFilter {
  alias
  equipment
  property
  system
}

input PropertyNameAliasOrder {
  asc: PropertyNameAliasOrderable
  desc: PropertyNameAliasOrderable
  then: PropertyNameAliasOrder
}

enum PropertyNameAliasOrderable {
  alias
  system
}

input PropertyNameAliasPatch {
  alias: String
  equipment: EquipmentRef
  property: PropertyRef
  system: String
}

input PropertyNameAliasRef {
  alias: String
  equipment: EquipmentRef
  id: ID
  property: PropertyRef
  system: String
}

input PropertyOrder {
  asc: PropertyOrderable
  desc: PropertyOrderable
  then: PropertyOrder
}

enum PropertyOrderable {
  address
  description
  expression
  name
  value
}

input PropertyPatch {
  address: String
  dataType: DataType
  definedBy: PropertyRef
  description: String
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  eventPayloads: [EventDefinitionRef]
  eventTriggers: [EventDefinitionRef]
  expression: String
  isActive: Boolean
  isTestedBy: [TestSpecificationRef]
  jobOrder: JobOrderRef
  jobResponse: JobResponseRef
  materialClass: MaterialClassRef
  name: String
  operationsRequest: OperationsRequestRef
  parameterSpecifications: [ParameterSpecificationRef]
  propertyNameAliases: [PropertyNameAliasRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  storeHistory: Boolean
  type: PropertyType
  unitOfMeasure: UnitOfMeasureRef
  value: String
}

input PropertyRef {
  address: String
  dataType: DataType
  definedBy: PropertyRef
  description: String
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  eventPayloads: [EventDefinitionRef]
  eventTriggers: [EventDefinitionRef]
  expression: String
  id: ID
  isActive: Boolean
  isTestedBy: [TestSpecificationRef]
  jobOrder: JobOrderRef
  jobResponse: JobResponseRef
  materialClass: MaterialClassRef
  name: String
  operationsRequest: OperationsRequestRef
  parameterSpecifications: [ParameterSpecificationRef]
  propertyNameAliases: [PropertyNameAliasRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  storeHistory: Boolean
  type: PropertyType
  unitOfMeasure: UnitOfMeasureRef
  value: String
}

enum PropertyType {
  BOUND
  CALCULATED
  REFERENCED
}

input PropertyType_hash {
  eq: PropertyType
  in: [PropertyType]
}

#  Columnar dataset for time-series property values
type PropertyValue {
  property: Property
  timestamp: DateTime
  value: String
}

type PropertyValueAlias {
  alias: String!
  id: ID!
  property(filter: PropertyFilter): Property!
  system: String!
  value: String!
}

type PropertyValueAliasAggregateResult {
  aliasMax: String
  aliasMin: String
  count: Int
  systemMax: String
  systemMin: String
  valueMax: String
  valueMin: String
}

input PropertyValueAliasFilter {
  alias: StringFullTextFilter
  and: [PropertyValueAliasFilter]
  has: [PropertyValueAliasHasFilter]
  id: [ID!]
  not: PropertyValueAliasFilter
  or: [PropertyValueAliasFilter]
  system: StringFullTextFilter
  value: StringFullTextFilter
}

enum PropertyValueAliasHasFilter {
  alias
  property
  system
  value
}

input PropertyValueAliasOrder {
  asc: PropertyValueAliasOrderable
  desc: PropertyValueAliasOrderable
  then: PropertyValueAliasOrder
}

enum PropertyValueAliasOrderable {
  alias
  system
  value
}

input PropertyValueAliasPatch {
  alias: String
  property: PropertyRef
  system: String
  value: String
}

input PropertyValueAliasRef {
  alias: String
  id: ID
  property: PropertyRef
  system: String
  value: String
}

#  filter the properties and time range to be returned
input PropertyValuesFilter {
  # returns all values between this timestamp and the timestamp specified by to.
  # If not specified, defaules to -24h from the current time
  from: DateTime

  #  provide a list of property ids to return. Works as AND with propertyName filter.
  # if not specified, return all properties for the equipment.
  propertyId: [ID]

  #  filter by the property name. Works as AND with propertyId filter.
  # if not specified, return all properties for the equipment.
  propertyName: StringHashFilter

  # returns all events between this timestamp and the timestamp specified by from.
  # If not specified, this value defaults to the current time
  to: DateTime
}

type QuantityLog {
  comments: String
  equipment(filter: EquipmentFilter): Equipment
  id: ID!
  isActive: Boolean
  jobResponse(filter: JobResponseFilter): JobResponse!
  quantity: Float!
  reasonCode: String
  reasonText: String
  timestamp: DateTime
  type: MaterialUse!
}

type QuantityLogAggregateResult {
  commentsMax: String
  commentsMin: String
  count: Int
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
  reasonCodeMax: String
  reasonCodeMin: String
  reasonTextMax: String
  reasonTextMin: String
  timestampMax: DateTime
  timestampMin: DateTime
}

input QuantityLogFilter {
  and: [QuantityLogFilter]
  comments: StringHashFilter
  has: [QuantityLogHasFilter]
  id: [ID!]
  isActive: Boolean
  not: QuantityLogFilter
  or: [QuantityLogFilter]
  reasonCode: StringHashFilter
  reasonText: StringHashFilter
  timestamp: DateTimeFilter
  type: MaterialUse_hash
}

enum QuantityLogHasFilter {
  comments
  equipment
  isActive
  jobResponse
  quantity
  reasonCode
  reasonText
  timestamp
  type
}

input QuantityLogOrder {
  asc: QuantityLogOrderable
  desc: QuantityLogOrderable
  then: QuantityLogOrder
}

enum QuantityLogOrderable {
  comments
  quantity
  reasonCode
  reasonText
  timestamp
}

input QuantityLogPatch {
  comments: String
  equipment: EquipmentRef
  isActive: Boolean
  jobResponse: JobResponseRef
  quantity: Float
  reasonCode: String
  reasonText: String
  timestamp: DateTime
  type: MaterialUse
}

input QuantityLogRef {
  comments: String
  equipment: EquipmentRef
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  quantity: Float
  reasonCode: String
  reasonText: String
  timestamp: DateTime
  type: MaterialUse
}

type QuantityLogTs {
  comment: String
  equipment: Equipment
  material: MaterialDefinition
  materialUse: MaterialUse
  plannedRunRate: Float
  quantity: Float
  reasonCode: String
  reasonText: String
  timeStamp: DateTime
}

input QuantityLogTsInput {
  comment: String
  equipment: ExtEquipmentRef!
  material: ExtMaterialDefinitionRef
  materialUse: MaterialUse!
  quantity: Float!
  reasonCode: String
  reasonText: String
  timeStamp: DateTime!
}

# a summary of the quantity log
type QuantitySummary {
  # the sum of this type of quantity
  quantitySum: Float
  reasonCode: String
  reasonText: String

  # the type of quantity associated with the result
  type: String
}

# the filter for a quantitySummary query
input QuantitySummaryFilter {
  # returns only the type specified by filterType
  filterType: String

  # groups the quantity logs on their reasons as well as their type if used.
  # valid options are 'reasonText' and 'reasonCode'
  groupBy: String

  # deprecated
  sortBy: String

  # limits the number of results that return
  topN: Int
}

type Query {
  aggregateACL(filter: ACLFilter): ACLAggregateResult
  aggregateAccessRight(filter: AccessRightFilter): AccessRightAggregateResult
  aggregateAddress(filter: AddressFilter): AddressAggregateResult
  aggregateBillOfMaterial(
    filter: BillOfMaterialFilter
  ): BillOfMaterialAggregateResult
  aggregateBox(filter: BoxFilter): BoxAggregateResult
  aggregateCarrier(filter: CarrierFilter): CarrierAggregateResult
  aggregateDashboardConfig(
    filter: DashboardConfigFilter
  ): DashboardConfigAggregateResult
  aggregateDashboardPanelConfig(
    filter: DashboardPanelConfigFilter
  ): DashboardPanelConfigAggregateResult
  aggregateDashboardWidgetConfigProperty(
    filter: DashboardWidgetConfigPropertyFilter
  ): DashboardWidgetConfigPropertyAggregateResult
  aggregateDelivery(filter: DeliveryFilter): DeliveryAggregateResult
  aggregateEquipment(filter: EquipmentFilter): EquipmentAggregateResult
  aggregateEquipmentActual(
    filter: EquipmentActualFilter
  ): EquipmentActualAggregateResult
  aggregateEquipmentClass(
    filter: EquipmentClassFilter
  ): EquipmentClassAggregateResult
  aggregateEquipmentNameAlias(
    filter: EquipmentNameAliasFilter
  ): EquipmentNameAliasAggregateResult
  aggregateEquipmentPropertyOverride(
    filter: EquipmentPropertyOverrideFilter
  ): EquipmentPropertyOverrideAggregateResult
  aggregateEquipmentReasonOverride(
    filter: EquipmentReasonOverrideFilter
  ): EquipmentReasonOverrideAggregateResult
  aggregateEquipmentRelation(
    filter: EquipmentRelationFilter
  ): EquipmentRelationAggregateResult
  aggregateEquipmentSpecification(
    filter: EquipmentSpecificationFilter
  ): EquipmentSpecificationAggregateResult
  aggregateEventDefinition(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
  aggregateEventLog(filter: EventLogFilter): EventLogAggregateResult
  aggregateForm(filter: FormFilter): FormAggregateResult
  aggregateGeneralLedgerAccount(
    filter: GeneralLedgerAccountFilter
  ): GeneralLedgerAccountAggregateResult
  aggregateInterfaceMessageLog(
    filter: InterfaceMessageLogFilter
  ): InterfaceMessageLogAggregateResult
  aggregateInventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
  ): InventoryHandlingPolicyAggregateResult
  aggregateInventoryHandlingRule(
    filter: InventoryHandlingRuleFilter
  ): InventoryHandlingRuleAggregateResult
  aggregateInventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
  ): InventoryHoldingPolicyAggregateResult
  aggregateJobOrder(filter: JobOrderFilter): JobOrderAggregateResult
  aggregateJobOrderDependency(
    filter: JobOrderDependencyFilter
  ): JobOrderDependencyAggregateResult
  aggregateJobOrderDispatchStateModel(
    filter: JobOrderDispatchStateModelFilter
  ): JobOrderDispatchStateModelAggregateResult
  aggregateJobOrderNote(filter: JobOrderNoteFilter): JobOrderNoteAggregateResult
  aggregateJobResponse(filter: JobResponseFilter): JobResponseAggregateResult
  aggregateLibreService(filter: LibreServiceFilter): LibreServiceAggregateResult
  aggregateMaterialActual(
    filter: MaterialActualFilter
  ): MaterialActualAggregateResult
  aggregateMaterialAlternate(
    filter: MaterialAlternateFilter
  ): MaterialAlternateAggregateResult
  aggregateMaterialClass(
    filter: MaterialClassFilter
  ): MaterialClassAggregateResult
  aggregateMaterialDefinition(
    filter: MaterialDefinitionFilter
  ): MaterialDefinitionAggregateResult
  aggregateMaterialEventRuleset(
    filter: MaterialEventRulesetFilter
  ): MaterialEventRulesetAggregateResult
  aggregateMaterialLot(filter: MaterialLotFilter): MaterialLotAggregateResult
  aggregateMaterialSpecification(
    filter: MaterialSpecificationFilter
  ): MaterialSpecificationAggregateResult
  aggregateMaterialStateModel(
    filter: MaterialStateModelFilter
  ): MaterialStateModelAggregateResult
  aggregateMaterialStateTransition(
    filter: MaterialStateTransitionFilter
  ): MaterialStateTransitionAggregateResult
  aggregateMaterialStatus(
    filter: MaterialStatusFilter
  ): MaterialStatusAggregateResult
  aggregateMaterialSubLot(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
  aggregateMaterialUnit(filter: MaterialUnitFilter): MaterialUnitAggregateResult
  aggregateMenu(filter: MenuFilter): MenuAggregateResult
  aggregateOperationsDefinition(
    filter: OperationsDefinitionFilter
  ): OperationsDefinitionAggregateResult
  aggregateOperationsRequest(
    filter: OperationsRequestFilter
  ): OperationsRequestAggregateResult
  aggregateOperationsSegment(
    filter: OperationsSegmentFilter
  ): OperationsSegmentAggregateResult
  aggregateOrder(filter: OrderFilter): OrderAggregateResult
  aggregateOrderLine(filter: OrderLineFilter): OrderLineAggregateResult
  aggregateOrderStartRuleset(
    filter: OrderStartRulesetFilter
  ): OrderStartRulesetAggregateResult
  aggregateParameterSpecification(
    filter: ParameterSpecificationFilter
  ): ParameterSpecificationAggregateResult
  aggregatePartner(filter: PartnerFilter): PartnerAggregateResult
  aggregatePayloadFieldDefinition(
    filter: PayloadFieldDefinitionFilter
  ): PayloadFieldDefinitionAggregateResult
  aggregatePerson(filter: PersonFilter): PersonAggregateResult
  aggregatePersonnelActual(
    filter: PersonnelActualFilter
  ): PersonnelActualAggregateResult
  aggregatePersonnelClass(
    filter: PersonnelClassFilter
  ): PersonnelClassAggregateResult
  aggregatePersonnelSpecification(
    filter: PersonnelSpecificationFilter
  ): PersonnelSpecificationAggregateResult
  aggregateProperty(filter: PropertyFilter): PropertyAggregateResult
  aggregatePropertyNameAlias(
    filter: PropertyNameAliasFilter
  ): PropertyNameAliasAggregateResult
  aggregatePropertyValueAlias(
    filter: PropertyValueAliasFilter
  ): PropertyValueAliasAggregateResult
  aggregateQuantityLog(filter: QuantityLogFilter): QuantityLogAggregateResult
  aggregateReason(filter: ReasonFilter): ReasonAggregateResult
  aggregateReasonCategory(
    filter: ReasonCategoryFilter
  ): ReasonCategoryAggregateResult
  aggregateRequestState(filter: RequestStateFilter): RequestStateAggregateResult
  aggregateRole(filter: RoleFilter): RoleAggregateResult
  aggregateSegmentDependency(
    filter: SegmentDependencyFilter
  ): SegmentDependencyAggregateResult
  aggregateSegmentInvoiceSetting(
    filter: SegmentInvoiceSettingFilter
  ): SegmentInvoiceSettingAggregateResult
  aggregateShipment(filter: ShipmentFilter): ShipmentAggregateResult
  aggregateShipmentItem(filter: ShipmentItemFilter): ShipmentItemAggregateResult
  aggregateShippingAccount(
    filter: ShippingAccountFilter
  ): ShippingAccountAggregateResult
  aggregateStateEventRuleset(
    filter: StateEventRulesetFilter
  ): StateEventRulesetAggregateResult
  aggregateTestResult(filter: TestResultFilter): TestResultAggregateResult
  aggregateTestSpecification(
    filter: TestSpecificationFilter
  ): TestSpecificationAggregateResult
  aggregateTransitionEventRuleset(
    filter: TransitionEventRulesetFilter
  ): TransitionEventRulesetAggregateResult
  aggregateUnitOfMeasure(
    filter: UnitOfMeasureFilter
  ): UnitOfMeasureAggregateResult
  aggregateUnitOfMeasureConversion(
    filter: UnitOfMeasureConversionFilter
  ): UnitOfMeasureConversionAggregateResult
  aggregateUser(filter: UserFilter): UserAggregateResult
  aggregateUserRole(filter: UserRoleFilter): UserRoleAggregateResult
  aggregateWorkCalendar(filter: WorkCalendarFilter): WorkCalendarAggregateResult
  aggregateWorkCalendarDefinitionEntry(
    filter: WorkCalendarDefinitionEntryFilter
  ): WorkCalendarDefinitionEntryAggregateResult
  aggregateWorkCalendarEntry(
    filter: WorkCalendarEntryFilter
  ): WorkCalendarEntryAggregateResult
  aggregateWorkflowConnection(
    filter: WorkflowConnectionFilter
  ): WorkflowConnectionAggregateResult
  aggregateWorkflowConnectionType(
    filter: WorkflowConnectionTypeFilter
  ): WorkflowConnectionTypeAggregateResult
  aggregateWorkflowInstance(
    filter: WorkflowInstanceFilter
  ): WorkflowInstanceAggregateResult
  aggregateWorkflowInstanceProperty(
    filter: WorkflowInstancePropertyFilter
  ): WorkflowInstancePropertyAggregateResult
  aggregateWorkflowNode(filter: WorkflowNodeFilter): WorkflowNodeAggregateResult
  aggregateWorkflowNodeEvent(
    filter: WorkflowNodeEventFilter
  ): WorkflowNodeEventAggregateResult
  aggregateWorkflowNodeInstance(
    filter: WorkflowNodeInstanceFilter
  ): WorkflowNodeInstanceAggregateResult
  aggregateWorkflowNodeType(
    filter: WorkflowNodeTypeFilter
  ): WorkflowNodeTypeAggregateResult
  aggregateWorkflowProperty(
    filter: WorkflowPropertyFilter
  ): WorkflowPropertyAggregateResult
  aggregateWorkflowPropertyInstance(
    filter: WorkflowPropertyInstanceFilter
  ): WorkflowPropertyInstanceAggregateResult
  aggregateWorkflowPropertyValue(
    filter: WorkflowPropertyValueFilter
  ): WorkflowPropertyValueAggregateResult
  aggregateWorkflowSpecification(
    filter: WorkflowSpecificationFilter
  ): WorkflowSpecificationAggregateResult
  getACL(id: ID!): ACL
  getAccessRight(id: ID!): AccessRight
  getAddress(id: ID!): Address
  getAllEventsInTimeRange(filter: AllEventsInTimeRangeFilter!): [EventsByField]
  getBillOfMaterial(id: ID, name: String): BillOfMaterial
  getBox(id: ID!): Box
  getCarrier(code: String, id: ID): Carrier
  getDashboardConfig(id: ID, name: String): DashboardConfig
  getDashboardPanelConfig(id: ID!): DashboardPanelConfig
  getDashboardWidgetConfigProperty(id: ID!): DashboardWidgetConfigProperty
  getDelivery(id: ID!): Delivery
  getDeliveryOrder(
    delivery: ExtDeliveryRef!
    shippingAccountData: ShippingAccountData!
  ): TransportCompanyDeliveryOrder
  getEquipment(id: ID!): Equipment
  getEquipmentActual(id: ID!): EquipmentActual
  getEquipmentClass(id: ID!): EquipmentClass
  getEquipmentNameAlias(id: ID!): EquipmentNameAlias
  getEquipmentPropertyOverride(id: ID!): EquipmentPropertyOverride
  getEquipmentReasonOverride(id: ID!): EquipmentReasonOverride
  getEquipmentRelation(id: ID!): EquipmentRelation
  getEquipmentSpecification(id: ID!): EquipmentSpecification
  getEventDefinition(id: ID!): EventDefinition
  getEventLog(id: ID!): EventLog
  getForm(id: ID, name: String): Form
  getGeneralLedgerAccount(code: String, id: ID): GeneralLedgerAccount
  getInterfaceMessageLog(id: ID!): InterfaceMessageLog
  getInventoryHandlingPolicy(id: ID, name: String): InventoryHandlingPolicy
  getInventoryHandlingRule(id: ID!): InventoryHandlingRule
  getInventoryHoldingPolicy(id: ID!): InventoryHoldingPolicy
  getInventoryTransactionsRaw(
    filter: InventoryTransactionsRawFilter
  ): [InventoryTransaction]
  getJobOrder(id: ID, name: String): JobOrder
  getJobOrderDependency(id: ID!): JobOrderDependency
  getJobOrderNote(id: ID!): JobOrderNote
  getJobResponse(id: ID!): JobResponse
  getLibreService(id: ID, name: String): LibreService
  getMaterialActual(id: ID!): MaterialActual
  getMaterialAlternate(id: ID!): MaterialAlternate
  getMaterialClass(code: String, id: ID): MaterialClass
  getMaterialDefinition(code: String, id: ID): MaterialDefinition
  getMaterialEventRuleset(id: ID!): MaterialEventRuleset
  getMaterialLot(code: String, id: ID): MaterialLot
  getMaterialSpecification(id: ID!): MaterialSpecification
  getMaterialStateModel(id: ID, name: String): MaterialStateModel
  getMaterialStateTransition(id: ID!): MaterialStateTransition
  getMaterialStatus(code: String, id: ID): MaterialStatus
  getMaterialSubLot(code: String, id: ID): MaterialSubLot
  getMaterialUnit(id: ID, serialNumber: String): MaterialUnit
  getMenu(id: ID!): Menu
  getOperationsDefinition(id: ID, name: String): OperationsDefinition
  getOperationsRequest(code: String, id: ID): OperationsRequest
  getOperationsSegment(id: ID!): OperationsSegment
  getOrder(id: ID!): Order
  getOrderLine(id: ID!): OrderLine
  getOrderStartRuleset(id: ID!): OrderStartRuleset
  getPackingReturnInstructionsPDF(
    input: GetPackingReturnInstructionsPDFInput!
  ): String
  getPackingSlipPDF: String
  getParameterSpecification(id: ID!): ParameterSpecification
  getPartner(id: ID!): Partner
  getPayloadFieldDefinition(id: ID!): PayloadFieldDefinition
  getPerson(id: ID, name: String): Person
  getPersonnelActual(id: ID!): PersonnelActual
  getPersonnelClass(id: ID, name: String): PersonnelClass
  getPersonnelSpecification(id: ID!): PersonnelSpecification
  getProperty(id: ID!): Property
  getPropertyNameAlias(id: ID!): PropertyNameAlias
  getPropertyValueAlias(id: ID!): PropertyValueAlias
  getQuantityLog(id: ID!): QuantityLog
  getReason(id: ID!): Reason
  getReasonCategory(code: String, id: ID): ReasonCategory
  getRequestState(id: ID, name: String): RequestState
  getRole(name: String!): Role
  getSegmentDependency(id: ID!): SegmentDependency
  getSegmentInvoiceSetting(id: ID!): SegmentInvoiceSetting
  getShipment(id: ID!): Shipment
  getShipmentItem(id: ID!): ShipmentItem
  getShippingAccount(id: ID!): ShippingAccount
  getStateEventRuleset(id: ID!): StateEventRuleset
  getStockOnHand(filter: StockOnHandFilter): [InventoryTransaction]
  getTestResult(id: ID!): TestResult
  getTestSpecification(id: ID!): TestSpecification
  getTransitionEventRuleset(id: ID!): TransitionEventRuleset
  getUnitOfMeasure(code: String, id: ID): UnitOfMeasure
  getUnitOfMeasureConversion(id: ID!): UnitOfMeasureConversion
  getUser(id: ID, username: String): User
  getUserRole(id: ID!): UserRole
  getWorkCalendar(id: ID, name: String): WorkCalendar
  getWorkCalendarDefinitionEntry(id: ID!): WorkCalendarDefinitionEntry
  getWorkCalendarEntry(id: ID!): WorkCalendarEntry
  getWorkflowConnection(id: ID!): WorkflowConnection
  getWorkflowConnectionType(id: ID!): WorkflowConnectionType
  getWorkflowInstance(id: ID!): WorkflowInstance
  getWorkflowInstanceProperty(id: ID, key: String): WorkflowInstanceProperty
  getWorkflowNode(id: ID!): WorkflowNode
  getWorkflowNodeEvent(id: ID!): WorkflowNodeEvent
  getWorkflowNodeInstance(id: ID!): WorkflowNodeInstance
  getWorkflowNodeType(id: ID!): WorkflowNodeType
  getWorkflowProperty(id: ID!): WorkflowProperty
  getWorkflowPropertyInstance(id: ID!): WorkflowPropertyInstance
  getWorkflowPropertyValue(id: ID!): WorkflowPropertyValue
  getWorkflowSpecification(id: ID!): WorkflowSpecification
  queryACL(filter: ACLFilter, first: Int, offset: Int): [ACL]
  queryAccessRight(
    filter: AccessRightFilter
    first: Int
    offset: Int
  ): [AccessRight]
  queryAddress(
    filter: AddressFilter
    first: Int
    offset: Int
    order: AddressOrder
  ): [Address]
  queryBillOfMaterial(
    filter: BillOfMaterialFilter
    first: Int
    offset: Int
    order: BillOfMaterialOrder
  ): [BillOfMaterial]
  queryBox(filter: BoxFilter, first: Int, offset: Int, order: BoxOrder): [Box]
  queryCarrier(
    filter: CarrierFilter
    first: Int
    offset: Int
    order: CarrierOrder
  ): [Carrier]
  queryDashboardConfig(
    filter: DashboardConfigFilter
    first: Int
    offset: Int
    order: DashboardConfigOrder
  ): [DashboardConfig]
  queryDashboardPanelConfig(
    filter: DashboardPanelConfigFilter
    first: Int
    offset: Int
    order: DashboardPanelConfigOrder
  ): [DashboardPanelConfig]
  queryDashboardWidgetConfigProperty(
    filter: DashboardWidgetConfigPropertyFilter
    first: Int
    offset: Int
    order: DashboardWidgetConfigPropertyOrder
  ): [DashboardWidgetConfigProperty]
  queryDelivery(
    filter: DeliveryFilter
    first: Int
    offset: Int
    order: DeliveryOrder
  ): [Delivery]
  queryEquipment(
    filter: EquipmentFilter
    first: Int
    offset: Int
    order: EquipmentOrder
  ): [Equipment]
  queryEquipmentActual(
    filter: EquipmentActualFilter
    first: Int
    offset: Int
    order: EquipmentActualOrder
  ): [EquipmentActual]
  queryEquipmentClass(
    filter: EquipmentClassFilter
    first: Int
    offset: Int
    order: EquipmentClassOrder
  ): [EquipmentClass]
  queryEquipmentNameAlias(
    filter: EquipmentNameAliasFilter
    first: Int
    offset: Int
    order: EquipmentNameAliasOrder
  ): [EquipmentNameAlias]
  queryEquipmentPropertyOverride(
    filter: EquipmentPropertyOverrideFilter
    first: Int
    offset: Int
    order: EquipmentPropertyOverrideOrder
  ): [EquipmentPropertyOverride]
  queryEquipmentReasonOverride(
    filter: EquipmentReasonOverrideFilter
    first: Int
    offset: Int
    order: EquipmentReasonOverrideOrder
  ): [EquipmentReasonOverride]
  queryEquipmentRelation(
    filter: EquipmentRelationFilter
    first: Int
    offset: Int
  ): [EquipmentRelation]
  queryEquipmentSpecification(
    filter: EquipmentSpecificationFilter
    first: Int
    offset: Int
    order: EquipmentSpecificationOrder
  ): [EquipmentSpecification]
  queryEventDefinition(
    filter: EventDefinitionFilter
    first: Int
    offset: Int
    order: EventDefinitionOrder
  ): [EventDefinition]
  queryEventLog(
    filter: EventLogFilter
    first: Int
    offset: Int
    order: EventLogOrder
  ): [EventLog]
  queryForm(
    filter: FormFilter
    first: Int
    offset: Int
    order: FormOrder
  ): [Form]
  queryGeneralLedgerAccount(
    filter: GeneralLedgerAccountFilter
    first: Int
    offset: Int
    order: GeneralLedgerAccountOrder
  ): [GeneralLedgerAccount]
  queryInterfaceMessageLog(
    filter: InterfaceMessageLogFilter
    first: Int
    offset: Int
    order: InterfaceMessageLogOrder
  ): [InterfaceMessageLog]
  queryInventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
    first: Int
    offset: Int
    order: InventoryHandlingPolicyOrder
  ): [InventoryHandlingPolicy]
  queryInventoryHandlingRule(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  queryInventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    first: Int
    offset: Int
    order: InventoryHoldingPolicyOrder
  ): [InventoryHoldingPolicy]
  queryJobOrder(
    filter: JobOrderFilter
    first: Int
    offset: Int
    order: JobOrderOrder
  ): [JobOrder]
  queryJobOrderDependency(
    filter: JobOrderDependencyFilter
    first: Int
    offset: Int
    order: JobOrderDependencyOrder
  ): [JobOrderDependency]
  queryJobOrderDispatchStateModel(
    filter: JobOrderDispatchStateModelFilter
    first: Int
    offset: Int
  ): [JobOrderDispatchStateModel]
  queryJobOrderNote(
    filter: JobOrderNoteFilter
    first: Int
    offset: Int
    order: JobOrderNoteOrder
  ): [JobOrderNote]
  queryJobResponse(
    filter: JobResponseFilter
    first: Int
    offset: Int
    order: JobResponseOrder
  ): [JobResponse]
  queryLibreService(
    filter: LibreServiceFilter
    first: Int
    offset: Int
    order: LibreServiceOrder
  ): [LibreService]
  queryMaterialActual(
    filter: MaterialActualFilter
    first: Int
    offset: Int
    order: MaterialActualOrder
  ): [MaterialActual]
  queryMaterialAlternate(
    filter: MaterialAlternateFilter
    first: Int
    offset: Int
    order: MaterialAlternateOrder
  ): [MaterialAlternate]
  queryMaterialClass(
    filter: MaterialClassFilter
    first: Int
    offset: Int
    order: MaterialClassOrder
  ): [MaterialClass]
  queryMaterialDefinition(
    filter: MaterialDefinitionFilter
    first: Int
    offset: Int
    order: MaterialDefinitionOrder
  ): [MaterialDefinition]
  queryMaterialEquipment(filter: MaterialEquipmentFilter): [MaterialEquipment]
  queryMaterialEventRuleset(
    filter: MaterialEventRulesetFilter
    first: Int
    offset: Int
    order: MaterialEventRulesetOrder
  ): [MaterialEventRuleset]
  queryMaterialLot(
    filter: MaterialLotFilter
    first: Int
    offset: Int
    order: MaterialLotOrder
  ): [MaterialLot]
  queryMaterialSpecification(
    filter: MaterialSpecificationFilter
    first: Int
    offset: Int
    order: MaterialSpecificationOrder
  ): [MaterialSpecification]
  queryMaterialStateModel(
    filter: MaterialStateModelFilter
    first: Int
    offset: Int
    order: MaterialStateModelOrder
  ): [MaterialStateModel]
  queryMaterialStateTransition(
    filter: MaterialStateTransitionFilter
    first: Int
    offset: Int
  ): [MaterialStateTransition]
  queryMaterialStatus(
    filter: MaterialStatusFilter
    first: Int
    offset: Int
    order: MaterialStatusOrder
  ): [MaterialStatus]
  queryMaterialSubLot(
    filter: MaterialSubLotFilter
    first: Int
    offset: Int
    order: MaterialSubLotOrder
  ): [MaterialSubLot]
  queryMaterialUnit(
    filter: MaterialUnitFilter
    first: Int
    offset: Int
    order: MaterialUnitOrder
  ): [MaterialUnit]
  queryMenu(
    filter: MenuFilter
    first: Int
    offset: Int
    order: MenuOrder
  ): [Menu]
  queryOperationsDefinition(
    filter: OperationsDefinitionFilter
    first: Int
    offset: Int
    order: OperationsDefinitionOrder
  ): [OperationsDefinition]
  queryOperationsRequest(
    filter: OperationsRequestFilter
    first: Int
    offset: Int
    order: OperationsRequestOrder
  ): [OperationsRequest]
  queryOperationsSegment(
    filter: OperationsSegmentFilter
    first: Int
    offset: Int
    order: OperationsSegmentOrder
  ): [OperationsSegment]
  queryOrder(
    filter: OrderFilter
    first: Int
    offset: Int
    order: OrderOrder
  ): [Order]
  queryOrderLine(
    filter: OrderLineFilter
    first: Int
    offset: Int
    order: OrderLineOrder
  ): [OrderLine]
  queryOrderStartRuleset(
    filter: OrderStartRulesetFilter
    first: Int
    offset: Int
    order: OrderStartRulesetOrder
  ): [OrderStartRuleset]
  queryParameterSpecification(
    filter: ParameterSpecificationFilter
    first: Int
    offset: Int
    order: ParameterSpecificationOrder
  ): [ParameterSpecification]
  queryPartner(
    filter: PartnerFilter
    first: Int
    offset: Int
    order: PartnerOrder
  ): [Partner]
  queryPayloadFieldDefinition(
    filter: PayloadFieldDefinitionFilter
    first: Int
    offset: Int
    order: PayloadFieldDefinitionOrder
  ): [PayloadFieldDefinition]
  queryPerson(
    filter: PersonFilter
    first: Int
    offset: Int
    order: PersonOrder
  ): [Person]
  queryPersonnelActual(
    filter: PersonnelActualFilter
    first: Int
    offset: Int
    order: PersonnelActualOrder
  ): [PersonnelActual]
  queryPersonnelClass(
    filter: PersonnelClassFilter
    first: Int
    offset: Int
    order: PersonnelClassOrder
  ): [PersonnelClass]
  queryPersonnelSpecification(
    filter: PersonnelSpecificationFilter
    first: Int
    offset: Int
    order: PersonnelSpecificationOrder
  ): [PersonnelSpecification]
  queryPlanningSummaryByStateByEquipment(
    filter: PlanningSummaryFilter!
  ): [[MaterialEquipmentState]]
  queryProperty(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  queryPropertyNameAlias(
    filter: PropertyNameAliasFilter
    first: Int
    offset: Int
    order: PropertyNameAliasOrder
  ): [PropertyNameAlias]
  queryPropertyValueAlias(
    filter: PropertyValueAliasFilter
    first: Int
    offset: Int
    order: PropertyValueAliasOrder
  ): [PropertyValueAlias]
  queryQuantityLog(
    filter: QuantityLogFilter
    first: Int
    offset: Int
    order: QuantityLogOrder
  ): [QuantityLog]
  queryReason(
    filter: ReasonFilter
    first: Int
    offset: Int
    order: ReasonOrder
  ): [Reason]
  queryReasonCategory(
    filter: ReasonCategoryFilter
    first: Int
    offset: Int
    order: ReasonCategoryOrder
  ): [ReasonCategory]
  queryRequestState(
    filter: RequestStateFilter
    first: Int
    offset: Int
    order: RequestStateOrder
  ): [RequestState]
  queryRole(
    filter: RoleFilter
    first: Int
    offset: Int
    order: RoleOrder
  ): [Role]
  querySegmentDependency(
    filter: SegmentDependencyFilter
    first: Int
    offset: Int
    order: SegmentDependencyOrder
  ): [SegmentDependency]
  querySegmentInvoiceSetting(
    filter: SegmentInvoiceSettingFilter
    first: Int
    offset: Int
    order: SegmentInvoiceSettingOrder
  ): [SegmentInvoiceSetting]
  queryShipment(
    filter: ShipmentFilter
    first: Int
    offset: Int
    order: ShipmentOrder
  ): [Shipment]
  queryShipmentItem(
    filter: ShipmentItemFilter
    first: Int
    offset: Int
    order: ShipmentItemOrder
  ): [ShipmentItem]
  queryShippingAccount(
    filter: ShippingAccountFilter
    first: Int
    offset: Int
    order: ShippingAccountOrder
  ): [ShippingAccount]
  queryStateEventRuleset(
    filter: StateEventRulesetFilter
    first: Int
    offset: Int
    order: StateEventRulesetOrder
  ): [StateEventRuleset]
  queryTestResult(
    filter: TestResultFilter
    first: Int
    offset: Int
    order: TestResultOrder
  ): [TestResult]
  queryTestSpecification(
    filter: TestSpecificationFilter
    first: Int
    offset: Int
    order: TestSpecificationOrder
  ): [TestSpecification]
  queryTransitionEventRuleset(
    filter: TransitionEventRulesetFilter
    first: Int
    offset: Int
    order: TransitionEventRulesetOrder
  ): [TransitionEventRuleset]
  queryUnitOfMeasure(
    filter: UnitOfMeasureFilter
    first: Int
    offset: Int
    order: UnitOfMeasureOrder
  ): [UnitOfMeasure]
  queryUnitOfMeasureConversion(
    filter: UnitOfMeasureConversionFilter
    first: Int
    offset: Int
    order: UnitOfMeasureConversionOrder
  ): [UnitOfMeasureConversion]
  queryUser(
    filter: UserFilter
    first: Int
    offset: Int
    order: UserOrder
  ): [User]
  queryUserRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
  queryWorkCalendar(
    filter: WorkCalendarFilter
    first: Int
    offset: Int
    order: WorkCalendarOrder
  ): [WorkCalendar]
  queryWorkCalendarDefinitionEntry(
    filter: WorkCalendarDefinitionEntryFilter
    first: Int
    offset: Int
    order: WorkCalendarDefinitionEntryOrder
  ): [WorkCalendarDefinitionEntry]
  queryWorkCalendarEntry(
    filter: WorkCalendarEntryFilter
    first: Int
    offset: Int
    order: WorkCalendarEntryOrder
  ): [WorkCalendarEntry]
  queryWorkflowConnection(
    filter: WorkflowConnectionFilter
    first: Int
    offset: Int
    order: WorkflowConnectionOrder
  ): [WorkflowConnection]
  queryWorkflowConnectionType(
    filter: WorkflowConnectionTypeFilter
    first: Int
    offset: Int
    order: WorkflowConnectionTypeOrder
  ): [WorkflowConnectionType]
  queryWorkflowInstance(
    filter: WorkflowInstanceFilter
    first: Int
    offset: Int
    order: WorkflowInstanceOrder
  ): [WorkflowInstance]
  queryWorkflowInstanceProperty(
    filter: WorkflowInstancePropertyFilter
    first: Int
    offset: Int
    order: WorkflowInstancePropertyOrder
  ): [WorkflowInstanceProperty]
  queryWorkflowNode(
    filter: WorkflowNodeFilter
    first: Int
    offset: Int
    order: WorkflowNodeOrder
  ): [WorkflowNode]
  queryWorkflowNodeEvent(
    filter: WorkflowNodeEventFilter
    first: Int
    offset: Int
    order: WorkflowNodeEventOrder
  ): [WorkflowNodeEvent]
  queryWorkflowNodeInstance(
    filter: WorkflowNodeInstanceFilter
    first: Int
    offset: Int
    order: WorkflowNodeInstanceOrder
  ): [WorkflowNodeInstance]
  queryWorkflowNodeType(
    filter: WorkflowNodeTypeFilter
    first: Int
    offset: Int
    order: WorkflowNodeTypeOrder
  ): [WorkflowNodeType]
  queryWorkflowProperty(
    filter: WorkflowPropertyFilter
    first: Int
    offset: Int
    order: WorkflowPropertyOrder
  ): [WorkflowProperty]
  queryWorkflowPropertyInstance(
    filter: WorkflowPropertyInstanceFilter
    first: Int
    offset: Int
    order: WorkflowPropertyInstanceOrder
  ): [WorkflowPropertyInstance]
  queryWorkflowPropertyValue(
    filter: WorkflowPropertyValueFilter
    first: Int
    offset: Int
    order: WorkflowPropertyValueOrder
  ): [WorkflowPropertyValue]
  queryWorkflowSpecification(
    filter: WorkflowSpecificationFilter
    first: Int
    offset: Int
    order: WorkflowSpecificationOrder
  ): [WorkflowSpecification]
  validateASN(input: ValidateASNInput!): [ASNStaging]
}

type RawKpi {
  actualProductionTimeSeconds: Int
  quantities: [QuantityLogTs]
}

type Reason {
  category(filter: ReasonCategoryFilter): ReasonCategory
  children(
    filter: ReasonFilter
    first: Int
    offset: Int
    order: ReasonOrder
  ): [Reason]
  childrenAggregate(filter: ReasonFilter): ReasonAggregateResult
  class: ReasonClass!
  equipment(filter: EquipmentFilter): Equipment
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass
  equipmentOverrides(
    filter: EquipmentReasonOverrideFilter
    first: Int
    offset: Int
    order: EquipmentReasonOverrideOrder
  ): [EquipmentReasonOverride]
  equipmentOverridesAggregate(
    filter: EquipmentReasonOverrideFilter
  ): EquipmentReasonOverrideAggregateResult
  erpCode: String!
  id: ID!
  isActive: Boolean
  label: String!
  parent(filter: ReasonFilter): Reason
  standardValue: Float
  text: String!
  valueUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type ReasonAggregateResult {
  count: Int
  erpCodeMax: String
  erpCodeMin: String
  labelMax: String
  labelMin: String
  standardValueAvg: Float
  standardValueMax: Float
  standardValueMin: Float
  standardValueSum: Float
  textMax: String
  textMin: String
}

type ReasonCategory {
  code: String!
  id: ID!
  isActive: Boolean
  reason(
    filter: ReasonFilter
    first: Int
    offset: Int
    order: ReasonOrder
  ): [Reason]
  reasonAggregate(filter: ReasonFilter): ReasonAggregateResult
  timeCategory: TimeCategory!
}

type ReasonCategoryAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
}

input ReasonCategoryFilter {
  and: [ReasonCategoryFilter]
  code: StringHashFilter
  has: [ReasonCategoryHasFilter]
  id: [ID!]
  isActive: Boolean
  not: ReasonCategoryFilter
  or: [ReasonCategoryFilter]
}

enum ReasonCategoryHasFilter {
  code
  isActive
  reason
  timeCategory
}

input ReasonCategoryOrder {
  asc: ReasonCategoryOrderable
  desc: ReasonCategoryOrderable
  then: ReasonCategoryOrder
}

enum ReasonCategoryOrderable {
  code
}

input ReasonCategoryPatch {
  isActive: Boolean
  reason: [ReasonRef]
  timeCategory: TimeCategory
}

input ReasonCategoryRef {
  code: String
  id: ID
  isActive: Boolean
  reason: [ReasonRef]
  timeCategory: TimeCategory
}

enum ReasonClass {
  Scrap
  Time
}

input ReasonClass_hash {
  eq: ReasonClass
  in: [ReasonClass]
}

input ReasonFilter {
  and: [ReasonFilter]
  class: ReasonClass_hash
  erpCode: StringHashFilter
  has: [ReasonHasFilter]
  id: [ID!]
  isActive: Boolean
  label: StringHashFilter
  not: ReasonFilter
  or: [ReasonFilter]
  text: StringHashFilter
}

enum ReasonHasFilter {
  category
  children
  class
  equipment
  equipmentClass
  equipmentOverrides
  erpCode
  isActive
  label
  parent
  standardValue
  text
  valueUoM
}

input ReasonOrder {
  asc: ReasonOrderable
  desc: ReasonOrderable
  then: ReasonOrder
}

enum ReasonOrderable {
  erpCode
  label
  standardValue
  text
}

input ReasonPatch {
  category: ReasonCategoryRef
  children: [ReasonRef]
  class: ReasonClass
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  equipmentOverrides: [EquipmentReasonOverrideRef]
  erpCode: String
  isActive: Boolean
  label: String
  parent: ReasonRef
  standardValue: Float
  text: String
  valueUoM: UnitOfMeasureRef
}

input ReasonRef {
  category: ReasonCategoryRef
  children: [ReasonRef]
  class: ReasonClass
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  equipmentOverrides: [EquipmentReasonOverrideRef]
  erpCode: String
  id: ID
  isActive: Boolean
  label: String
  parent: ReasonRef
  standardValue: Float
  text: String
  valueUoM: UnitOfMeasureRef
}

input ReceiveInboundShipmentInput {
  inboundQuantity: Int
  materialCode: String
  max: Int
  min: Int
  orderNumber: String
  plannedQuantity: Int!
  sohQty: Int
  status: String
  warehouse: String
}

input ReplayRawDataInput {
  equipment: [String!]!
  fromDateTIme: String!
}

type RequestState {
  description: String
  id: ID!
  isActive: Boolean
  name: String!
}

type RequestStateAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  nameMax: String
  nameMin: String
}

input RequestStateFilter {
  and: [RequestStateFilter]
  has: [RequestStateHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: RequestStateFilter
  or: [RequestStateFilter]
}

enum RequestStateHasFilter {
  description
  isActive
  name
}

input RequestStateOrder {
  asc: RequestStateOrderable
  desc: RequestStateOrderable
  then: RequestStateOrder
}

enum RequestStateOrderable {
  description
  name
}

input RequestStatePatch {
  description: String
  isActive: Boolean
}

input RequestStateRef {
  description: String
  id: ID
  isActive: Boolean
  name: String
}

type Role {
  hasGrantedRights(
    filter: AccessRightFilter
    first: Int
    offset: Int
  ): [AccessRight]
  hasGrantedRightsAggregate(
    filter: AccessRightFilter
  ): AccessRightAggregateResult
  hasMembers(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
  hasMembersAggregate(filter: UserRoleFilter): UserRoleAggregateResult
  isActive: Boolean
  name: String!
  workflowNodes(
    filter: WorkflowNodeFilter
    first: Int
    offset: Int
    order: WorkflowNodeOrder
  ): [WorkflowNode]
  workflowNodesAggregate(
    filter: WorkflowNodeFilter
  ): WorkflowNodeAggregateResult
}

type RoleAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
}

input RoleFilter {
  and: [RoleFilter]
  has: [RoleHasFilter]
  name: StringHashFilter
  not: RoleFilter
  or: [RoleFilter]
}

enum RoleHasFilter {
  hasGrantedRights
  hasMembers
  isActive
  name
  workflowNodes
}

input RoleOrder {
  asc: RoleOrderable
  desc: RoleOrderable
  then: RoleOrder
}

enum RoleOrderable {
  name
}

input RolePatch {
  hasGrantedRights: [AccessRightRef]
  hasMembers: [UserRoleRef]
  isActive: Boolean
  workflowNodes: [WorkflowNodeRef]
}

input RoleRef {
  hasGrantedRights: [AccessRightRef]
  hasMembers: [UserRoleRef]
  isActive: Boolean
  name: String
  workflowNodes: [WorkflowNodeRef]
}

enum RulesetTriggerOption {
  ORDER_END
  ORDER_START
}

# represents a rate at a timestamp
type RunRate {
  rate: Float
  time: DateTime
}

# the filter required to return the requiredRunRate type
input RunRateFilter {
  # the scheduled finish of the job response
  ScheduledFinish: DateTime

  # the run rate required over the total course of the job response to meet the quantity target
  TargetRunRate: Float
}

# a summary of the run rate log
type RunRateSummary {
  # the average run rate over the course of the job response queried from
  avgRunRate: Float

  # the run rate at the time of query
  currentRunRate: Float

  # the raw run rate log over the course of the job response interpolated to every minute
  interpolatedRunRate: [RunRate]

  # the run rate required to reach the job orders target before the scheduled end time.
  # requires both targetRunRate and scheduledFinish to be passed through the filter
  requiredRunRate: Float
}

type SegmentDependency {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  from(filter: OperationsSegmentFilter): OperationsSegment!
  id: ID!
  isActive: Boolean
  jobOrderDependencies(
    filter: JobOrderDependencyFilter
    first: Int
    offset: Int
    order: JobOrderDependencyOrder
  ): [JobOrderDependency]
  jobOrderDependenciesAggregate(
    filter: JobOrderDependencyFilter
  ): JobOrderDependencyAggregateResult
  to(filter: OperationsSegmentFilter): OperationsSegment!
  transitionEventRuleset(
    filter: TransitionEventRulesetFilter
  ): TransitionEventRuleset
}

type SegmentDependencyAggregateResult {
  conditionMax: String
  conditionMin: String
  count: Int
  dependencyFactorAvg: Float
  dependencyFactorMax: Float
  dependencyFactorMin: Float
  dependencyFactorSum: Float
  descriptionMax: String
  descriptionMin: String
}

input SegmentDependencyFilter {
  and: [SegmentDependencyFilter]
  has: [SegmentDependencyHasFilter]
  id: [ID!]
  isActive: Boolean
  not: SegmentDependencyFilter
  or: [SegmentDependencyFilter]
}

enum SegmentDependencyHasFilter {
  condition
  dependencyFactor
  dependencyType
  description
  factorUoM
  from
  isActive
  jobOrderDependencies
  to
  transitionEventRuleset
}

input SegmentDependencyOrder {
  asc: SegmentDependencyOrderable
  desc: SegmentDependencyOrderable
  then: SegmentDependencyOrder
}

enum SegmentDependencyOrderable {
  condition
  dependencyFactor
  description
}

input SegmentDependencyPatch {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM: UnitOfMeasureRef
  from: OperationsSegmentRef
  isActive: Boolean
  jobOrderDependencies: [JobOrderDependencyRef]
  to: OperationsSegmentRef
  transitionEventRuleset: TransitionEventRulesetRef
}

input SegmentDependencyRef {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM: UnitOfMeasureRef
  from: OperationsSegmentRef
  id: ID
  isActive: Boolean
  jobOrderDependencies: [JobOrderDependencyRef]
  to: OperationsSegmentRef
  transitionEventRuleset: TransitionEventRulesetRef
}

type SegmentInvoiceSetting {
  costPerHour: Float
  costPerUnit: Float
  id: ID!
  partner(filter: PartnerFilter): Partner
}

type SegmentInvoiceSettingAggregateResult {
  costPerHourAvg: Float
  costPerHourMax: Float
  costPerHourMin: Float
  costPerHourSum: Float
  costPerUnitAvg: Float
  costPerUnitMax: Float
  costPerUnitMin: Float
  costPerUnitSum: Float
  count: Int
}

input SegmentInvoiceSettingFilter {
  and: [SegmentInvoiceSettingFilter]
  has: [SegmentInvoiceSettingHasFilter]
  id: [ID!]
  not: SegmentInvoiceSettingFilter
  or: [SegmentInvoiceSettingFilter]
}

enum SegmentInvoiceSettingHasFilter {
  costPerHour
  costPerUnit
  partner
}

input SegmentInvoiceSettingOrder {
  asc: SegmentInvoiceSettingOrderable
  desc: SegmentInvoiceSettingOrderable
  then: SegmentInvoiceSettingOrder
}

enum SegmentInvoiceSettingOrderable {
  costPerHour
  costPerUnit
}

input SegmentInvoiceSettingPatch {
  costPerHour: Float
  costPerUnit: Float
  partner: PartnerRef
}

input SegmentInvoiceSettingRef {
  costPerHour: Float
  costPerUnit: Float
  id: ID
  partner: PartnerRef
}

enum SegmentType {
  EMBED_SUBPROCESS
  SYSTEM_TASK
  USER_TASK
}

# A shipment represents a consignment of goods being sent or received into a warehouse
type Shipment {
  consignmentNumber: String
  customerReference: String
  dateTimeCreatedUTC: DateTime
  dateTimeDeliveredUTC: DateTime
  dateTimePackedUTC: DateTime
  dateTimeReceivedUTC: DateTime
  delivered(filter: DeliveryFilter): Delivery
  emailTrackingEnabled: Boolean
  from(filter: AddressFilter): Address
  id: ID!
  isActive: Boolean
  items(
    filter: ShipmentItemFilter
    first: Int
    offset: Int
    order: ShipmentItemOrder
  ): [ShipmentItem]
  itemsAggregate(filter: ShipmentItemFilter): ShipmentItemAggregateResult
  order(filter: OrderFilter): Order!
  packedItems(filter: PackedItemsFilter): [PackedItem]
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  reference: String
  status: ShipmentStatus
  to(filter: AddressFilter): Address
  transportCompany: TransportCompany
  transportCompanyProductCode: String
  transportCompanyShipmentId: String
  type: ShipmentType!
  warehouse(filter: EquipmentFilter): Equipment!
}

type ShipmentAggregateResult {
  consignmentNumberMax: String
  consignmentNumberMin: String
  count: Int
  customerReferenceMax: String
  customerReferenceMin: String
  dateTimeCreatedUTCMax: DateTime
  dateTimeCreatedUTCMin: DateTime
  dateTimeDeliveredUTCMax: DateTime
  dateTimeDeliveredUTCMin: DateTime
  dateTimePackedUTCMax: DateTime
  dateTimePackedUTCMin: DateTime
  dateTimeReceivedUTCMax: DateTime
  dateTimeReceivedUTCMin: DateTime
  referenceMax: String
  referenceMin: String
  transportCompanyProductCodeMax: String
  transportCompanyProductCodeMin: String
  transportCompanyShipmentIdMax: String
  transportCompanyShipmentIdMin: String
}

input ShipmentFilter {
  and: [ShipmentFilter]
  consignmentNumber: StringFullTextFilter_StringHashFilter
  dateTimeCreatedUTC: DateTimeFilter
  dateTimeDeliveredUTC: DateTimeFilter
  dateTimePackedUTC: DateTimeFilter
  dateTimeReceivedUTC: DateTimeFilter
  has: [ShipmentHasFilter]
  id: [ID!]
  isActive: Boolean
  not: ShipmentFilter
  or: [ShipmentFilter]
  reference: StringHashFilter_StringRegExpFilter
  status: ShipmentStatus_hash
  type: ShipmentType_hash
}

enum ShipmentHasFilter {
  consignmentNumber
  customerReference
  dateTimeCreatedUTC
  dateTimeDeliveredUTC
  dateTimePackedUTC
  dateTimeReceivedUTC
  delivered
  emailTrackingEnabled
  from
  isActive
  items
  order
  properties
  reference
  status
  to
  transportCompany
  transportCompanyProductCode
  transportCompanyShipmentId
  type
  warehouse
}

# A shipment item represents an individual package or line item within the shipment
type ShipmentItem {
  bin(filter: EquipmentFilter): Equipment
  box(filter: BoxFilter): Box
  id: ID!
  isActive: Boolean
  isParcel: Boolean
  material(filter: MaterialDefinitionFilter): MaterialDefinition
  packedItems(filter: PackedItemsFilter): [PackedItem]
  packedQty: Int
  plannedQuantity: Int
  shipment(filter: ShipmentFilter): Shipment
  status: ShipmentItemStatus!
  trackingDetailsArticleId: String
  trackingDetailsBarcodeId: String
  trackingDetailsConsignmentId: String
  transportCompanyItemId: String
  transportCompanyItemReference: String
  weightKg: Float
}

type ShipmentItemAggregateResult {
  count: Int
  plannedQuantityAvg: Float
  plannedQuantityMax: Int
  plannedQuantityMin: Int
  plannedQuantitySum: Int
  trackingDetailsArticleIdMax: String
  trackingDetailsArticleIdMin: String
  trackingDetailsBarcodeIdMax: String
  trackingDetailsBarcodeIdMin: String
  trackingDetailsConsignmentIdMax: String
  trackingDetailsConsignmentIdMin: String
  transportCompanyItemIdMax: String
  transportCompanyItemIdMin: String
  transportCompanyItemReferenceMax: String
  transportCompanyItemReferenceMin: String
  weightKgAvg: Float
  weightKgMax: Float
  weightKgMin: Float
  weightKgSum: Float
}

input ShipmentItemFilter {
  and: [ShipmentItemFilter]
  has: [ShipmentItemHasFilter]
  id: [ID!]
  isActive: Boolean
  isParcel: Boolean
  not: ShipmentItemFilter
  or: [ShipmentItemFilter]
  status: ShipmentItemStatus_hash
}

enum ShipmentItemHasFilter {
  bin
  box
  isActive
  isParcel
  material
  plannedQuantity
  shipment
  status
  trackingDetailsArticleId
  trackingDetailsBarcodeId
  trackingDetailsConsignmentId
  transportCompanyItemId
  transportCompanyItemReference
  weightKg
}

input ShipmentItemOrder {
  asc: ShipmentItemOrderable
  desc: ShipmentItemOrderable
  then: ShipmentItemOrder
}

enum ShipmentItemOrderable {
  plannedQuantity
  trackingDetailsArticleId
  trackingDetailsBarcodeId
  trackingDetailsConsignmentId
  transportCompanyItemId
  transportCompanyItemReference
  weightKg
}

input ShipmentItemPatch {
  bin: EquipmentRef
  box: BoxRef
  isActive: Boolean
  isParcel: Boolean
  material: MaterialDefinitionRef
  plannedQuantity: Int
  shipment: ShipmentRef
  status: ShipmentItemStatus
  trackingDetailsArticleId: String
  trackingDetailsBarcodeId: String
  trackingDetailsConsignmentId: String
  transportCompanyItemId: String
  transportCompanyItemReference: String
  weightKg: Float
}

input ShipmentItemRef {
  bin: EquipmentRef
  box: BoxRef
  id: ID
  isActive: Boolean
  isParcel: Boolean
  material: MaterialDefinitionRef
  plannedQuantity: Int
  shipment: ShipmentRef
  status: ShipmentItemStatus
  trackingDetailsArticleId: String
  trackingDetailsBarcodeId: String
  trackingDetailsConsignmentId: String
  transportCompanyItemId: String
  transportCompanyItemReference: String
  weightKg: Float
}

enum ShipmentItemStatus {
  CREATED
  DELETED
  DELIVERED
  PACKED
  SHIPPED
}

input ShipmentItemStatus_hash {
  eq: ShipmentItemStatus
  in: [ShipmentItemStatus]
}

input ShipmentOrder {
  asc: ShipmentOrderable
  desc: ShipmentOrderable
  then: ShipmentOrder
}

enum ShipmentOrderable {
  consignmentNumber
  customerReference
  dateTimeCreatedUTC
  dateTimeDeliveredUTC
  dateTimePackedUTC
  dateTimeReceivedUTC
  reference
  transportCompanyProductCode
  transportCompanyShipmentId
}

input ShipmentPatch {
  consignmentNumber: String
  customerReference: String
  dateTimeCreatedUTC: DateTime
  dateTimeDeliveredUTC: DateTime
  dateTimePackedUTC: DateTime
  dateTimeReceivedUTC: DateTime
  delivered: DeliveryRef
  emailTrackingEnabled: Boolean
  from: AddressRef
  isActive: Boolean
  items: [ShipmentItemRef]
  order: OrderRef
  properties: [PropertyRef]
  reference: String
  status: ShipmentStatus
  to: AddressRef
  transportCompany: TransportCompany
  transportCompanyProductCode: String
  transportCompanyShipmentId: String
  type: ShipmentType
  warehouse: EquipmentRef
}

input ShipmentRef {
  consignmentNumber: String
  customerReference: String
  dateTimeCreatedUTC: DateTime
  dateTimeDeliveredUTC: DateTime
  dateTimePackedUTC: DateTime
  dateTimeReceivedUTC: DateTime
  delivered: DeliveryRef
  emailTrackingEnabled: Boolean
  from: AddressRef
  id: ID
  isActive: Boolean
  items: [ShipmentItemRef]
  order: OrderRef
  properties: [PropertyRef]
  reference: String
  status: ShipmentStatus
  to: AddressRef
  transportCompany: TransportCompany
  transportCompanyProductCode: String
  transportCompanyShipmentId: String
  type: ShipmentType
  warehouse: EquipmentRef
}

enum ShipmentStatus {
  COMPLETE
  CREATED
  DELIVERED
  PACKED
  RECEIVED
  SHIPPED
  UNPACKED
}

input ShipmentStatus_hash {
  eq: ShipmentStatus
  in: [ShipmentStatus]
}

enum ShipmentType {
  INBOUND
  OUTBOUND
  RETURN
}

input ShipmentType_hash {
  eq: ShipmentType
  in: [ShipmentType]
}

type ShippingAccount {
  accountNumber: String
  id: ID!
  isActive: Boolean
  partner(filter: PartnerFilter): Partner
  secret: String
  transportCompany: TransportCompany
  username: String
  warehouse(filter: EquipmentFilter): Equipment
}

type ShippingAccountAggregateResult {
  accountNumberMax: String
  accountNumberMin: String
  count: Int
  secretMax: String
  secretMin: String
  usernameMax: String
  usernameMin: String
}

input ShippingAccountData {
  Partner: ExtPartnerRef!
  TransportCompany: TransportCompany!
  Warehouse: ExtEquipmentRef!
}

input ShippingAccountFilter {
  and: [ShippingAccountFilter]
  has: [ShippingAccountHasFilter]
  id: [ID!]
  isActive: Boolean
  not: ShippingAccountFilter
  or: [ShippingAccountFilter]
  transportCompany: TransportCompany_hash
}

enum ShippingAccountHasFilter {
  accountNumber
  isActive
  partner
  secret
  transportCompany
  username
  warehouse
}

input ShippingAccountOrder {
  asc: ShippingAccountOrderable
  desc: ShippingAccountOrderable
  then: ShippingAccountOrder
}

enum ShippingAccountOrderable {
  accountNumber
  secret
  username
}

input ShippingAccountPatch {
  accountNumber: String
  isActive: Boolean
  partner: PartnerRef
  secret: String
  transportCompany: TransportCompany
  username: String
  warehouse: EquipmentRef
}

input ShippingAccountRef {
  accountNumber: String
  id: ID
  isActive: Boolean
  partner: PartnerRef
  secret: String
  transportCompany: TransportCompany
  username: String
  warehouse: EquipmentRef
}

type StateEventRuleset {
  eventDefs(
    filter: EventDefinitionFilter
    first: Int
    offset: Int
    order: EventDefinitionOrder
  ): [EventDefinition]
  eventDefsAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
  id: ID!
  name: String!
  segment(filter: OperationsSegmentFilter): OperationsSegment
  targetState: String!
  triggerWhen: [RulesetTriggerOption]
}

type StateEventRulesetAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
  targetStateMax: String
  targetStateMin: String
}

input StateEventRulesetFilter {
  and: [StateEventRulesetFilter]
  has: [StateEventRulesetHasFilter]
  id: [ID!]
  not: StateEventRulesetFilter
  or: [StateEventRulesetFilter]
}

enum StateEventRulesetHasFilter {
  eventDefs
  name
  segment
  targetState
  triggerWhen
}

input StateEventRulesetOrder {
  asc: StateEventRulesetOrderable
  desc: StateEventRulesetOrderable
  then: StateEventRulesetOrder
}

enum StateEventRulesetOrderable {
  name
  targetState
}

input StateEventRulesetPatch {
  eventDefs: [EventDefinitionRef]
  name: String
  segment: OperationsSegmentRef
  targetState: String
  triggerWhen: [RulesetTriggerOption]
}

input StateEventRulesetRef {
  eventDefs: [EventDefinitionRef]
  id: ID
  name: String
  segment: OperationsSegmentRef
  targetState: String
  triggerWhen: [RulesetTriggerOption]
}

input StateFilter {
  canPack: Boolean
  canReceive: Boolean
  isPlanned: Boolean
}

input StockOnHandFilter {
  carrier: [ExtCarrierRef]
  from: DateTime
  groupBy: StockOnHandGroupBy
  jobResponse: [ExtJobResponseRef]
  material: [ExtMaterialDefinitionRef]
  materialSubLot: [ExtMaterialSubLotRef]
  maximumStock: Int
  minimumStock: Int
  shipment: [ExtShipmentRef]
  shipmentItem: [ExtShipmentItemRef]
  status: [ExtMaterialStatusRef]
  storageLocation: [ExtEquipmentRef]
  to: DateTime
  warehouse: [ExtEquipmentRef]
}

input StockOnHandGroupBy {
  carrier: Boolean
  jobResponse: Boolean
  shipment: Boolean
  status: Boolean
  storageLocation: Boolean
  subLot: Boolean
}

enum StockType {
  NEW_STOCK
  REPAIRED
  RETURNED
}

input StockType_hash {
  eq: StockType
  in: [StockType]
}

input StringExactFilter {
  between: StringRange
  eq: String
  ge: String
  gt: String
  in: [String]
  le: String
  lt: String
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringFullTextFilter_StringHashFilter {
  alloftext: String
  anyoftext: String
  eq: String
  in: [String]
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringHashFilter_StringRegExpFilter {
  eq: String
  in: [String]
  regexp: String
}

input StringRange {
  max: String!
  min: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type TestResult {
  description: String
  id: ID!
  isActive: Boolean
  result: String
  testDateTime: DateTime
  uom(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type TestResultAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  resultMax: String
  resultMin: String
  testDateTimeMax: DateTime
  testDateTimeMin: DateTime
}

input TestResultFilter {
  and: [TestResultFilter]
  has: [TestResultHasFilter]
  id: [ID!]
  isActive: Boolean
  not: TestResultFilter
  or: [TestResultFilter]
}

enum TestResultHasFilter {
  description
  isActive
  result
  testDateTime
  uom
}

input TestResultOrder {
  asc: TestResultOrderable
  desc: TestResultOrderable
  then: TestResultOrder
}

enum TestResultOrderable {
  description
  result
  testDateTime
}

input TestResultPatch {
  description: String
  isActive: Boolean
  result: String
  testDateTime: DateTime
  uom: UnitOfMeasureRef
}

input TestResultRef {
  description: String
  id: ID
  isActive: Boolean
  result: String
  testDateTime: DateTime
  uom: UnitOfMeasureRef
}

type TestSpecification {
  description: String
  id: ID!
  isActive: Boolean
  version: String
}

type TestSpecificationAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  versionMax: String
  versionMin: String
}

input TestSpecificationFilter {
  and: [TestSpecificationFilter]
  has: [TestSpecificationHasFilter]
  id: [ID!]
  isActive: Boolean
  not: TestSpecificationFilter
  or: [TestSpecificationFilter]
}

enum TestSpecificationHasFilter {
  description
  isActive
  version
}

input TestSpecificationOrder {
  asc: TestSpecificationOrderable
  desc: TestSpecificationOrderable
  then: TestSpecificationOrder
}

enum TestSpecificationOrderable {
  description
  version
}

input TestSpecificationPatch {
  description: String
  isActive: Boolean
  version: String
}

input TestSpecificationRef {
  description: String
  id: ID
  isActive: Boolean
  version: String
}

# Time Category abbreviations are defined in ISO 22400 and are used
# to calculate the ISO standard KPI
enum TimeCategory {
  # ADET is the actual unit delay times are actual times associated with malfunction-caused interrupts, minor stoppages,
  # and other unplanned time intervals that occur while tasks are being completed that lead to unwanted extension
  # of the order processing time
  ADET

  # ADOT is the actual unit down time is the time when the work unit is not running with orders, although it is available.
  ADOT

  # APT is the actual production time is the time during a work unit is producing. It includes only the value-adding functions.
  APT

  # AUST is the actual setup time is the time actually consumed for the preparation of an order at a work unit.
  AUST

  # PDOT is time, included in the planned operation time, in which the work unit is planned for no operations within the operation time period
  PDOT

  # PSDT is the time in which the work unit is planned to be out of operation
  PSDT

  # TTR is the time interval during which an item is in a down state due to a failure (IEC 60050-191)
  TTR
}

input TimeRangeFilter {
  from: DateTime
  to: DateTime
}

type TransitionEventRuleset {
  eventDefs(
    filter: EventDefinitionFilter
    first: Int
    offset: Int
    order: EventDefinitionOrder
  ): [EventDefinition]
  eventDefsAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
  id: ID!
  name: String!
  segmentDependency(filter: SegmentDependencyFilter): SegmentDependency
}

type TransitionEventRulesetAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
}

input TransitionEventRulesetFilter {
  and: [TransitionEventRulesetFilter]
  has: [TransitionEventRulesetHasFilter]
  id: [ID!]
  not: TransitionEventRulesetFilter
  or: [TransitionEventRulesetFilter]
}

enum TransitionEventRulesetHasFilter {
  eventDefs
  name
  segmentDependency
}

input TransitionEventRulesetOrder {
  asc: TransitionEventRulesetOrderable
  desc: TransitionEventRulesetOrderable
  then: TransitionEventRulesetOrder
}

enum TransitionEventRulesetOrderable {
  name
}

input TransitionEventRulesetPatch {
  eventDefs: [EventDefinitionRef]
  name: String
  segmentDependency: SegmentDependencyRef
}

input TransitionEventRulesetRef {
  eventDefs: [EventDefinitionRef]
  id: ID
  name: String
  segmentDependency: SegmentDependencyRef
}

enum TransportCompany {
  AUSPOST
  MANUAL
}

input TransportCompany_hash {
  eq: TransportCompany
  in: [TransportCompany]
}

type TransportCompanyDeliveryOrder {
  DeliveryID: String!
  NumberOfShipments: Int
  Shipments: [Shipment]
  Status: String
  TotalCost: Float
  TotalCostExGst: Float
  TotalGst: Float
  TransportCompanyDeliveryID: String!
}

type UnitOfMeasure {
  code: String!
  dataType: DataType
  id: ID!
  isActive: Boolean
}

type UnitOfMeasureAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
}

type UnitOfMeasureConversion {
  denominator: Float!
  fromUoM(filter: UnitOfMeasureFilter): UnitOfMeasure!
  id: ID!
  isActive: Boolean
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
  numerator: Float!
  toUoM(filter: UnitOfMeasureFilter): UnitOfMeasure!
}

type UnitOfMeasureConversionAggregateResult {
  count: Int
  denominatorAvg: Float
  denominatorMax: Float
  denominatorMin: Float
  denominatorSum: Float
  numeratorAvg: Float
  numeratorMax: Float
  numeratorMin: Float
  numeratorSum: Float
}

input UnitOfMeasureConversionFilter {
  and: [UnitOfMeasureConversionFilter]
  has: [UnitOfMeasureConversionHasFilter]
  id: [ID!]
  isActive: Boolean
  not: UnitOfMeasureConversionFilter
  or: [UnitOfMeasureConversionFilter]
}

enum UnitOfMeasureConversionHasFilter {
  denominator
  fromUoM
  isActive
  material
  numerator
  toUoM
}

input UnitOfMeasureConversionOrder {
  asc: UnitOfMeasureConversionOrderable
  desc: UnitOfMeasureConversionOrderable
  then: UnitOfMeasureConversionOrder
}

enum UnitOfMeasureConversionOrderable {
  denominator
  numerator
}

input UnitOfMeasureConversionPatch {
  denominator: Float
  fromUoM: UnitOfMeasureRef
  isActive: Boolean
  material: MaterialDefinitionRef
  numerator: Float
  toUoM: UnitOfMeasureRef
}

input UnitOfMeasureConversionRef {
  denominator: Float
  fromUoM: UnitOfMeasureRef
  id: ID
  isActive: Boolean
  material: MaterialDefinitionRef
  numerator: Float
  toUoM: UnitOfMeasureRef
}

input UnitOfMeasureFilter {
  and: [UnitOfMeasureFilter]
  code: StringHashFilter
  has: [UnitOfMeasureHasFilter]
  id: [ID!]
  isActive: Boolean
  not: UnitOfMeasureFilter
  or: [UnitOfMeasureFilter]
}

enum UnitOfMeasureHasFilter {
  code
  dataType
  isActive
}

input UnitOfMeasureOrder {
  asc: UnitOfMeasureOrderable
  desc: UnitOfMeasureOrderable
  then: UnitOfMeasureOrder
}

enum UnitOfMeasureOrderable {
  code
}

input UnitOfMeasurePatch {
  dataType: DataType
  isActive: Boolean
}

input UnitOfMeasureRef {
  code: String
  dataType: DataType
  id: ID
  isActive: Boolean
}

input UpdateAccessRightInput {
  filter: AccessRightFilter!
  remove: AccessRightPatch
  set: AccessRightPatch
}

type UpdateAccessRightPayload {
  accessRight(filter: AccessRightFilter, first: Int, offset: Int): [AccessRight]
  numUids: Int
}

input UpdateACLInput {
  filter: ACLFilter!
  remove: ACLPatch
  set: ACLPatch
}

type UpdateACLPayload {
  aCL(filter: ACLFilter, first: Int, offset: Int): [ACL]
  numUids: Int
}

input UpdateAddressInput {
  filter: AddressFilter!
  remove: AddressPatch
  set: AddressPatch
}

type UpdateAddressPayload {
  address(
    filter: AddressFilter
    first: Int
    offset: Int
    order: AddressOrder
  ): [Address]
  numUids: Int
}

input UpdateBillOfMaterialInput {
  filter: BillOfMaterialFilter!
  remove: BillOfMaterialPatch
  set: BillOfMaterialPatch
}

type UpdateBillOfMaterialPayload {
  billOfMaterial(
    filter: BillOfMaterialFilter
    first: Int
    offset: Int
    order: BillOfMaterialOrder
  ): [BillOfMaterial]
  numUids: Int
}

input UpdateBoxInput {
  filter: BoxFilter!
  remove: BoxPatch
  set: BoxPatch
}

type UpdateBoxPayload {
  box(filter: BoxFilter, first: Int, offset: Int, order: BoxOrder): [Box]
  numUids: Int
}

input UpdateCarrierInput {
  filter: CarrierFilter!
  remove: CarrierPatch
  set: CarrierPatch
}

type UpdateCarrierPayload {
  carrier(
    filter: CarrierFilter
    first: Int
    offset: Int
    order: CarrierOrder
  ): [Carrier]
  numUids: Int
}

input UpdateDashboardConfigInput {
  filter: DashboardConfigFilter!
  remove: DashboardConfigPatch
  set: DashboardConfigPatch
}

type UpdateDashboardConfigPayload {
  dashboardConfig(
    filter: DashboardConfigFilter
    first: Int
    offset: Int
    order: DashboardConfigOrder
  ): [DashboardConfig]
  numUids: Int
}

input UpdateDashboardPanelConfigInput {
  filter: DashboardPanelConfigFilter!
  remove: DashboardPanelConfigPatch
  set: DashboardPanelConfigPatch
}

type UpdateDashboardPanelConfigPayload {
  dashboardPanelConfig(
    filter: DashboardPanelConfigFilter
    first: Int
    offset: Int
    order: DashboardPanelConfigOrder
  ): [DashboardPanelConfig]
  numUids: Int
}

input UpdateDashboardWidgetConfigPropertyInput {
  filter: DashboardWidgetConfigPropertyFilter!
  remove: DashboardWidgetConfigPropertyPatch
  set: DashboardWidgetConfigPropertyPatch
}

type UpdateDashboardWidgetConfigPropertyPayload {
  dashboardWidgetConfigProperty(
    filter: DashboardWidgetConfigPropertyFilter
    first: Int
    offset: Int
    order: DashboardWidgetConfigPropertyOrder
  ): [DashboardWidgetConfigProperty]
  numUids: Int
}

input UpdateDeliveryInput {
  filter: DeliveryFilter!
  remove: DeliveryPatch
  set: DeliveryPatch
}

type UpdateDeliveryPayload {
  delivery(
    filter: DeliveryFilter
    first: Int
    offset: Int
    order: DeliveryOrder
  ): [Delivery]
  numUids: Int
}

type UpdatedOrderStatus {
  equipment: Equipment
  eventStartTime: DateTime
  updateType: String
}

input UpdateEquipmentActualInput {
  filter: EquipmentActualFilter!
  remove: EquipmentActualPatch
  set: EquipmentActualPatch
}

type UpdateEquipmentActualPayload {
  equipmentActual(
    filter: EquipmentActualFilter
    first: Int
    offset: Int
    order: EquipmentActualOrder
  ): [EquipmentActual]
  numUids: Int
}

input UpdateEquipmentClassInput {
  filter: EquipmentClassFilter!
  remove: EquipmentClassPatch
  set: EquipmentClassPatch
}

type UpdateEquipmentClassPayload {
  equipmentClass(
    filter: EquipmentClassFilter
    first: Int
    offset: Int
    order: EquipmentClassOrder
  ): [EquipmentClass]
  numUids: Int
}

input UpdateEquipmentInput {
  filter: EquipmentFilter!
  remove: EquipmentPatch
  set: EquipmentPatch
}

input UpdateEquipmentNameAliasInput {
  filter: EquipmentNameAliasFilter!
  remove: EquipmentNameAliasPatch
  set: EquipmentNameAliasPatch
}

type UpdateEquipmentNameAliasPayload {
  equipmentNameAlias(
    filter: EquipmentNameAliasFilter
    first: Int
    offset: Int
    order: EquipmentNameAliasOrder
  ): [EquipmentNameAlias]
  numUids: Int
}

type UpdateEquipmentPayload {
  equipment(
    filter: EquipmentFilter
    first: Int
    offset: Int
    order: EquipmentOrder
  ): [Equipment]
  numUids: Int
}

input UpdateEquipmentPropertyOverrideInput {
  filter: EquipmentPropertyOverrideFilter!
  remove: EquipmentPropertyOverridePatch
  set: EquipmentPropertyOverridePatch
}

type UpdateEquipmentPropertyOverridePayload {
  equipmentPropertyOverride(
    filter: EquipmentPropertyOverrideFilter
    first: Int
    offset: Int
    order: EquipmentPropertyOverrideOrder
  ): [EquipmentPropertyOverride]
  numUids: Int
}

input UpdateEquipmentReasonOverrideInput {
  filter: EquipmentReasonOverrideFilter!
  remove: EquipmentReasonOverridePatch
  set: EquipmentReasonOverridePatch
}

type UpdateEquipmentReasonOverridePayload {
  equipmentReasonOverride(
    filter: EquipmentReasonOverrideFilter
    first: Int
    offset: Int
    order: EquipmentReasonOverrideOrder
  ): [EquipmentReasonOverride]
  numUids: Int
}

input UpdateEquipmentRelationInput {
  filter: EquipmentRelationFilter!
  remove: EquipmentRelationPatch
  set: EquipmentRelationPatch
}

type UpdateEquipmentRelationPayload {
  equipmentRelation(
    filter: EquipmentRelationFilter
    first: Int
    offset: Int
  ): [EquipmentRelation]
  numUids: Int
}

input UpdateEquipmentSpecificationInput {
  filter: EquipmentSpecificationFilter!
  remove: EquipmentSpecificationPatch
  set: EquipmentSpecificationPatch
}

type UpdateEquipmentSpecificationPayload {
  equipmentSpecification(
    filter: EquipmentSpecificationFilter
    first: Int
    offset: Int
    order: EquipmentSpecificationOrder
  ): [EquipmentSpecification]
  numUids: Int
}

input UpdateEventDefinitionInput {
  filter: EventDefinitionFilter!
  remove: EventDefinitionPatch
  set: EventDefinitionPatch
}

type UpdateEventDefinitionPayload {
  eventDefinition(
    filter: EventDefinitionFilter
    first: Int
    offset: Int
    order: EventDefinitionOrder
  ): [EventDefinition]
  numUids: Int
}

input UpdateEventLogInput {
  filter: EventLogFilter!
  remove: EventLogPatch
  set: EventLogPatch
}

type UpdateEventLogPayload {
  eventLog(
    filter: EventLogFilter
    first: Int
    offset: Int
    order: EventLogOrder
  ): [EventLog]
  numUids: Int
}

input UpdateFormInput {
  filter: FormFilter!
  remove: FormPatch
  set: FormPatch
}

type UpdateFormPayload {
  form(filter: FormFilter, first: Int, offset: Int, order: FormOrder): [Form]
  numUids: Int
}

input UpdateGeneralLedgerAccountInput {
  filter: GeneralLedgerAccountFilter!
  remove: GeneralLedgerAccountPatch
  set: GeneralLedgerAccountPatch
}

type UpdateGeneralLedgerAccountPayload {
  generalLedgerAccount(
    filter: GeneralLedgerAccountFilter
    first: Int
    offset: Int
    order: GeneralLedgerAccountOrder
  ): [GeneralLedgerAccount]
  numUids: Int
}

input UpdateInterfaceMessageLogInput {
  filter: InterfaceMessageLogFilter!
  remove: InterfaceMessageLogPatch
  set: InterfaceMessageLogPatch
}

type UpdateInterfaceMessageLogPayload {
  interfaceMessageLog(
    filter: InterfaceMessageLogFilter
    first: Int
    offset: Int
    order: InterfaceMessageLogOrder
  ): [InterfaceMessageLog]
  numUids: Int
}

input UpdateInventoryHandlingPolicyInput {
  filter: InventoryHandlingPolicyFilter!
  remove: InventoryHandlingPolicyPatch
  set: InventoryHandlingPolicyPatch
}

type UpdateInventoryHandlingPolicyPayload {
  inventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
    first: Int
    offset: Int
    order: InventoryHandlingPolicyOrder
  ): [InventoryHandlingPolicy]
  numUids: Int
}

input UpdateInventoryHandlingRuleInput {
  filter: InventoryHandlingRuleFilter!
  remove: InventoryHandlingRulePatch
  set: InventoryHandlingRulePatch
}

type UpdateInventoryHandlingRulePayload {
  inventoryHandlingRule(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  numUids: Int
}

input UpdateInventoryHoldingPolicyInput {
  filter: InventoryHoldingPolicyFilter!
  remove: InventoryHoldingPolicyPatch
  set: InventoryHoldingPolicyPatch
}

type UpdateInventoryHoldingPolicyPayload {
  inventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    first: Int
    offset: Int
    order: InventoryHoldingPolicyOrder
  ): [InventoryHoldingPolicy]
  numUids: Int
}

input UpdateJobOrderDependencyInput {
  filter: JobOrderDependencyFilter!
  remove: JobOrderDependencyPatch
  set: JobOrderDependencyPatch
}

type UpdateJobOrderDependencyPayload {
  jobOrderDependency(
    filter: JobOrderDependencyFilter
    first: Int
    offset: Int
    order: JobOrderDependencyOrder
  ): [JobOrderDependency]
  numUids: Int
}

input UpdateJobOrderDispatchStateModelInput {
  filter: JobOrderDispatchStateModelFilter!
  remove: JobOrderDispatchStateModelPatch
  set: JobOrderDispatchStateModelPatch
}

type UpdateJobOrderDispatchStateModelPayload {
  jobOrderDispatchStateModel(
    filter: JobOrderDispatchStateModelFilter
    first: Int
    offset: Int
  ): [JobOrderDispatchStateModel]
  numUids: Int
}

input UpdateJobOrderInput {
  filter: JobOrderFilter!
  remove: JobOrderPatch
  set: JobOrderPatch
}

input UpdateJobOrderNoteInput {
  filter: JobOrderNoteFilter!
  remove: JobOrderNotePatch
  set: JobOrderNotePatch
}

type UpdateJobOrderNotePayload {
  jobOrderNote(
    filter: JobOrderNoteFilter
    first: Int
    offset: Int
    order: JobOrderNoteOrder
  ): [JobOrderNote]
  numUids: Int
}

type UpdateJobOrderPayload {
  jobOrder(
    filter: JobOrderFilter
    first: Int
    offset: Int
    order: JobOrderOrder
  ): [JobOrder]
  numUids: Int
}

input UpdateJobOrderStatusInput {
  filter: JobOrderFilter!
  set: JobOrderStatusPatch
}

input UpdateJobResponseInput {
  filter: JobResponseFilter!
  remove: JobResponsePatch
  set: JobResponsePatch
}

type UpdateJobResponsePayload {
  jobResponse(
    filter: JobResponseFilter
    first: Int
    offset: Int
    order: JobResponseOrder
  ): [JobResponse]
  numUids: Int
}

input UpdateLibreServiceInput {
  filter: LibreServiceFilter!
  remove: LibreServicePatch
  set: LibreServicePatch
}

type UpdateLibreServicePayload {
  libreService(
    filter: LibreServiceFilter
    first: Int
    offset: Int
    order: LibreServiceOrder
  ): [LibreService]
  numUids: Int
}

input UpdateMaterialActualInput {
  filter: MaterialActualFilter!
  remove: MaterialActualPatch
  set: MaterialActualPatch
}

type UpdateMaterialActualPayload {
  materialActual(
    filter: MaterialActualFilter
    first: Int
    offset: Int
    order: MaterialActualOrder
  ): [MaterialActual]
  numUids: Int
}

input UpdateMaterialAlternateInput {
  filter: MaterialAlternateFilter!
  remove: MaterialAlternatePatch
  set: MaterialAlternatePatch
}

type UpdateMaterialAlternatePayload {
  materialAlternate(
    filter: MaterialAlternateFilter
    first: Int
    offset: Int
    order: MaterialAlternateOrder
  ): [MaterialAlternate]
  numUids: Int
}

input UpdateMaterialClassInput {
  filter: MaterialClassFilter!
  remove: MaterialClassPatch
  set: MaterialClassPatch
}

type UpdateMaterialClassPayload {
  materialClass(
    filter: MaterialClassFilter
    first: Int
    offset: Int
    order: MaterialClassOrder
  ): [MaterialClass]
  numUids: Int
}

input UpdateMaterialDefinitionInput {
  filter: MaterialDefinitionFilter!
  remove: MaterialDefinitionPatch
  set: MaterialDefinitionPatch
}

type UpdateMaterialDefinitionPayload {
  materialDefinition(
    filter: MaterialDefinitionFilter
    first: Int
    offset: Int
    order: MaterialDefinitionOrder
  ): [MaterialDefinition]
  numUids: Int
}

input UpdateMaterialEventRulesetInput {
  filter: MaterialEventRulesetFilter!
  remove: MaterialEventRulesetPatch
  set: MaterialEventRulesetPatch
}

type UpdateMaterialEventRulesetPayload {
  materialEventRuleset(
    filter: MaterialEventRulesetFilter
    first: Int
    offset: Int
    order: MaterialEventRulesetOrder
  ): [MaterialEventRuleset]
  numUids: Int
}

input UpdateMaterialLotInput {
  filter: MaterialLotFilter!
  remove: MaterialLotPatch
  set: MaterialLotPatch
}

type UpdateMaterialLotPayload {
  materialLot(
    filter: MaterialLotFilter
    first: Int
    offset: Int
    order: MaterialLotOrder
  ): [MaterialLot]
  numUids: Int
}

input UpdateMaterialSpecificationInput {
  filter: MaterialSpecificationFilter!
  remove: MaterialSpecificationPatch
  set: MaterialSpecificationPatch
}

type UpdateMaterialSpecificationPayload {
  materialSpecification(
    filter: MaterialSpecificationFilter
    first: Int
    offset: Int
    order: MaterialSpecificationOrder
  ): [MaterialSpecification]
  numUids: Int
}

input UpdateMaterialStateModelInput {
  filter: MaterialStateModelFilter!
  remove: MaterialStateModelPatch
  set: MaterialStateModelPatch
}

type UpdateMaterialStateModelPayload {
  materialStateModel(
    filter: MaterialStateModelFilter
    first: Int
    offset: Int
    order: MaterialStateModelOrder
  ): [MaterialStateModel]
  numUids: Int
}

input UpdateMaterialStateTransitionInput {
  filter: MaterialStateTransitionFilter!
  remove: MaterialStateTransitionPatch
  set: MaterialStateTransitionPatch
}

type UpdateMaterialStateTransitionPayload {
  materialStateTransition(
    filter: MaterialStateTransitionFilter
    first: Int
    offset: Int
  ): [MaterialStateTransition]
  numUids: Int
}

input UpdateMaterialStatusInput {
  filter: MaterialStatusFilter!
  remove: MaterialStatusPatch
  set: MaterialStatusPatch
}

type UpdateMaterialStatusPayload {
  materialStatus(
    filter: MaterialStatusFilter
    first: Int
    offset: Int
    order: MaterialStatusOrder
  ): [MaterialStatus]
  numUids: Int
}

input UpdateMaterialSubLotInput {
  filter: MaterialSubLotFilter!
  remove: MaterialSubLotPatch
  set: MaterialSubLotPatch
}

type UpdateMaterialSubLotPayload {
  materialSubLot(
    filter: MaterialSubLotFilter
    first: Int
    offset: Int
    order: MaterialSubLotOrder
  ): [MaterialSubLot]
  numUids: Int
}

input UpdateMaterialUnitInput {
  filter: MaterialUnitFilter!
  remove: MaterialUnitPatch
  set: MaterialUnitPatch
}

type UpdateMaterialUnitPayload {
  materialUnit(
    filter: MaterialUnitFilter
    first: Int
    offset: Int
    order: MaterialUnitOrder
  ): [MaterialUnit]
  numUids: Int
}

input UpdateMenuInput {
  filter: MenuFilter!
  remove: MenuPatch
  set: MenuPatch
}

type UpdateMenuPayload {
  menu(filter: MenuFilter, first: Int, offset: Int, order: MenuOrder): [Menu]
  numUids: Int
}

input UpdateOperationsDefinitionInput {
  filter: OperationsDefinitionFilter!
  remove: OperationsDefinitionPatch
  set: OperationsDefinitionPatch
}

type UpdateOperationsDefinitionPayload {
  numUids: Int
  operationsDefinition(
    filter: OperationsDefinitionFilter
    first: Int
    offset: Int
    order: OperationsDefinitionOrder
  ): [OperationsDefinition]
}

input UpdateOperationsRequestInput {
  filter: OperationsRequestFilter!
  remove: OperationsRequestPatch
  set: OperationsRequestPatch
}

type UpdateOperationsRequestPayload {
  numUids: Int
  operationsRequest(
    filter: OperationsRequestFilter
    first: Int
    offset: Int
    order: OperationsRequestOrder
  ): [OperationsRequest]
}

input UpdateOperationsSegmentInput {
  filter: OperationsSegmentFilter!
  remove: OperationsSegmentPatch
  set: OperationsSegmentPatch
}

type UpdateOperationsSegmentPayload {
  numUids: Int
  operationsSegment(
    filter: OperationsSegmentFilter
    first: Int
    offset: Int
    order: OperationsSegmentOrder
  ): [OperationsSegment]
}

input UpdateOrderInput {
  filter: OrderFilter!
  remove: OrderPatch
  set: OrderPatch
}

input UpdateOrderLineInput {
  filter: OrderLineFilter!
  remove: OrderLinePatch
  set: OrderLinePatch
}

type UpdateOrderLinePayload {
  numUids: Int
  orderLine(
    filter: OrderLineFilter
    first: Int
    offset: Int
    order: OrderLineOrder
  ): [OrderLine]
}

type UpdateOrderPayload {
  numUids: Int
  order(
    filter: OrderFilter
    first: Int
    offset: Int
    order: OrderOrder
  ): [Order]
}

input UpdateOrderStartRulesetInput {
  filter: OrderStartRulesetFilter!
  remove: OrderStartRulesetPatch
  set: OrderStartRulesetPatch
}

type UpdateOrderStartRulesetPayload {
  numUids: Int
  orderStartRuleset(
    filter: OrderStartRulesetFilter
    first: Int
    offset: Int
    order: OrderStartRulesetOrder
  ): [OrderStartRuleset]
}

input UpdateOrderStatusInput {
  equipment: ExtEquipmentRef!
  eventStartTime: DateTime!
  updateType: String!
}

input UpdateParameterSpecificationInput {
  filter: ParameterSpecificationFilter!
  remove: ParameterSpecificationPatch
  set: ParameterSpecificationPatch
}

type UpdateParameterSpecificationPayload {
  numUids: Int
  parameterSpecification(
    filter: ParameterSpecificationFilter
    first: Int
    offset: Int
    order: ParameterSpecificationOrder
  ): [ParameterSpecification]
}

input UpdatePartnerInput {
  filter: PartnerFilter!
  remove: PartnerPatch
  set: PartnerPatch
}

type UpdatePartnerPayload {
  numUids: Int
  partner(
    filter: PartnerFilter
    first: Int
    offset: Int
    order: PartnerOrder
  ): [Partner]
}

input UpdatePayloadFieldDefinitionInput {
  filter: PayloadFieldDefinitionFilter!
  remove: PayloadFieldDefinitionPatch
  set: PayloadFieldDefinitionPatch
}

type UpdatePayloadFieldDefinitionPayload {
  numUids: Int
  payloadFieldDefinition(
    filter: PayloadFieldDefinitionFilter
    first: Int
    offset: Int
    order: PayloadFieldDefinitionOrder
  ): [PayloadFieldDefinition]
}

input UpdatePersonInput {
  filter: PersonFilter!
  remove: PersonPatch
  set: PersonPatch
}

input UpdatePersonnelActualInput {
  filter: PersonnelActualFilter!
  remove: PersonnelActualPatch
  set: PersonnelActualPatch
}

type UpdatePersonnelActualPayload {
  numUids: Int
  personnelActual(
    filter: PersonnelActualFilter
    first: Int
    offset: Int
    order: PersonnelActualOrder
  ): [PersonnelActual]
}

input UpdatePersonnelClassInput {
  filter: PersonnelClassFilter!
  remove: PersonnelClassPatch
  set: PersonnelClassPatch
}

type UpdatePersonnelClassPayload {
  numUids: Int
  personnelClass(
    filter: PersonnelClassFilter
    first: Int
    offset: Int
    order: PersonnelClassOrder
  ): [PersonnelClass]
}

input UpdatePersonnelSpecificationInput {
  filter: PersonnelSpecificationFilter!
  remove: PersonnelSpecificationPatch
  set: PersonnelSpecificationPatch
}

type UpdatePersonnelSpecificationPayload {
  numUids: Int
  personnelSpecification(
    filter: PersonnelSpecificationFilter
    first: Int
    offset: Int
    order: PersonnelSpecificationOrder
  ): [PersonnelSpecification]
}

type UpdatePersonPayload {
  numUids: Int
  person(
    filter: PersonFilter
    first: Int
    offset: Int
    order: PersonOrder
  ): [Person]
}

input UpdatePropertyInput {
  filter: PropertyFilter!
  remove: PropertyPatch
  set: PropertyPatch
}

input UpdatePropertyNameAliasInput {
  filter: PropertyNameAliasFilter!
  remove: PropertyNameAliasPatch
  set: PropertyNameAliasPatch
}

type UpdatePropertyNameAliasPayload {
  numUids: Int
  propertyNameAlias(
    filter: PropertyNameAliasFilter
    first: Int
    offset: Int
    order: PropertyNameAliasOrder
  ): [PropertyNameAlias]
}

type UpdatePropertyPayload {
  numUids: Int
  property(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
}

input UpdatePropertyValueAliasInput {
  filter: PropertyValueAliasFilter!
  remove: PropertyValueAliasPatch
  set: PropertyValueAliasPatch
}

type UpdatePropertyValueAliasPayload {
  numUids: Int
  propertyValueAlias(
    filter: PropertyValueAliasFilter
    first: Int
    offset: Int
    order: PropertyValueAliasOrder
  ): [PropertyValueAlias]
}

input UpdateQuantityLogInput {
  filter: QuantityLogFilter!
  remove: QuantityLogPatch
  set: QuantityLogPatch
}

type UpdateQuantityLogPayload {
  numUids: Int
  quantityLog(
    filter: QuantityLogFilter
    first: Int
    offset: Int
    order: QuantityLogOrder
  ): [QuantityLog]
}

input UpdateReasonCategoryInput {
  filter: ReasonCategoryFilter!
  remove: ReasonCategoryPatch
  set: ReasonCategoryPatch
}

type UpdateReasonCategoryPayload {
  numUids: Int
  reasonCategory(
    filter: ReasonCategoryFilter
    first: Int
    offset: Int
    order: ReasonCategoryOrder
  ): [ReasonCategory]
}

input UpdateReasonInput {
  filter: ReasonFilter!
  remove: ReasonPatch
  set: ReasonPatch
}

type UpdateReasonPayload {
  numUids: Int
  reason(
    filter: ReasonFilter
    first: Int
    offset: Int
    order: ReasonOrder
  ): [Reason]
}

input UpdateRequestStateInput {
  filter: RequestStateFilter!
  remove: RequestStatePatch
  set: RequestStatePatch
}

type UpdateRequestStatePayload {
  numUids: Int
  requestState(
    filter: RequestStateFilter
    first: Int
    offset: Int
    order: RequestStateOrder
  ): [RequestState]
}

input UpdateRoleInput {
  filter: RoleFilter!
  remove: RolePatch
  set: RolePatch
}

type UpdateRolePayload {
  numUids: Int
  role(filter: RoleFilter, first: Int, offset: Int, order: RoleOrder): [Role]
}

input UpdateSegmentDependencyInput {
  filter: SegmentDependencyFilter!
  remove: SegmentDependencyPatch
  set: SegmentDependencyPatch
}

type UpdateSegmentDependencyPayload {
  numUids: Int
  segmentDependency(
    filter: SegmentDependencyFilter
    first: Int
    offset: Int
    order: SegmentDependencyOrder
  ): [SegmentDependency]
}

input UpdateSegmentInvoiceSettingInput {
  filter: SegmentInvoiceSettingFilter!
  remove: SegmentInvoiceSettingPatch
  set: SegmentInvoiceSettingPatch
}

type UpdateSegmentInvoiceSettingPayload {
  numUids: Int
  segmentInvoiceSetting(
    filter: SegmentInvoiceSettingFilter
    first: Int
    offset: Int
    order: SegmentInvoiceSettingOrder
  ): [SegmentInvoiceSetting]
}

input UpdateShipmentInput {
  filter: ShipmentFilter!
  remove: ShipmentPatch
  set: ShipmentPatch
}

input UpdateShipmentItemInput {
  filter: ShipmentItemFilter!
  remove: ShipmentItemPatch
  set: ShipmentItemPatch
}

type UpdateShipmentItemPayload {
  numUids: Int
  shipmentItem(
    filter: ShipmentItemFilter
    first: Int
    offset: Int
    order: ShipmentItemOrder
  ): [ShipmentItem]
}

type UpdateShipmentPayload {
  numUids: Int
  shipment(
    filter: ShipmentFilter
    first: Int
    offset: Int
    order: ShipmentOrder
  ): [Shipment]
}

input UpdateShippingAccountInput {
  filter: ShippingAccountFilter!
  remove: ShippingAccountPatch
  set: ShippingAccountPatch
}

type UpdateShippingAccountPayload {
  numUids: Int
  shippingAccount(
    filter: ShippingAccountFilter
    first: Int
    offset: Int
    order: ShippingAccountOrder
  ): [ShippingAccount]
}

input UpdateStateEventRulesetInput {
  filter: StateEventRulesetFilter!
  remove: StateEventRulesetPatch
  set: StateEventRulesetPatch
}

type UpdateStateEventRulesetPayload {
  numUids: Int
  stateEventRuleset(
    filter: StateEventRulesetFilter
    first: Int
    offset: Int
    order: StateEventRulesetOrder
  ): [StateEventRuleset]
}

input UpdateTestResultInput {
  filter: TestResultFilter!
  remove: TestResultPatch
  set: TestResultPatch
}

type UpdateTestResultPayload {
  numUids: Int
  testResult(
    filter: TestResultFilter
    first: Int
    offset: Int
    order: TestResultOrder
  ): [TestResult]
}

input UpdateTestSpecificationInput {
  filter: TestSpecificationFilter!
  remove: TestSpecificationPatch
  set: TestSpecificationPatch
}

type UpdateTestSpecificationPayload {
  numUids: Int
  testSpecification(
    filter: TestSpecificationFilter
    first: Int
    offset: Int
    order: TestSpecificationOrder
  ): [TestSpecification]
}

input UpdateTransitionEventRulesetInput {
  filter: TransitionEventRulesetFilter!
  remove: TransitionEventRulesetPatch
  set: TransitionEventRulesetPatch
}

type UpdateTransitionEventRulesetPayload {
  numUids: Int
  transitionEventRuleset(
    filter: TransitionEventRulesetFilter
    first: Int
    offset: Int
    order: TransitionEventRulesetOrder
  ): [TransitionEventRuleset]
}

input UpdateUnitOfMeasureConversionInput {
  filter: UnitOfMeasureConversionFilter!
  remove: UnitOfMeasureConversionPatch
  set: UnitOfMeasureConversionPatch
}

type UpdateUnitOfMeasureConversionPayload {
  numUids: Int
  unitOfMeasureConversion(
    filter: UnitOfMeasureConversionFilter
    first: Int
    offset: Int
    order: UnitOfMeasureConversionOrder
  ): [UnitOfMeasureConversion]
}

input UpdateUnitOfMeasureInput {
  filter: UnitOfMeasureFilter!
  remove: UnitOfMeasurePatch
  set: UnitOfMeasurePatch
}

type UpdateUnitOfMeasurePayload {
  numUids: Int
  unitOfMeasure(
    filter: UnitOfMeasureFilter
    first: Int
    offset: Int
    order: UnitOfMeasureOrder
  ): [UnitOfMeasure]
}

input UpdateUserInput {
  filter: UserFilter!
  remove: UserPatch
  set: UserPatch
}

type UpdateUserPayload {
  numUids: Int
  user(filter: UserFilter, first: Int, offset: Int, order: UserOrder): [User]
}

input UpdateUserRoleInput {
  filter: UserRoleFilter!
  remove: UserRolePatch
  set: UserRolePatch
}

type UpdateUserRolePayload {
  numUids: Int
  userRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
}

input UpdateWorkCalendarDefinitionEntryInput {
  filter: WorkCalendarDefinitionEntryFilter!
  remove: WorkCalendarDefinitionEntryPatch
  set: WorkCalendarDefinitionEntryPatch
}

type UpdateWorkCalendarDefinitionEntryPayload {
  numUids: Int
  workCalendarDefinitionEntry(
    filter: WorkCalendarDefinitionEntryFilter
    first: Int
    offset: Int
    order: WorkCalendarDefinitionEntryOrder
  ): [WorkCalendarDefinitionEntry]
}

input UpdateWorkCalendarEntryInput {
  filter: WorkCalendarEntryFilter!
  remove: WorkCalendarEntryPatch
  set: WorkCalendarEntryPatch
}

type UpdateWorkCalendarEntryPayload {
  numUids: Int
  workCalendarEntry(
    filter: WorkCalendarEntryFilter
    first: Int
    offset: Int
    order: WorkCalendarEntryOrder
  ): [WorkCalendarEntry]
}

input UpdateWorkCalendarInput {
  filter: WorkCalendarFilter!
  remove: WorkCalendarPatch
  set: WorkCalendarPatch
}

type UpdateWorkCalendarPayload {
  numUids: Int
  workCalendar(
    filter: WorkCalendarFilter
    first: Int
    offset: Int
    order: WorkCalendarOrder
  ): [WorkCalendar]
}

input UpdateWorkflowConnectionInput {
  filter: WorkflowConnectionFilter!
  remove: WorkflowConnectionPatch
  set: WorkflowConnectionPatch
}

type UpdateWorkflowConnectionPayload {
  numUids: Int
  workflowConnection(
    filter: WorkflowConnectionFilter
    first: Int
    offset: Int
    order: WorkflowConnectionOrder
  ): [WorkflowConnection]
}

input UpdateWorkflowConnectionTypeInput {
  filter: WorkflowConnectionTypeFilter!
  remove: WorkflowConnectionTypePatch
  set: WorkflowConnectionTypePatch
}

type UpdateWorkflowConnectionTypePayload {
  numUids: Int
  workflowConnectionType(
    filter: WorkflowConnectionTypeFilter
    first: Int
    offset: Int
    order: WorkflowConnectionTypeOrder
  ): [WorkflowConnectionType]
}

input UpdateWorkflowInstanceInput {
  filter: WorkflowInstanceFilter!
  remove: WorkflowInstancePatch
  set: WorkflowInstancePatch
}

type UpdateWorkflowInstancePayload {
  numUids: Int
  workflowInstance(
    filter: WorkflowInstanceFilter
    first: Int
    offset: Int
    order: WorkflowInstanceOrder
  ): [WorkflowInstance]
}

input UpdateWorkflowInstancePropertyInput {
  filter: WorkflowInstancePropertyFilter!
  remove: WorkflowInstancePropertyPatch
  set: WorkflowInstancePropertyPatch
}

type UpdateWorkflowInstancePropertyPayload {
  numUids: Int
  workflowInstanceProperty(
    filter: WorkflowInstancePropertyFilter
    first: Int
    offset: Int
    order: WorkflowInstancePropertyOrder
  ): [WorkflowInstanceProperty]
}

input UpdateWorkflowNodeEventInput {
  filter: WorkflowNodeEventFilter!
  remove: WorkflowNodeEventPatch
  set: WorkflowNodeEventPatch
}

type UpdateWorkflowNodeEventPayload {
  numUids: Int
  workflowNodeEvent(
    filter: WorkflowNodeEventFilter
    first: Int
    offset: Int
    order: WorkflowNodeEventOrder
  ): [WorkflowNodeEvent]
}

input UpdateWorkflowNodeInput {
  filter: WorkflowNodeFilter!
  remove: WorkflowNodePatch
  set: WorkflowNodePatch
}

input UpdateWorkflowNodeInstanceInput {
  filter: WorkflowNodeInstanceFilter!
  remove: WorkflowNodeInstancePatch
  set: WorkflowNodeInstancePatch
}

type UpdateWorkflowNodeInstancePayload {
  numUids: Int
  workflowNodeInstance(
    filter: WorkflowNodeInstanceFilter
    first: Int
    offset: Int
    order: WorkflowNodeInstanceOrder
  ): [WorkflowNodeInstance]
}

type UpdateWorkflowNodePayload {
  numUids: Int
  workflowNode(
    filter: WorkflowNodeFilter
    first: Int
    offset: Int
    order: WorkflowNodeOrder
  ): [WorkflowNode]
}

input UpdateWorkflowNodeTypeInput {
  filter: WorkflowNodeTypeFilter!
  remove: WorkflowNodeTypePatch
  set: WorkflowNodeTypePatch
}

type UpdateWorkflowNodeTypePayload {
  numUids: Int
  workflowNodeType(
    filter: WorkflowNodeTypeFilter
    first: Int
    offset: Int
    order: WorkflowNodeTypeOrder
  ): [WorkflowNodeType]
}

input UpdateWorkflowPropertyInput {
  filter: WorkflowPropertyFilter!
  remove: WorkflowPropertyPatch
  set: WorkflowPropertyPatch
}

input UpdateWorkflowPropertyInstanceInput {
  filter: WorkflowPropertyInstanceFilter!
  remove: WorkflowPropertyInstancePatch
  set: WorkflowPropertyInstancePatch
}

type UpdateWorkflowPropertyInstancePayload {
  numUids: Int
  workflowPropertyInstance(
    filter: WorkflowPropertyInstanceFilter
    first: Int
    offset: Int
    order: WorkflowPropertyInstanceOrder
  ): [WorkflowPropertyInstance]
}

type UpdateWorkflowPropertyPayload {
  numUids: Int
  workflowProperty(
    filter: WorkflowPropertyFilter
    first: Int
    offset: Int
    order: WorkflowPropertyOrder
  ): [WorkflowProperty]
}

input UpdateWorkflowPropertyValueInput {
  filter: WorkflowPropertyValueFilter!
  remove: WorkflowPropertyValuePatch
  set: WorkflowPropertyValuePatch
}

type UpdateWorkflowPropertyValuePayload {
  numUids: Int
  workflowPropertyValue(
    filter: WorkflowPropertyValueFilter
    first: Int
    offset: Int
    order: WorkflowPropertyValueOrder
  ): [WorkflowPropertyValue]
}

input UpdateWorkflowSpecificationInput {
  filter: WorkflowSpecificationFilter!
  remove: WorkflowSpecificationPatch
  set: WorkflowSpecificationPatch
}

type UpdateWorkflowSpecificationPayload {
  numUids: Int
  workflowSpecification(
    filter: WorkflowSpecificationFilter
    first: Int
    offset: Int
    order: WorkflowSpecificationOrder
  ): [WorkflowSpecification]
}

input UpdateWorkflowTaskInput {
  properties: [ExtWorkflowPropertyRef]
  status: String!
  task: ExtWorkflowNodeInstanceRef!
  user: CoreUserRef!
}

input UploadScheduleInput {
  begin: DateTime
  end: DateTime
  matNo: String
  orderNo: String
  workCenter: String
}

type UploadScheduleRowValidation {
  begin: DateTime
  end: DateTime
  errList: [String]
  isValid: Boolean
  materialNo: String
  orderNo: String
  workCenter: String
}

type UploadScheduleStaging {
  jobOrderStagings: [JobOrderStaging]
  operationsRequestStagings: [OperationsRequestStaging]
  rowValidations: [UploadScheduleRowValidation]
}

input UploadStagedScheduleInput {
  jobOrderStagings: [JobOrderStagingInput]
  operationsRequestStagings: [OperationsRequestStagingInput]
}

type UploadStagedScheduleOutput {
  jobOrders: [JobOrder]
  operationsRequest: [OperationsRequest]
}

type User {
  hasRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
  hasRoleAggregate(filter: UserRoleFilter): UserRoleAggregateResult
  id: ID!
  isActive: Boolean
  isType: UserType!
  name: String
  tasks(
    filter: WorkflowNodeInstanceFilter
    first: Int
    offset: Int
    order: WorkflowNodeInstanceOrder
  ): [WorkflowNodeInstance]
  tasksAggregate(
    filter: WorkflowNodeInstanceFilter
  ): WorkflowNodeInstanceAggregateResult
  username: String!
}

type UserAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
  usernameMax: String
  usernameMin: String
}

input UserFilter {
  and: [UserFilter]
  has: [UserHasFilter]
  id: [ID!]
  isType: UserType_hash
  not: UserFilter
  or: [UserFilter]
  username: StringHashFilter
}

enum UserHasFilter {
  hasRole
  isActive
  isType
  name
  tasks
  username
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

enum UserOrderable {
  name
  username
}

input UserPatch {
  hasRole: [UserRoleRef]
  isActive: Boolean
  isType: UserType
  name: String
  tasks: [WorkflowNodeInstanceRef]
}

input UserRef {
  hasRole: [UserRoleRef]
  id: ID
  isActive: Boolean
  isType: UserType
  name: String
  tasks: [WorkflowNodeInstanceRef]
  username: String
}

type UserRole {
  id: ID!
  isActive: Boolean
  responsibilities(
    filter: EquipmentFilter
    first: Int
    offset: Int
    order: EquipmentOrder
  ): [Equipment]!
  responsibilitiesAggregate(filter: EquipmentFilter): EquipmentAggregateResult
  role(filter: RoleFilter): Role!
  user(filter: UserFilter): User!
}

type UserRoleAggregateResult {
  count: Int
}

input UserRoleFilter {
  and: [UserRoleFilter]
  has: [UserRoleHasFilter]
  id: [ID!]
  not: UserRoleFilter
  or: [UserRoleFilter]
}

enum UserRoleHasFilter {
  isActive
  responsibilities
  role
  user
}

input UserRolePatch {
  isActive: Boolean
  responsibilities: [EquipmentRef]
  role: RoleRef
  user: UserRef
}

input UserRoleRef {
  id: ID
  isActive: Boolean
  responsibilities: [EquipmentRef]
  role: RoleRef
  user: UserRef
}

enum UserType {
  ADMIN
  USER
}

input UserType_hash {
  eq: UserType
  in: [UserType]
}

input ValidateASNInput {
  asnStagingInput: [ASNStagingInput!]!
  site: ExtEquipmentRef!
}

enum Weekday {
  FR
  MO
  SA
  SU
  TH
  TU
  WE
}

input WithinFilter {
  polygon: PolygonRef!
}

type WorkCalendar {
  definition(
    filter: WorkCalendarDefinitionEntryFilter
    first: Int
    offset: Int
    order: WorkCalendarDefinitionEntryOrder
  ): [WorkCalendarDefinitionEntry]
  definitionAggregate(
    filter: WorkCalendarDefinitionEntryFilter
  ): WorkCalendarDefinitionEntryAggregateResult
  description: String
  entries(
    filter: WorkCalendarEntryFilter
    first: Int
    offset: Int
    order: WorkCalendarEntryOrder
  ): [WorkCalendarEntry]
  entriesAggregate(
    filter: WorkCalendarEntryFilter
  ): WorkCalendarEntryAggregateResult
  equipment(
    filter: EquipmentFilter
    first: Int
    offset: Int
    order: EquipmentOrder
  ): [Equipment]
  equipmentAggregate(filter: EquipmentFilter): EquipmentAggregateResult
  id: ID!
  isActive: Boolean
  name: String!
}

type WorkCalendarAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  nameMax: String
  nameMin: String
}

# Work Calendar domain describes the definition of shift patterns and non-working days
# The Work Calendar Definition defines the rule used to determine work calendar entries.
# It contains the recurrence time for the rule, the duration of the entry, the entry type, and properties associated with the entry.
# Standard Entry Types include Working Time and Non-Working Time. The entry may include property definitions.
# The definition uses the rrule.js library to generate calendar events, and the fields available match
# the configuration fields required by rrule.js
type WorkCalendarDefinitionEntry {
  byHour: [Int]
  byMinute: [Int]
  byMonth: [Int]
  byMonthDay: [Int]
  bySecond: [Int]
  bySetPos: [Int]
  byWeekDay: [Weekday]
  byWeekNo: [Int]
  byYearDay: [Int]
  calendarEntries(
    filter: WorkCalendarEntryFilter
    first: Int
    offset: Int
    order: WorkCalendarEntryOrder
  ): [WorkCalendarEntry]
  calendarEntriesAggregate(
    filter: WorkCalendarEntryFilter
  ): WorkCalendarEntryAggregateResult
  count: Int
  description: String
  duration: String
  endDateTime: DateTime
  entryType: WorkCalendarEntryType!
  freq: Frequency!
  hierarchyScope(filter: EquipmentFilter): Equipment
  id: ID!
  interval: Int
  isActive: Boolean
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  startDateTime: DateTime!
  wkst: Weekday
  workCalendar(filter: WorkCalendarFilter): WorkCalendar
}

type WorkCalendarDefinitionEntryAggregateResult {
  count: Int
  countAvg: Float
  countMax: Int
  countMin: Int
  countSum: Int
  descriptionMax: String
  descriptionMin: String
  durationMax: String
  durationMin: String
  endDateTimeMax: DateTime
  endDateTimeMin: DateTime
  intervalAvg: Float
  intervalMax: Int
  intervalMin: Int
  intervalSum: Int
  startDateTimeMax: DateTime
  startDateTimeMin: DateTime
}

input WorkCalendarDefinitionEntryFilter {
  and: [WorkCalendarDefinitionEntryFilter]
  has: [WorkCalendarDefinitionEntryHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkCalendarDefinitionEntryFilter
  or: [WorkCalendarDefinitionEntryFilter]
}

enum WorkCalendarDefinitionEntryHasFilter {
  byHour
  byMinute
  byMonth
  byMonthDay
  bySecond
  bySetPos
  byWeekDay
  byWeekNo
  byYearDay
  calendarEntries
  count
  description
  duration
  endDateTime
  entryType
  freq
  hierarchyScope
  interval
  isActive
  properties
  startDateTime
  wkst
  workCalendar
}

input WorkCalendarDefinitionEntryOrder {
  asc: WorkCalendarDefinitionEntryOrderable
  desc: WorkCalendarDefinitionEntryOrderable
  then: WorkCalendarDefinitionEntryOrder
}

enum WorkCalendarDefinitionEntryOrderable {
  count
  description
  duration
  endDateTime
  interval
  startDateTime
}

input WorkCalendarDefinitionEntryPatch {
  byHour: [Int]
  byMinute: [Int]
  byMonth: [Int]
  byMonthDay: [Int]
  bySecond: [Int]
  bySetPos: [Int]
  byWeekDay: [Weekday]
  byWeekNo: [Int]
  byYearDay: [Int]
  calendarEntries: [WorkCalendarEntryRef]
  count: Int
  description: String
  duration: String
  endDateTime: DateTime
  entryType: WorkCalendarEntryType
  freq: Frequency
  hierarchyScope: EquipmentRef
  interval: Int
  isActive: Boolean
  properties: [PropertyRef]
  startDateTime: DateTime
  wkst: Weekday
  workCalendar: WorkCalendarRef
}

input WorkCalendarDefinitionEntryRef {
  byHour: [Int]
  byMinute: [Int]
  byMonth: [Int]
  byMonthDay: [Int]
  bySecond: [Int]
  bySetPos: [Int]
  byWeekDay: [Weekday]
  byWeekNo: [Int]
  byYearDay: [Int]
  calendarEntries: [WorkCalendarEntryRef]
  count: Int
  description: String
  duration: String
  endDateTime: DateTime
  entryType: WorkCalendarEntryType
  freq: Frequency
  hierarchyScope: EquipmentRef
  id: ID
  interval: Int
  isActive: Boolean
  properties: [PropertyRef]
  startDateTime: DateTime
  wkst: Weekday
  workCalendar: WorkCalendarRef
}

type WorkCalendarEntry {
  definition(
    filter: WorkCalendarDefinitionEntryFilter
  ): WorkCalendarDefinitionEntry
  description: String
  elapsedDuration: Int
  entryType: WorkCalendarEntryType!
  finishDateTime: DateTime!
  hierarchyScope(filter: EquipmentFilter): Equipment
  id: ID!
  isActive: Boolean
  properties(
    filter: PropertyFilter
    first: Int
    offset: Int
    order: PropertyOrder
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  startDateTime: DateTime!
  workCalendar(filter: WorkCalendarFilter): WorkCalendar
}

type WorkCalendarEntryAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  finishDateTimeMax: DateTime
  finishDateTimeMin: DateTime
  startDateTimeMax: DateTime
  startDateTimeMin: DateTime
}

input WorkCalendarEntryFilter {
  and: [WorkCalendarEntryFilter]
  entryType: WorkCalendarEntryType_hash
  finishDateTime: DateTimeFilter
  has: [WorkCalendarEntryHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkCalendarEntryFilter
  or: [WorkCalendarEntryFilter]
  startDateTime: DateTimeFilter
}

enum WorkCalendarEntryHasFilter {
  definition
  description
  entryType
  finishDateTime
  hierarchyScope
  isActive
  properties
  startDateTime
  workCalendar
}

input WorkCalendarEntryOrder {
  asc: WorkCalendarEntryOrderable
  desc: WorkCalendarEntryOrderable
  then: WorkCalendarEntryOrder
}

enum WorkCalendarEntryOrderable {
  description
  finishDateTime
  startDateTime
}

input WorkCalendarEntryPatch {
  definition: WorkCalendarDefinitionEntryRef
  description: String
  entryType: WorkCalendarEntryType
  finishDateTime: DateTime
  hierarchyScope: EquipmentRef
  isActive: Boolean
  properties: [PropertyRef]
  startDateTime: DateTime
  workCalendar: WorkCalendarRef
}

input WorkCalendarEntryRef {
  definition: WorkCalendarDefinitionEntryRef
  description: String
  entryType: WorkCalendarEntryType
  finishDateTime: DateTime
  hierarchyScope: EquipmentRef
  id: ID
  isActive: Boolean
  properties: [PropertyRef]
  startDateTime: DateTime
  workCalendar: WorkCalendarRef
}

enum WorkCalendarEntryType {
  PlannedBusyTime
  PlannedDowntime
  PlannedShutdown
}

input WorkCalendarEntryType_hash {
  eq: WorkCalendarEntryType
  in: [WorkCalendarEntryType]
}

input WorkCalendarFilter {
  and: [WorkCalendarFilter]
  has: [WorkCalendarHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: WorkCalendarFilter
  or: [WorkCalendarFilter]
}

enum WorkCalendarHasFilter {
  definition
  description
  entries
  equipment
  isActive
  name
}

input WorkCalendarOrder {
  asc: WorkCalendarOrderable
  desc: WorkCalendarOrderable
  then: WorkCalendarOrder
}

enum WorkCalendarOrderable {
  description
  name
}

input WorkCalendarPatch {
  definition: [WorkCalendarDefinitionEntryRef]
  description: String
  entries: [WorkCalendarEntryRef]
  equipment: [EquipmentRef]
  isActive: Boolean
}

input WorkCalendarRef {
  definition: [WorkCalendarDefinitionEntryRef]
  description: String
  entries: [WorkCalendarEntryRef]
  equipment: [EquipmentRef]
  id: ID
  isActive: Boolean
  name: String
}

type WorkflowConnection {
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  condition: String
  connectionType(filter: WorkflowConnectionTypeFilter): WorkflowConnectionType!
  createdBy(filter: UserFilter): User
  createdDateTime: DateTime
  from(filter: WorkflowNodeFilter): WorkflowNode!
  id: ID!
  isActive: Boolean
  modifiedBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  properties(
    filter: WorkflowPropertyFilter
    first: Int
    offset: Int
    order: WorkflowPropertyOrder
  ): [WorkflowProperty]
  propertiesAggregate(
    filter: WorkflowPropertyFilter
  ): WorkflowPropertyAggregateResult
  to(filter: WorkflowNodeFilter): WorkflowNode!
  workflowSpecification(
    filter: WorkflowSpecificationFilter
  ): WorkflowSpecification!
}

type WorkflowConnectionAggregateResult {
  conditionMax: String
  conditionMin: String
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
}

input WorkflowConnectionFilter {
  and: [WorkflowConnectionFilter]
  has: [WorkflowConnectionHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkflowConnectionFilter
  or: [WorkflowConnectionFilter]
}

enum WorkflowConnectionHasFilter {
  access
  condition
  connectionType
  createdBy
  createdDateTime
  from
  isActive
  modifiedBy
  modifiedDateTime
  properties
  to
  workflowSpecification
}

input WorkflowConnectionOrder {
  asc: WorkflowConnectionOrderable
  desc: WorkflowConnectionOrderable
  then: WorkflowConnectionOrder
}

enum WorkflowConnectionOrderable {
  condition
  createdDateTime
  modifiedDateTime
}

input WorkflowConnectionPatch {
  access: [ACLRef]
  condition: String
  connectionType: WorkflowConnectionTypeRef
  createdBy: UserRef
  createdDateTime: DateTime
  from: WorkflowNodeRef
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  properties: [WorkflowPropertyRef]
  to: WorkflowNodeRef
  workflowSpecification: WorkflowSpecificationRef
}

input WorkflowConnectionRef {
  access: [ACLRef]
  condition: String
  connectionType: WorkflowConnectionTypeRef
  createdBy: UserRef
  createdDateTime: DateTime
  from: WorkflowNodeRef
  id: ID
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  properties: [WorkflowPropertyRef]
  to: WorkflowNodeRef
  workflowSpecification: WorkflowSpecificationRef
}

type WorkflowConnectionType {
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  connections(
    filter: WorkflowConnectionFilter
    first: Int
    offset: Int
    order: WorkflowConnectionOrder
  ): [WorkflowConnection]
  connectionsAggregate(
    filter: WorkflowConnectionFilter
  ): WorkflowConnectionAggregateResult
  createdBy(filter: UserFilter): User
  createdDateTime: DateTime
  description: String!
  id: ID!
  isActive: Boolean
  modifiedBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  name: String!
  properties(
    filter: WorkflowPropertyFilter
    first: Int
    offset: Int
    order: WorkflowPropertyOrder
  ): [WorkflowProperty]
  propertiesAggregate(
    filter: WorkflowPropertyFilter
  ): WorkflowPropertyAggregateResult
}

type WorkflowConnectionTypeAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  descriptionMax: String
  descriptionMin: String
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  nameMax: String
  nameMin: String
}

input WorkflowConnectionTypeFilter {
  and: [WorkflowConnectionTypeFilter]
  has: [WorkflowConnectionTypeHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkflowConnectionTypeFilter
  or: [WorkflowConnectionTypeFilter]
}

enum WorkflowConnectionTypeHasFilter {
  access
  connections
  createdBy
  createdDateTime
  description
  isActive
  modifiedBy
  modifiedDateTime
  name
  properties
}

input WorkflowConnectionTypeOrder {
  asc: WorkflowConnectionTypeOrderable
  desc: WorkflowConnectionTypeOrderable
  then: WorkflowConnectionTypeOrder
}

enum WorkflowConnectionTypeOrderable {
  createdDateTime
  description
  modifiedDateTime
  name
}

input WorkflowConnectionTypePatch {
  access: [ACLRef]
  connections: [WorkflowConnectionRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  properties: [WorkflowPropertyRef]
}

input WorkflowConnectionTypeRef {
  access: [ACLRef]
  connections: [WorkflowConnectionRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  id: ID
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  properties: [WorkflowPropertyRef]
}

type WorkflowInstance {
  children(
    filter: WorkflowInstanceFilter
    first: Int
    offset: Int
    order: WorkflowInstanceOrder
  ): [WorkflowInstance]
  childrenAggregate(
    filter: WorkflowInstanceFilter
  ): WorkflowInstanceAggregateResult
  createdBy(filter: UserFilter): User
  createdDateTime: DateTime
  equipment(filter: EquipmentFilter): Equipment
  id: ID!
  modifiedBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  nodeInstances(
    filter: WorkflowNodeInstanceFilter
    first: Int
    offset: Int
    order: WorkflowNodeInstanceOrder
  ): [WorkflowNodeInstance]
  nodeInstancesAggregate(
    filter: WorkflowNodeInstanceFilter
  ): WorkflowNodeInstanceAggregateResult
  orderLines(
    filter: OrderLineFilter
    first: Int
    offset: Int
    order: OrderLineOrder
  ): [OrderLine]
  orderLinesAggregate(filter: OrderLineFilter): OrderLineAggregateResult
  parent(filter: WorkflowInstanceFilter): WorkflowInstance
  properties(
    filter: WorkflowInstancePropertyFilter
    first: Int
    offset: Int
    order: WorkflowInstancePropertyOrder
  ): [WorkflowInstanceProperty]
  propertiesAggregate(
    filter: WorkflowInstancePropertyFilter
  ): WorkflowInstancePropertyAggregateResult
  propertyInstances(
    filter: WorkflowPropertyInstanceFilter
    first: Int
    offset: Int
    order: WorkflowPropertyInstanceOrder
  ): [WorkflowPropertyInstance]
  propertyInstancesAggregate(
    filter: WorkflowPropertyInstanceFilter
  ): WorkflowPropertyInstanceAggregateResult
  status: WorkflowNodeStatus
  workflowSpecification(
    filter: WorkflowSpecificationFilter
  ): WorkflowSpecification
}

type WorkflowInstanceAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
}

input WorkflowInstanceFilter {
  and: [WorkflowInstanceFilter]
  createdDateTime: DateTimeFilter
  has: [WorkflowInstanceHasFilter]
  id: [ID!]
  not: WorkflowInstanceFilter
  or: [WorkflowInstanceFilter]
  status: WorkflowNodeStatus_hash
}

enum WorkflowInstanceHasFilter {
  children
  createdBy
  createdDateTime
  equipment
  modifiedBy
  modifiedDateTime
  nodeInstances
  orderLines
  parent
  properties
  propertyInstances
  status
  workflowSpecification
}

input WorkflowInstanceOrder {
  asc: WorkflowInstanceOrderable
  desc: WorkflowInstanceOrderable
  then: WorkflowInstanceOrder
}

enum WorkflowInstanceOrderable {
  createdDateTime
  modifiedDateTime
}

input WorkflowInstancePatch {
  children: [WorkflowInstanceRef]
  createdBy: UserRef
  createdDateTime: DateTime
  equipment: EquipmentRef
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  nodeInstances: [WorkflowNodeInstanceRef]
  orderLines: [OrderLineRef]
  parent: WorkflowInstanceRef
  properties: [WorkflowInstancePropertyRef]
  propertyInstances: [WorkflowPropertyInstanceRef]
  status: WorkflowNodeStatus
  workflowSpecification: WorkflowSpecificationRef
}

type WorkflowInstanceProperty {
  id: ID!
  key: String!
  name: String!
  values(
    filter: WorkflowPropertyValueFilter
    first: Int
    offset: Int
    order: WorkflowPropertyValueOrder
  ): [WorkflowPropertyValue]
  valuesAggregate(
    filter: WorkflowPropertyValueFilter
  ): WorkflowPropertyValueAggregateResult
  workflowInstance(filter: WorkflowInstanceFilter): WorkflowInstance
}

type WorkflowInstancePropertyAggregateResult {
  count: Int
  keyMax: String
  keyMin: String
  nameMax: String
  nameMin: String
}

input WorkflowInstancePropertyFilter {
  and: [WorkflowInstancePropertyFilter]
  has: [WorkflowInstancePropertyHasFilter]
  id: [ID!]
  key: StringHashFilter
  not: WorkflowInstancePropertyFilter
  or: [WorkflowInstancePropertyFilter]
}

enum WorkflowInstancePropertyHasFilter {
  key
  name
  values
  workflowInstance
}

input WorkflowInstancePropertyOrder {
  asc: WorkflowInstancePropertyOrderable
  desc: WorkflowInstancePropertyOrderable
  then: WorkflowInstancePropertyOrder
}

enum WorkflowInstancePropertyOrderable {
  key
  name
}

input WorkflowInstancePropertyPatch {
  name: String
  values: [WorkflowPropertyValueRef]
  workflowInstance: WorkflowInstanceRef
}

input WorkflowInstancePropertyRef {
  id: ID
  key: String
  name: String
  values: [WorkflowPropertyValueRef]
  workflowInstance: WorkflowInstanceRef
}

input WorkflowInstanceRef {
  children: [WorkflowInstanceRef]
  createdBy: UserRef
  createdDateTime: DateTime
  equipment: EquipmentRef
  id: ID
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  nodeInstances: [WorkflowNodeInstanceRef]
  orderLines: [OrderLineRef]
  parent: WorkflowInstanceRef
  properties: [WorkflowInstancePropertyRef]
  propertyInstances: [WorkflowPropertyInstanceRef]
  status: WorkflowNodeStatus
  workflowSpecification: WorkflowSpecificationRef
}

type WorkflowNode {
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  createdBy(filter: UserFilter): User
  createdDateTime: DateTime
  description: String!
  form(filter: FormFilter): Form
  height: Int
  id: ID!
  inflows(
    filter: WorkflowConnectionFilter
    first: Int
    offset: Int
    order: WorkflowConnectionOrder
  ): [WorkflowConnection]
  inflowsAggregate(
    filter: WorkflowConnectionFilter
  ): WorkflowConnectionAggregateResult
  isActive: Boolean
  modifiedBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  name: String!
  nodeInstances(
    filter: WorkflowNodeInstanceFilter
    first: Int
    offset: Int
    order: WorkflowNodeInstanceOrder
  ): [WorkflowNodeInstance]
  nodeInstancesAggregate(
    filter: WorkflowNodeInstanceFilter
  ): WorkflowNodeInstanceAggregateResult
  nodeType(filter: WorkflowNodeTypeFilter): WorkflowNodeType!
  outflows(
    filter: WorkflowConnectionFilter
    first: Int
    offset: Int
    order: WorkflowConnectionOrder
  ): [WorkflowConnection]
  outflowsAggregate(
    filter: WorkflowConnectionFilter
  ): WorkflowConnectionAggregateResult
  positionX: Int
  positionY: Int
  properties(
    filter: WorkflowPropertyFilter
    first: Int
    offset: Int
    order: WorkflowPropertyOrder
  ): [WorkflowProperty]
  propertiesAggregate(
    filter: WorkflowPropertyFilter
  ): WorkflowPropertyAggregateResult
  role(filter: RoleFilter): Role
  uiComponent: String
  width: Int
  workflowSpecification(
    filter: WorkflowSpecificationFilter
  ): WorkflowSpecification!
}

type WorkflowNodeAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  descriptionMax: String
  descriptionMin: String
  heightAvg: Float
  heightMax: Int
  heightMin: Int
  heightSum: Int
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  nameMax: String
  nameMin: String
  positionXAvg: Float
  positionXMax: Int
  positionXMin: Int
  positionXSum: Int
  positionYAvg: Float
  positionYMax: Int
  positionYMin: Int
  positionYSum: Int
  uiComponentMax: String
  uiComponentMin: String
  widthAvg: Float
  widthMax: Int
  widthMin: Int
  widthSum: Int
}

enum WorkflowNodeClass {
  EVENT_END
  EVENT_INTERMEDIATE
  EVENT_START
  GATEWAY
  SUBPROCESS
  TASK_SYSTEM
  TASK_USER
}

type WorkflowNodeEvent {
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  createdBy(filter: UserFilter): User
  createdDateTime: DateTime
  id: ID!
  isActive: Boolean
  isProcessed: Boolean
  modifiedBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  next(filter: WorkflowNodeEventFilter): WorkflowNodeEvent
  nodeInstance(filter: WorkflowNodeInstanceFilter): WorkflowNodeInstance
  previous(filter: WorkflowNodeEventFilter): WorkflowNodeEvent
  status: WorkflowNodeStatus
  value: String
}

type WorkflowNodeEventAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  valueMax: String
  valueMin: String
}

input WorkflowNodeEventFilter {
  and: [WorkflowNodeEventFilter]
  createdDateTime: DateTimeFilter
  has: [WorkflowNodeEventHasFilter]
  id: [ID!]
  isActive: Boolean
  isProcessed: Boolean
  not: WorkflowNodeEventFilter
  or: [WorkflowNodeEventFilter]
  status: WorkflowNodeStatus_hash
}

enum WorkflowNodeEventHasFilter {
  access
  createdBy
  createdDateTime
  isActive
  isProcessed
  modifiedBy
  modifiedDateTime
  next
  nodeInstance
  previous
  status
  value
}

input WorkflowNodeEventOrder {
  asc: WorkflowNodeEventOrderable
  desc: WorkflowNodeEventOrderable
  then: WorkflowNodeEventOrder
}

enum WorkflowNodeEventOrderable {
  createdDateTime
  modifiedDateTime
  value
}

input WorkflowNodeEventPatch {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  isActive: Boolean
  isProcessed: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  next: WorkflowNodeEventRef
  nodeInstance: WorkflowNodeInstanceRef
  previous: WorkflowNodeEventRef
  status: WorkflowNodeStatus
  value: String
}

input WorkflowNodeEventRef {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  id: ID
  isActive: Boolean
  isProcessed: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  next: WorkflowNodeEventRef
  nodeInstance: WorkflowNodeInstanceRef
  previous: WorkflowNodeEventRef
  status: WorkflowNodeStatus
  value: String
}

input WorkflowNodeFilter {
  and: [WorkflowNodeFilter]
  has: [WorkflowNodeHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: WorkflowNodeFilter
  or: [WorkflowNodeFilter]
}

enum WorkflowNodeHasFilter {
  access
  createdBy
  createdDateTime
  description
  form
  height
  inflows
  isActive
  modifiedBy
  modifiedDateTime
  name
  nodeInstances
  nodeType
  outflows
  positionX
  positionY
  properties
  role
  uiComponent
  width
  workflowSpecification
}

type WorkflowNodeInstance {
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  assignedUser(filter: UserFilter): User
  createdBy(filter: UserFilter): User
  createdDateTime: DateTime
  duration: Int
  events(
    filter: WorkflowNodeEventFilter
    first: Int
    offset: Int
    order: WorkflowNodeEventOrder
  ): [WorkflowNodeEvent]
  eventsAggregate(
    filter: WorkflowNodeEventFilter
  ): WorkflowNodeEventAggregateResult
  id: ID!
  isActive: Boolean
  modifiedBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  node(filter: WorkflowNodeFilter): WorkflowNode!
  status: WorkflowNodeStatus
  workflowInstance(filter: WorkflowInstanceFilter): WorkflowInstance!
}

type WorkflowNodeInstanceAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
}

input WorkflowNodeInstanceFilter {
  and: [WorkflowNodeInstanceFilter]
  createdDateTime: DateTimeFilter
  has: [WorkflowNodeInstanceHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkflowNodeInstanceFilter
  or: [WorkflowNodeInstanceFilter]
  status: WorkflowNodeStatus_hash
}

enum WorkflowNodeInstanceHasFilter {
  access
  assignedUser
  createdBy
  createdDateTime
  events
  isActive
  modifiedBy
  modifiedDateTime
  node
  status
  workflowInstance
}

input WorkflowNodeInstanceOrder {
  asc: WorkflowNodeInstanceOrderable
  desc: WorkflowNodeInstanceOrderable
  then: WorkflowNodeInstanceOrder
}

enum WorkflowNodeInstanceOrderable {
  createdDateTime
  modifiedDateTime
}

input WorkflowNodeInstancePatch {
  access: [ACLRef]
  assignedUser: UserRef
  createdBy: UserRef
  createdDateTime: DateTime
  events: [WorkflowNodeEventRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  node: WorkflowNodeRef
  status: WorkflowNodeStatus
  workflowInstance: WorkflowInstanceRef
}

input WorkflowNodeInstanceRef {
  access: [ACLRef]
  assignedUser: UserRef
  createdBy: UserRef
  createdDateTime: DateTime
  events: [WorkflowNodeEventRef]
  id: ID
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  node: WorkflowNodeRef
  status: WorkflowNodeStatus
  workflowInstance: WorkflowInstanceRef
}

input WorkflowNodeOrder {
  asc: WorkflowNodeOrderable
  desc: WorkflowNodeOrderable
  then: WorkflowNodeOrder
}

enum WorkflowNodeOrderable {
  createdDateTime
  description
  height
  modifiedDateTime
  name
  positionX
  positionY
  uiComponent
  width
}

input WorkflowNodePatch {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  form: FormRef
  height: Int
  inflows: [WorkflowConnectionRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  nodeInstances: [WorkflowNodeInstanceRef]
  nodeType: WorkflowNodeTypeRef
  outflows: [WorkflowConnectionRef]
  positionX: Int
  positionY: Int
  properties: [WorkflowPropertyRef]
  role: RoleRef
  uiComponent: String
  width: Int
  workflowSpecification: WorkflowSpecificationRef
}

input WorkflowNodeRef {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  form: FormRef
  height: Int
  id: ID
  inflows: [WorkflowConnectionRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  nodeInstances: [WorkflowNodeInstanceRef]
  nodeType: WorkflowNodeTypeRef
  outflows: [WorkflowConnectionRef]
  positionX: Int
  positionY: Int
  properties: [WorkflowPropertyRef]
  role: RoleRef
  uiComponent: String
  width: Int
  workflowSpecification: WorkflowSpecificationRef
}

enum WorkflowNodeStatus {
  CLAIMED
  COMPLETED
  CREATED
  PAUSED
  STARTED
}

input WorkflowNodeStatus_hash {
  eq: WorkflowNodeStatus
  in: [WorkflowNodeStatus]
}

type WorkflowNodeType {
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  createdBy(filter: UserFilter): User
  createdDateTime: DateTime
  description: String!
  id: ID!
  isActive: Boolean
  modifiedBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  name: String!
  nodeClass: WorkflowNodeClass!
  nodes(
    filter: WorkflowNodeFilter
    first: Int
    offset: Int
    order: WorkflowNodeOrder
  ): [WorkflowNode]
  nodesAggregate(filter: WorkflowNodeFilter): WorkflowNodeAggregateResult
  properties(
    filter: WorkflowPropertyFilter
    first: Int
    offset: Int
    order: WorkflowPropertyOrder
  ): [WorkflowProperty]
  propertiesAggregate(
    filter: WorkflowPropertyFilter
  ): WorkflowPropertyAggregateResult
}

type WorkflowNodeTypeAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  descriptionMax: String
  descriptionMin: String
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  nameMax: String
  nameMin: String
}

input WorkflowNodeTypeFilter {
  and: [WorkflowNodeTypeFilter]
  has: [WorkflowNodeTypeHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkflowNodeTypeFilter
  or: [WorkflowNodeTypeFilter]
}

enum WorkflowNodeTypeHasFilter {
  access
  createdBy
  createdDateTime
  description
  isActive
  modifiedBy
  modifiedDateTime
  name
  nodeClass
  nodes
  properties
}

input WorkflowNodeTypeOrder {
  asc: WorkflowNodeTypeOrderable
  desc: WorkflowNodeTypeOrderable
  then: WorkflowNodeTypeOrder
}

enum WorkflowNodeTypeOrderable {
  createdDateTime
  description
  modifiedDateTime
  name
}

input WorkflowNodeTypePatch {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  nodeClass: WorkflowNodeClass
  nodes: [WorkflowNodeRef]
  properties: [WorkflowPropertyRef]
}

input WorkflowNodeTypeRef {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  id: ID
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  nodeClass: WorkflowNodeClass
  nodes: [WorkflowNodeRef]
  properties: [WorkflowPropertyRef]
}

type WorkflowProperty {
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  connection(filter: WorkflowConnectionFilter): WorkflowConnection
  connectionType(filter: WorkflowConnectionTypeFilter): WorkflowConnectionType
  createdBy(filter: UserFilter): User
  createdDateTime: DateTime
  dataType: DataType
  definedBy(filter: WorkflowPropertyFilter): WorkflowProperty
  description: String!
  id: ID!
  instances(
    filter: WorkflowPropertyInstanceFilter
    first: Int
    offset: Int
    order: WorkflowPropertyInstanceOrder
  ): [WorkflowPropertyInstance]
  instancesAggregate(
    filter: WorkflowPropertyInstanceFilter
  ): WorkflowPropertyInstanceAggregateResult
  isActive: Boolean
  modifiedBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  name: String!
  node(filter: WorkflowNodeFilter): WorkflowNode
  nodeType(filter: WorkflowNodeTypeFilter): WorkflowNodeType
  propertyType: WorkflowPropertyType!
  unitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure
  value: String
}

type WorkflowPropertyAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  descriptionMax: String
  descriptionMin: String
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  nameMax: String
  nameMin: String
  valueMax: String
  valueMin: String
}

input WorkflowPropertyFilter {
  and: [WorkflowPropertyFilter]
  description: StringHashFilter
  has: [WorkflowPropertyHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: WorkflowPropertyFilter
  or: [WorkflowPropertyFilter]
}

enum WorkflowPropertyHasFilter {
  access
  connection
  connectionType
  createdBy
  createdDateTime
  dataType
  definedBy
  description
  instances
  isActive
  modifiedBy
  modifiedDateTime
  name
  node
  nodeType
  propertyType
  unitOfMeasure
  value
}

type WorkflowPropertyInstance {
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  createdBy(filter: UserFilter): User
  createdDateTime: DateTime
  id: ID!
  isActive: Boolean
  modifiedBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  values(
    filter: WorkflowPropertyValueFilter
    first: Int
    offset: Int
    order: WorkflowPropertyValueOrder
  ): [WorkflowPropertyValue]
  valuesAggregate(
    filter: WorkflowPropertyValueFilter
  ): WorkflowPropertyValueAggregateResult
  workflowInstance(filter: WorkflowInstanceFilter): WorkflowInstance
  workflowProperty(filter: WorkflowPropertyFilter): WorkflowProperty
}

type WorkflowPropertyInstanceAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
}

input WorkflowPropertyInstanceFilter {
  and: [WorkflowPropertyInstanceFilter]
  has: [WorkflowPropertyInstanceHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkflowPropertyInstanceFilter
  or: [WorkflowPropertyInstanceFilter]
}

enum WorkflowPropertyInstanceHasFilter {
  access
  createdBy
  createdDateTime
  isActive
  modifiedBy
  modifiedDateTime
  values
  workflowInstance
  workflowProperty
}

input WorkflowPropertyInstanceOrder {
  asc: WorkflowPropertyInstanceOrderable
  desc: WorkflowPropertyInstanceOrderable
  then: WorkflowPropertyInstanceOrder
}

enum WorkflowPropertyInstanceOrderable {
  createdDateTime
  modifiedDateTime
}

input WorkflowPropertyInstancePatch {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  values: [WorkflowPropertyValueRef]
  workflowInstance: WorkflowInstanceRef
  workflowProperty: WorkflowPropertyRef
}

input WorkflowPropertyInstanceRef {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  id: ID
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  values: [WorkflowPropertyValueRef]
  workflowInstance: WorkflowInstanceRef
  workflowProperty: WorkflowPropertyRef
}

input WorkflowPropertyOrder {
  asc: WorkflowPropertyOrderable
  desc: WorkflowPropertyOrderable
  then: WorkflowPropertyOrder
}

enum WorkflowPropertyOrderable {
  createdDateTime
  description
  modifiedDateTime
  name
  value
}

input WorkflowPropertyPatch {
  access: [ACLRef]
  connection: WorkflowConnectionRef
  connectionType: WorkflowConnectionTypeRef
  createdBy: UserRef
  createdDateTime: DateTime
  dataType: DataType
  definedBy: WorkflowPropertyRef
  description: String
  instances: [WorkflowPropertyInstanceRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  node: WorkflowNodeRef
  nodeType: WorkflowNodeTypeRef
  propertyType: WorkflowPropertyType
  unitOfMeasure: UnitOfMeasureRef
  value: String
}

input WorkflowPropertyRef {
  access: [ACLRef]
  connection: WorkflowConnectionRef
  connectionType: WorkflowConnectionTypeRef
  createdBy: UserRef
  createdDateTime: DateTime
  dataType: DataType
  definedBy: WorkflowPropertyRef
  description: String
  id: ID
  instances: [WorkflowPropertyInstanceRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  node: WorkflowNodeRef
  nodeType: WorkflowNodeTypeRef
  propertyType: WorkflowPropertyType
  unitOfMeasure: UnitOfMeasureRef
  value: String
}

enum WorkflowPropertyType {
  CONFIG
  STATIC
  VARIABLE
}

type WorkflowPropertyValue {
  createdBy(filter: UserFilter): User
  createdDateTime: DateTime
  id: ID!
  modifiedBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  next(filter: WorkflowPropertyValueFilter): WorkflowPropertyValue
  previous(filter: WorkflowPropertyValueFilter): WorkflowPropertyValue
  propertyInstance(
    filter: WorkflowPropertyInstanceFilter
  ): WorkflowPropertyInstance!
  value: String
}

type WorkflowPropertyValueAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  valueMax: String
  valueMin: String
}

input WorkflowPropertyValueFilter {
  and: [WorkflowPropertyValueFilter]
  has: [WorkflowPropertyValueHasFilter]
  id: [ID!]
  not: WorkflowPropertyValueFilter
  or: [WorkflowPropertyValueFilter]
}

enum WorkflowPropertyValueHasFilter {
  createdBy
  createdDateTime
  modifiedBy
  modifiedDateTime
  next
  previous
  propertyInstance
  value
}

input WorkflowPropertyValueOrder {
  asc: WorkflowPropertyValueOrderable
  desc: WorkflowPropertyValueOrderable
  then: WorkflowPropertyValueOrder
}

enum WorkflowPropertyValueOrderable {
  createdDateTime
  modifiedDateTime
  value
}

input WorkflowPropertyValuePatch {
  createdBy: UserRef
  createdDateTime: DateTime
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  next: WorkflowPropertyValueRef
  previous: WorkflowPropertyValueRef
  propertyInstance: WorkflowPropertyInstanceRef
  value: String
}

input WorkflowPropertyValueRef {
  createdBy: UserRef
  createdDateTime: DateTime
  id: ID
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  next: WorkflowPropertyValueRef
  previous: WorkflowPropertyValueRef
  propertyInstance: WorkflowPropertyInstanceRef
  value: String
}

type WorkflowSpecification {
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  connections(
    filter: WorkflowConnectionFilter
    first: Int
    offset: Int
    order: WorkflowConnectionOrder
  ): [WorkflowConnection]
  connectionsAggregate(
    filter: WorkflowConnectionFilter
  ): WorkflowConnectionAggregateResult
  createdBy(filter: UserFilter): User
  createdDateTime: DateTime
  description: String!
  id: ID!
  instances(
    filter: WorkflowInstanceFilter
    first: Int
    offset: Int
    order: WorkflowInstanceOrder
  ): [WorkflowInstance]
  instancesAggregate(
    filter: WorkflowInstanceFilter
  ): WorkflowInstanceAggregateResult
  isActive: Boolean
  modifiedBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  name: String!
  nodes(
    filter: WorkflowNodeFilter
    first: Int
    offset: Int
    order: WorkflowNodeOrder
  ): [WorkflowNode]
  nodesAggregate(filter: WorkflowNodeFilter): WorkflowNodeAggregateResult
}

type WorkflowSpecificationAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  descriptionMax: String
  descriptionMin: String
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  nameMax: String
  nameMin: String
}

input WorkflowSpecificationFilter {
  and: [WorkflowSpecificationFilter]
  has: [WorkflowSpecificationHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: WorkflowSpecificationFilter
  or: [WorkflowSpecificationFilter]
}

enum WorkflowSpecificationHasFilter {
  access
  connections
  createdBy
  createdDateTime
  description
  instances
  isActive
  modifiedBy
  modifiedDateTime
  name
  nodes
}

input WorkflowSpecificationOrder {
  asc: WorkflowSpecificationOrderable
  desc: WorkflowSpecificationOrderable
  then: WorkflowSpecificationOrder
}

enum WorkflowSpecificationOrderable {
  createdDateTime
  description
  modifiedDateTime
  name
}

input WorkflowSpecificationPatch {
  access: [ACLRef]
  connections: [WorkflowConnectionRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  instances: [WorkflowInstanceRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  nodes: [WorkflowNodeRef]
}

input WorkflowSpecificationRef {
  access: [ACLRef]
  connections: [WorkflowConnectionRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  id: ID
  instances: [WorkflowInstanceRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  nodes: [WorkflowNodeRef]
}

# An identification of the resources and workflow required to perform a specified unit of work
# shall be defined as a work definition. The work definition may apply to production, maintenance, quality and inventory
# activities.
enum WorkType {
  Inventory
  Maintenance
  Mixed
  Production
  Quality
}

input WorkType_hash {
  eq: WorkType
  in: [WorkType]
}
