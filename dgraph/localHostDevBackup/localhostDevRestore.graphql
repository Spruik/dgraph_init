directive @cacheControl(maxAge: Int!) on QUERY

directive @cascade(fields: [String]) on FIELD

enum AccessLevel {
  VIEWER
  MODERATOR
  OWNER
}

type AccessRight {
  id: ID!
  name: AccessRights
  forRole(filter: RoleFilter): Role
  isActive: Boolean
}

type AccessRightAggregateResult {
  count: Int
}

input AccessRightFilter {
  id: [ID!]
  name: AccessRights_hash
  has: [AccessRightHasFilter]
  and: [AccessRightFilter]
  or: [AccessRightFilter]
  not: AccessRightFilter
}

enum AccessRightHasFilter {
  name
  forRole
  isActive
}

input AccessRightPatch {
  name: AccessRights
  forRole: RoleRef
  isActive: Boolean
}

input AccessRightRef {
  id: ID
  name: AccessRights
  forRole: RoleRef
  isActive: Boolean
}

enum AccessRights {
  isAdmin
  getUser
  queryUser
  aggregateUser
  getUserRole
  queryUserRole
  aggregateUserRole
  getRole
  queryRole
  aggregateRole
  getAccessRight
  queryAccessRight
  aggregateAccessRight
  getACL
  queryACL
  aggregateACL
  getMenu
  queryMenu
  aggregateMenu
  getOperationsRequest
  queryOperationsRequest
  aggregateOperationsRequest
  getRequestState
  queryRequestState
  aggregateRequestState
  getOperationsDefinition
  queryOperationsDefinition
  aggregateOperationsDefinition
  getBillOfMaterial
  queryBillOfMaterial
  aggregateBillOfMaterial
  getOperationsSegment
  queryOperationsSegment
  aggregateOperationsSegment
  getTransitionEventRuleset
  queryTransitionEventRuleset
  aggregateTransitionEventRuleset
  getStateEventRuleset
  queryStateEventRuleset
  aggregateStateEventRuleset
  getMaterialEventRuleset
  queryMaterialEventRuleset
  aggregateMaterialEventRuleset
  getOrderStartRuleset
  queryOrderStartRuleset
  aggregateOrderStartRuleset
  getSegmentInvoiceSetting
  querySegmentInvoiceSetting
  aggregateSegmentInvoiceSetting
  getSegmentDependency
  querySegmentDependency
  aggregateSegmentDependency
  getJobOrder
  queryJobOrder
  aggregateJobOrder
  getJobResponse
  queryJobResponse
  aggregateJobResponse
  getEventLog
  queryEventLog
  aggregateEventLog
  getQuantityLog
  queryQuantityLog
  aggregateQuantityLog
  getEquipmentSpecification
  queryEquipmentSpecification
  aggregateEquipmentSpecification
  getMaterialSpecification
  queryMaterialSpecification
  aggregateMaterialSpecification
  getPersonnelSpecification
  queryPersonnelSpecification
  aggregatePersonnelSpecification
  getEquipment
  queryEquipment
  aggregateEquipment
  getEquipmentNameAlias
  queryEquipmentNameAlias
  aggregateEquipmentNameAlias
  getPropertyNameAlias
  queryPropertyNameAlias
  aggregatePropertyNameAlias
  getPropertyValueAlias
  queryPropertyValueAlias
  aggregatePropertyValueAlias
  getEquipmentReasonOverride
  queryEquipmentReasonOverride
  aggregateEquipmentReasonOverride
  getEquipmentClass
  queryEquipmentClass
  aggregateEquipmentClass
  getProperty
  queryProperty
  aggregateProperty
  getEquipmentPropertyOverride
  queryEquipmentPropertyOverride
  aggregateEquipmentPropertyOverride
  getEventDefinition
  queryEventDefinition
  aggregateEventDefinition
  getPayloadFieldDefinition
  queryPayloadFieldDefinition
  aggregatePayloadFieldDefinition
  getReason
  queryReason
  aggregateReason
  getReasonCategory
  queryReasonCategory
  aggregateReasonCategory
  getMaterialClass
  queryMaterialClass
  aggregateMaterialClass
  getMaterialDefinition
  queryMaterialDefinition
  aggregateMaterialDefinition
  getMaterialAlternate
  queryMaterialAlternate
  aggregateMaterialAlternate
  getCarrier
  queryCarrier
  aggregateCarrier
  getMaterialLot
  queryMaterialLot
  aggregateMaterialLot
  getMaterialSubLot
  queryMaterialSubLot
  aggregateMaterialSubLot
  getMaterialUnit
  queryMaterialUnit
  aggregateMaterialUnit
  getMaterialEquipment
  queryMaterialEquipment
  aggregateMaterialEquipment
  getUnitOfMeasure
  queryUnitOfMeasure
  aggregateUnitOfMeasure
  getUnitOfMeasureConversion
  queryUnitOfMeasureConversion
  aggregateUnitOfMeasureConversion
  getMaterialStatus
  queryMaterialStatus
  aggregateMaterialStatus
  getMaterialStateModel
  queryMaterialStateModel
  aggregateMaterialStateModel
  getMaterialStateTransition
  queryMaterialStateTransition
  aggregateMaterialStateTransition
  getPersonnelClass
  queryPersonnelClass
  aggregatePersonnelClass
  getPerson
  queryPerson
  aggregatePerson
  getTestSpecification
  queryTestSpecification
  aggregateTestSpecification
  getTestResult
  queryTestResult
  aggregateTestResult
  getWorkCalendarDefinitionEntry
  queryWorkCalendarDefinitionEntry
  aggregateWorkCalendarDefinitionEntry
  getWorkCalendarEntry
  queryWorkCalendarEntry
  aggregateWorkCalendarEntry
  getWorkCalendar
  queryWorkCalendar
  aggregateWorkCalendar
  getWorkflowSpecification
  queryWorkflowSpecification
  aggregateWorkflowSpecification
  getWorkflowInstance
  queryWorkflowInstance
  aggregateWorkflowInstance
  getWorkflowNode
  queryWorkflowNode
  aggregateWorkflowNode
  getWorkflowNodeInstance
  queryWorkflowNodeInstance
  aggregateWorkflowNodeInstance
  getWorkflowNodeEvent
  queryWorkflowNodeEvent
  aggregateWorkflowNodeEvent
  getWorkflowNodeType
  queryWorkflowNodeType
  aggregateWorkflowNodeType
  getWorkflowConnection
  queryWorkflowConnection
  aggregateWorkflowConnection
  getWorkflowConnectionType
  queryWorkflowConnectionType
  aggregateWorkflowConnectionType
  getWorkflowProperty
  queryWorkflowProperty
  aggregateWorkflowProperty
  getWorkflowPropertyInstance
  queryWorkflowPropertyInstance
  aggregateWorkflowPropertyInstance
  getWorkflowPropertyValue
  queryWorkflowPropertyValue
  aggregateWorkflowPropertyValue
  getForm
  queryForm
  aggregateForm
  getPartner
  queryPartner
  aggregatePartner
  getInventoryHandlingPolicy
  queryInventoryHandlingPolicy
  aggregateInventoryHandlingPolicy
  getInventoryHandlingRule
  queryInventoryHandlingRule
  aggregateInventoryHandlingRule
  getAddress
  queryAddress
  aggregateAddress
  getOrder
  queryOrder
  aggregateOrder
  getOrderLine
  queryOrderLine
  aggregateOrderLine
  getShipment
  queryShipment
  aggregateShipment
  getShipmentItem
  queryShipmentItem
  aggregateShipmentItem
  getBox
  queryBox
  aggregateBox
  getGeneralLedgerAccount
  queryGeneralLedgerAccount
  aggregateGeneralLedgerAccount
  addUser
  updateUser
  deleteUser
  addUserRole
  updateUserRole
  deleteUserRole
  addRole
  updateRole
  deleteRole
  addAccessRight
  updateAccessRight
  deleteAccessRight
  addACL
  updateACL
  deleteACL
  addMenu
  updateMenu
  deleteMenu
  addOperationsRequest
  updateOperationsRequest
  deleteOperationsRequest
  addRequestState
  updateRequestState
  deleteRequestState
  addOperationsDefinition
  updateOperationsDefinition
  deleteOperationsDefinition
  addBillOfMaterial
  updateBillOfMaterial
  deleteBillOfMaterial
  addOperationsSegment
  updateOperationsSegment
  deleteOperationsSegment
  addTransitionEventRuleset
  updateTransitionEventRuleset
  deleteTransitionEventRuleset
  addStateEventRuleset
  updateStateEventRuleset
  deleteStateEventRuleset
  addMaterialEventRuleset
  updateMaterialEventRuleset
  deleteMaterialEventRuleset
  addOrderStartRuleset
  updateOrderStartRuleset
  deleteOrderStartRuleset
  addSegmentInvoiceSetting
  updateSegmentInvoiceSetting
  deleteSegmentInvoiceSetting
  addSegmentDependency
  updateSegmentDependency
  deleteSegmentDependency
  addJobOrder
  updateJobOrder
  deleteJobOrder
  addJobResponse
  updateJobResponse
  deleteJobResponse
  addEventLog
  updateEventLog
  deleteEventLog
  addQuantityLog
  updateQuantityLog
  deleteQuantityLog
  addEquipmentSpecification
  updateEquipmentSpecification
  deleteEquipmentSpecification
  addMaterialSpecification
  updateMaterialSpecification
  deleteMaterialSpecification
  addPersonnelSpecification
  updatePersonnelSpecification
  deletePersonnelSpecification
  addEquipment
  updateEquipment
  deleteEquipment
  addEquipmentNameAlias
  updateEquipmentNameAlias
  deleteEquipmentNameAlias
  addPropertyNameAlias
  updatePropertyNameAlias
  deletePropertyNameAlias
  addPropertyValueAlias
  updatePropertyValueAlias
  deletePropertyValueAlias
  addEquipmentReasonOverride
  updateEquipmentReasonOverride
  deleteEquipmentReasonOverride
  addEquipmentClass
  updateEquipmentClass
  deleteEquipmentClass
  addProperty
  updateProperty
  deleteProperty
  addEquipmentPropertyOverride
  updateEquipmentPropertyOverride
  deleteEquipmentPropertyOverride
  addEventDefinition
  updateEventDefinition
  deleteEventDefinition
  addPayloadFieldDefinition
  updatePayloadFieldDefinition
  deletePayloadFieldDefinition
  addReason
  updateReason
  deleteReason
  addReasonCategory
  updateReasonCategory
  deleteReasonCategory
  addMaterialClass
  updateMaterialClass
  deleteMaterialClass
  addMaterialDefinition
  updateMaterialDefinition
  deleteMaterialDefinition
  addMaterialAlternate
  updateMaterialAlternate
  deleteMaterialAlternate
  addCarrier
  updateCarrier
  deleteCarrier
  addMaterialLot
  updateMaterialLot
  deleteMaterialLot
  addMaterialSubLot
  updateMaterialSubLot
  deleteMaterialSubLot
  addMaterialUnit
  updateMaterialUnit
  deleteMaterialUnit
  addMaterialEquipment
  updateMaterialEquipment
  deleteMaterialEquipment
  addUnitOfMeasure
  updateUnitOfMeasure
  deleteUnitOfMeasure
  addUnitOfMeasureConversion
  updateUnitOfMeasureConversion
  deleteUnitOfMeasureConversion
  addMaterialStatus
  updateMaterialStatus
  deleteMaterialStatus
  addMaterialStateModel
  updateMaterialStateModel
  deleteMaterialStateModel
  addMaterialStateTransition
  updateMaterialStateTransition
  deleteMaterialStateTransition
  addPersonnelClass
  updatePersonnelClass
  deletePersonnelClass
  addPerson
  updatePerson
  deletePerson
  addTestSpecification
  updateTestSpecification
  deleteTestSpecification
  addTestResult
  updateTestResult
  deleteTestResult
  addWorkCalendarDefinitionEntry
  updateWorkCalendarDefinitionEntry
  deleteWorkCalendarDefinitionEntry
  addWorkCalendarEntry
  updateWorkCalendarEntry
  deleteWorkCalendarEntry
  addWorkCalendar
  updateWorkCalendar
  deleteWorkCalendar
  addWorkflowSpecification
  updateWorkflowSpecification
  deleteWorkflowSpecification
  addWorkflowInstance
  updateWorkflowInstance
  deleteWorkflowInstance
  addWorkflowNode
  updateWorkflowNode
  deleteWorkflowNode
  addWorkflowNodeInstance
  updateWorkflowNodeInstance
  deleteWorkflowNodeInstance
  addWorkflowNodeEvent
  updateWorkflowNodeEvent
  deleteWorkflowNodeEvent
  addWorkflowNodeType
  updateWorkflowNodeType
  deleteWorkflowNodeType
  addWorkflowConnection
  updateWorkflowConnection
  deleteWorkflowConnection
  addWorkflowConnectionType
  updateWorkflowConnectionType
  deleteWorkflowConnectionType
  addWorkflowProperty
  updateWorkflowProperty
  deleteWorkflowProperty
  addWorkflowPropertyInstance
  updateWorkflowPropertyInstance
  deleteWorkflowPropertyInstance
  addWorkflowPropertyValue
  updateWorkflowPropertyValue
  deleteWorkflowPropertyValue
  addForm
  updateForm
  deleteForm
  addPartner
  updatePartner
  deletePartner
  addInventoryHandlingPolicy
  updateInventoryHandlingPolicy
  deleteInventoryHandlingPolicy
  addInventoryHandlingRule
  updateInventoryHandlingRule
  deleteInventoryHandlingRule
  addAddress
  updateAddress
  deleteAddress
  addOrder
  updateOrder
  deleteOrder
  addOrderLine
  updateOrderLine
  deleteOrderLine
  addShipment
  updateShipment
  deleteShipment
  addShipmentItem
  updateShipmentItem
  deleteShipmentItem
  addBox
  updateBox
  deleteBox
  addGeneralLedgerAccount
  updateGeneralLedgerAccount
  deleteGeneralLedgerAccount
}

input AccessRights_hash {
  eq: AccessRights
  in: [AccessRights]
}

type ACL {
  id: ID!
  isActive: Boolean
  level: AccessLevel
  grants(filter: RoleFilter): Role
}

type ACLAggregateResult {
  count: Int
}

input ACLFilter {
  id: [ID!]
  isActive: Boolean
  has: [ACLHasFilter]
  and: [ACLFilter]
  or: [ACLFilter]
  not: ACLFilter
}

enum ACLHasFilter {
  isActive
  level
  grants
}

input ACLPatch {
  isActive: Boolean
  level: AccessLevel
  grants: RoleRef
}

input ACLRef {
  id: ID
  isActive: Boolean
  level: AccessLevel
  grants: RoleRef
}

input AddAccessRightInput {
  name: AccessRights
  forRole: RoleRef
  isActive: Boolean
}

type AddAccessRightPayload {
  accessRight(filter: AccessRightFilter, first: Int, offset: Int): [AccessRight]
  numUids: Int
}

input AddACLInput {
  isActive: Boolean
  level: AccessLevel
  grants: RoleRef
}

type AddACLPayload {
  aCL(filter: ACLFilter, first: Int, offset: Int): [ACL]
  numUids: Int
}

input AddAddressInput {
  isActive: Boolean
  name: String
  street1: String
  street2: String
  number: String
  city: String
  state: String
  postCode: String
  countryCode: String
}

type AddAddressPayload {
  address(
    filter: AddressFilter
    order: AddressOrder
    first: Int
    offset: Int
  ): [Address]
  numUids: Int
}

input AddBillOfMaterialInput {
  isActive: Boolean
  name: String!
  version: String!
  description: String
  materialSpecifications: [MaterialSpecificationRef]
  operationsDefinition: OperationsDefinitionRef
}

type AddBillOfMaterialPayload {
  billOfMaterial(
    filter: BillOfMaterialFilter
    order: BillOfMaterialOrder
    first: Int
    offset: Int
  ): [BillOfMaterial]
  numUids: Int
}

input AddBoxInput {
  name: String
  sizeHeightCm: Int
  sizeWidthCm: Int
  sizeDepthCm: Int
}

type AddBoxPayload {
  box(filter: BoxFilter, order: BoxOrder, first: Int, offset: Int): [Box]
  numUids: Int
}

input AddCarrierInput {
  code: String!
  isActive: Boolean
  storageLocation: EquipmentRef!
  status: MaterialStatusRef!
  barcodeImage: String
  owner: PartnerRef
}




type AddCarrierPayload {
  carrier(
    filter: CarrierFilter
    order: CarrierOrder
    first: Int
    offset: Int
  ): [Carrier]
  numUids: Int
}

input AddDashboardConfigInput {
  name: String!
  isActive: Boolean
  panels: [DashboardPanelConfigRef]
}

type AddDashboardConfigPayload {
  dashboardConfig(
    filter: DashboardConfigFilter
    order: DashboardConfigOrder
    first: Int
    offset: Int
  ): [DashboardConfig]
  numUids: Int
}

input AddDashboardPanelConfigInput {
  dashboard: DashboardConfigRef
  widgetName: String
  properties: [DashboardWidgetConfigPropertyRef]
  x: Int
  y: Int
  w: Int
  h: Int
}

type AddDashboardPanelConfigPayload {
  dashboardPanelConfig(
    filter: DashboardPanelConfigFilter
    order: DashboardPanelConfigOrder
    first: Int
    offset: Int
  ): [DashboardPanelConfig]
  numUids: Int
}

input AddDashboardWidgetConfigPropertyInput {
  panel: DashboardPanelConfigRef
  key: String!
  value: String!
}

type AddDashboardWidgetConfigPropertyPayload {
  dashboardWidgetConfigProperty(
    filter: DashboardWidgetConfigPropertyFilter
    order: DashboardWidgetConfigPropertyOrder
    first: Int
    offset: Int
  ): [DashboardWidgetConfigProperty]
  numUids: Int
}

input AddDeliveryInput {
  dateTime: DateTime!
  shipments: [ShipmentRef]
  location: EquipmentRef
  operator: UserRef
  partner: PartnerRef
  transportCompany: TransportCompany
  transportCompanyDeliveryId: String
}

type AddDeliveryPayload {
  delivery(
    filter: DeliveryFilter
    order: DeliveryOrder
    first: Int
    offset: Int
  ): [Delivery]
  numUids: Int
}

input AddEquipmentActualInput {
  isActive: Boolean
  jobResponse: JobResponseRef!
  equipment: EquipmentRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type AddEquipmentActualPayload {
  equipmentActual(
    filter: EquipmentActualFilter
    order: EquipmentActualOrder
    first: Int
    offset: Int
  ): [EquipmentActual]
  numUids: Int
}

input AddEquipmentClassInput {
  isActive: Boolean
  name: String!
  label: String
  displayName: String
  description: String
  parent: EquipmentClassRef
  children: [EquipmentClassRef]
  equipments: [EquipmentRef]
  properties: [PropertyRef]
  eventDefinitions: [EventDefinitionRef]
  equipmentSpecifications: [EquipmentSpecificationRef]
  reasons: [ReasonRef]
  equipmentLevel: EquipmentElementLevel
  addressTemplate: String
  image: String
  dashboardConfig: DashboardConfigRef
}

type AddEquipmentClassPayload {
  equipmentClass(
    filter: EquipmentClassFilter
    order: EquipmentClassOrder
    first: Int
    offset: Int
  ): [EquipmentClass]
  numUids: Int
}

input AddEquipmentInput {
  isActive: Boolean
  userRoles: [UserRoleRef]
  name: String!
  label: String
  displayName: String
  description: String
  erpAssetID: String
  parent: EquipmentRef
  children: [EquipmentRef]
  equipmentClass: EquipmentClassRef
  equipmentLevel: EquipmentElementLevel
  equipmentActual: [EquipmentActualRef]
  properties: [PropertyRef]
  propertyNameAliases: [PropertyNameAliasRef]
  carriers: [CarrierRef]
  materialSubLots: [MaterialSubLotRef]
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  operationsRequests: [OperationsRequestRef]
  dataProvider: DataProvider
  dataProviderConnection: String
  addressTemplate: String
  timeZoneName: String
  workSpecifications: [EquipmentSpecificationRef]
  workflowInstances: [WorkflowInstanceRef]
  workCalendar: WorkCalendarRef
  jobResponses: [JobResponseRef]
  jobOrders: [JobOrderRef]
  shipments: [ShipmentRef]
  shipmentItems: [ShipmentItemRef]
  orders: [OrderRef]
  events: [EventLogRef]
  quantities: [QuantityLogRef]
  allowAdhocWorklog: Boolean
  reasons: [ReasonRef]
  reasonOverrides: [EquipmentReasonOverrideRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  mpmEnableJobInterlock: Boolean
  mpmPermissiveOutputName: String
  mpmEnableAutoIdentMatching: Boolean
  mpmAutoIdentMatchSource: String
  mpmEnableSetupStartDetection: Boolean
  mpmEnableSetupCloseDetection: Boolean
  mpmEnableORCWarning: Boolean
  mpmORCWarnTrigger: mpmORCWarnTriggers
  mpmEnableORCRevokePermissive: Boolean
  mpmORCRevokePermissiveTrigger: mpmORCRevokeTriggers
  mpmEnableORCBlockNextOrder: Boolean
  mpmEnableCallMaintenanceEvent: Boolean
  mpmEnableMaintenanceHandover: Boolean
  mpmEnableManualShiftStart: Boolean
  mpmEnableManualShiftEnd: Boolean
  mpmEnableManualBreak: Boolean
  mpmEnableManualPlannedMaint: Boolean
  ocsEnabled: Boolean
  ocsPageState: String
  ocsWorkflowSelector: String
  ocsChosenStopTime: DateTime
  inflows: [EquipmentRelationRef]
  outflows: [EquipmentRelationRef]
}

input AddEquipmentNameAliasInput {
  equipment: EquipmentRef!
  alias: String!
  system: String!
}

type AddEquipmentNameAliasPayload {
  equipmentNameAlias(
    filter: EquipmentNameAliasFilter
    order: EquipmentNameAliasOrder
    first: Int
    offset: Int
  ): [EquipmentNameAlias]
  numUids: Int
}

type AddEquipmentPayload {
  equipment(
    filter: EquipmentFilter
    order: EquipmentOrder
    first: Int
    offset: Int
  ): [Equipment]
  numUids: Int
}

input AddEquipmentPropertyOverrideInput {
  isActive: Boolean
  equipment: EquipmentRef!
  property: PropertyRef!
  address: String
  expression: String
  value: String
  storeHistory: Boolean
  ignore: Boolean
}

type AddEquipmentPropertyOverridePayload {
  equipmentPropertyOverride(
    filter: EquipmentPropertyOverrideFilter
    order: EquipmentPropertyOverrideOrder
    first: Int
    offset: Int
  ): [EquipmentPropertyOverride]
  numUids: Int
}

input AddEquipmentReasonOverrideInput {
  isActive: Boolean
  equipment: EquipmentRef
  reason: ReasonRef
  ignore: Boolean
  standardValue: Float
}

type AddEquipmentReasonOverridePayload {
  equipmentReasonOverride(
    filter: EquipmentReasonOverrideFilter
    order: EquipmentReasonOverrideOrder
    first: Int
    offset: Int
  ): [EquipmentReasonOverride]
  numUids: Int
}

input AddEquipmentRelationInput {
  isActive: Boolean
  from: EquipmentRef!
  to: EquipmentRef
  type: EquipmentRelationshipType!
}

type AddEquipmentRelationPayload {
  equipmentRelation(
    filter: EquipmentRelationFilter
    first: Int
    offset: Int
  ): [EquipmentRelation]
  numUids: Int
}

input AddEquipmentSpecificationInput {
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  description: String
  quantity: Float
  uom: UnitOfMeasureRef
}

type AddEquipmentSpecificationPayload {
  equipmentSpecification(
    filter: EquipmentSpecificationFilter
    order: EquipmentSpecificationOrder
    first: Int
    offset: Int
  ): [EquipmentSpecification]
  numUids: Int
}

input AddEventDefinitionInput {
  isActive: Boolean
  name: String!
  messageClass: MessageClass!
  triggerProperties: [PropertyRef]
  triggerExpression: String!
  delayOption: Boolean
  delayTime: Int
  payloadProperties: [PropertyRef]
  payloadFields: [PayloadFieldDefinitionRef]
  orderStartRuleset: OrderStartRulesetRef
  stateEventRuleset: StateEventRulesetRef
  materialEventRuleset: MaterialEventRulesetRef
  transitionEventRuleset: TransitionEventRulesetRef
  equipmentClass: EquipmentClassRef
}

type AddEventDefinitionPayload {
  eventDefinition(
    filter: EventDefinitionFilter
    order: EventDefinitionOrder
    first: Int
    offset: Int
  ): [EventDefinition]
  numUids: Int
}

input AddEventLogInput {
  isActive: Boolean
  jobResponse: JobResponseRef!
  equipment: EquipmentRef
  startDateTime: DateTime
  endDateTime: DateTime
  duration: Float
  reasonCode: String
  reasonText: String
  reasonCategoryCode: String
  reasonValue: Float
  reasonValueUoM: UnitOfMeasureRef
  comments: String
}

type AddEventLogPayload {
  eventLog(
    filter: EventLogFilter
    order: EventLogOrder
    first: Int
    offset: Int
  ): [EventLog]
  numUids: Int
}

input AddFormInput {
  isActive: Boolean
  name: String!
  workflowNodes: [WorkflowNodeRef]
  jsonSchema: String
  uiSchema: String
}

type AddFormPayload {
  form(filter: FormFilter, order: FormOrder, first: Int, offset: Int): [Form]
  numUids: Int
}

input AddGeneralLedgerAccountInput {
  code: String!
  name: String
  type: String
}

type AddGeneralLedgerAccountPayload {
  generalLedgerAccount(
    filter: GeneralLedgerAccountFilter
    order: GeneralLedgerAccountOrder
    first: Int
    offset: Int
  ): [GeneralLedgerAccount]
  numUids: Int
}

input AddInterfaceMessageLogInput {
  createdDateTime: DateTime
  level: String
  message: String
  component: String
  status: String
  errorMessage: String
  payload: String
}

type AddInterfaceMessageLogPayload {
  interfaceMessageLog(
    filter: InterfaceMessageLogFilter
    order: InterfaceMessageLogOrder
    first: Int
    offset: Int
  ): [InterfaceMessageLog]
  numUids: Int
}

input AddInventoryActualInput {
  isActive: Boolean
  jobResponse: ExtJobResponseRef!
  materialDefinition: ExtMaterialDefinitionRef
  materialLot: ExtMaterialLotRef
  materialSubLot: ExtMaterialSubLotRef
  materialUse: MaterialUse
  materialStatus: ExtMaterialStatusRef
  carrier: ExtCarrierRef
  quantity: Float
  quantityUoM: ExtUnitOfMeasureRef
}

type AddInventoryActualPayload {
  isActive: Boolean
  jobResponse: JobResponse!
  materialDefinition: MaterialDefinition
  materialLot: MaterialLot
  materialSubLot: MaterialSubLot
  materialUse: MaterialUse
  materialStatus: MaterialStatus
  carrier: Carrier
  quantity: Float
  quantityUoM: UnitOfMeasure
}

input AddInventoryHandlingPolicyInput {
  isActive: Boolean
  name: String!
  materialClass: [MaterialClassRef]
  verifySerialNumberOnReceipt: Boolean
  verifySerialNumberOnPacking: Boolean
  trackBySerialNumber: Boolean
  trackByCarrier: Boolean
  rules: [InventoryHandlingRuleRef]
}

type AddInventoryHandlingPolicyPayload {
  inventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
    order: InventoryHandlingPolicyOrder
    first: Int
    offset: Int
  ): [InventoryHandlingPolicy]
  numUids: Int
}

input AddInventoryHandlingRuleInput {
  isActive: Boolean
  customer: PartnerRef!
  stockType: StockType!
  warehouse: [EquipmentRef!]!
  stateModel: MaterialStateModelRef!
  inventoryHandlingPolicy: InventoryHandlingPolicyRef!
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
}

type AddInventoryHandlingRulePayload {
  inventoryHandlingRule(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  numUids: Int
}

input AddInventoryHoldingPolicyInput {
  isActive: Boolean
  material: MaterialDefinitionRef!
  inventoryHandlingRule: InventoryHandlingRuleRef!
  materialStatus: MaterialStatusRef!
  inventoryMax: Int
  inventoryMin: Int
}

type AddInventoryHoldingPolicyPayload {
  inventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    order: InventoryHoldingPolicyOrder
    first: Int
    offset: Int
  ): [InventoryHoldingPolicy]
  numUids: Int
}

input AddJobOrderDependencyInput {
  isActive: Boolean
  description: String
  from: JobOrderRef!
  to: JobOrderRef!
  dependencyType: DependencyType
  dependencyFactor: Float
  factorUoM: UnitOfMeasureRef
  condition: String
  segmentDependency: SegmentDependencyRef
}

type AddJobOrderDependencyPayload {
  jobOrderDependency(
    filter: JobOrderDependencyFilter
    order: JobOrderDependencyOrder
    first: Int
    offset: Int
  ): [JobOrderDependency]
  numUids: Int
}

input AddJobOrderDispatchStateModelInput {
  fromStatus: DispatchStatus!
  allowedTransition: [DispatchStatus]
}

type AddJobOrderDispatchStateModelPayload {
  jobOrderDispatchStateModel(
    filter: JobOrderDispatchStateModelFilter
    first: Int
    offset: Int
  ): [JobOrderDispatchStateModel]
  numUids: Int
}

input AddJobOrderInput {
  isActive: Boolean
  createdDateTime: DateTime
  name: String!
  version: String
  description: String
  parent: JobOrderRef
  children: [JobOrderRef]
  workType: WorkType
  workDefinitionType: String
  duration: Float
  durationUoM: UnitOfMeasureRef
  materialSpecifications: [MaterialSpecificationRef]
  equipmentSpecifications: [EquipmentSpecificationRef]
  personnelSpecifications: [PersonnelSpecificationRef]
  parameterSpecifications: [ParameterSpecificationRef]
  scheduledStartDateTime: DateTime
  scheduledEndDateTime: DateTime
  scheduledDuration: Float
  equipment: EquipmentRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  priority: Int
  properties: [PropertyRef]
  hierarchyScope: String
  dispatchStatus: DispatchStatus
  operationsRequest: OperationsRequestRef
  operationsSegment: OperationsSegmentRef
  jobResponses: [JobResponseRef]
  jobOrderNotes: [JobOrderNoteRef]
  inflows: [JobOrderDependencyRef]
  outflows: [JobOrderDependencyRef]
  previous: [JobOrderRef]
  next: [JobOrderRef]
}

input AddJobOrderNoteInput {
  comment: String
  createdDateTime: DateTime
  editedDateTime: DateTime
  createdBy: UserRef
  modifiedBy: UserRef
  isActive: Boolean
  jobOrder: JobOrderRef
}

type AddJobOrderNotePayload {
  jobOrderNote(
    filter: JobOrderNoteFilter
    order: JobOrderNoteOrder
    first: Int
    offset: Int
  ): [JobOrderNote]
  numUids: Int
}

type AddJobOrderPayload {
  jobOrder(
    filter: JobOrderFilter
    order: JobOrderOrder
    first: Int
    offset: Int
  ): [JobOrder]
  numUids: Int
}

input AddJobResponseInput {
  isActive: Boolean
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  operator: UserRef
  equipment: EquipmentRef
  startDateTime: DateTime
  endDateTime: DateTime
  productionDate: String
  actualDuration: Float
  jobOrder: JobOrderRef
  events: [EventLogRef]
  quantities: [QuantityLogRef]
  personnelActual: [PersonnelActualRef]
  equipmentActual: [EquipmentActualRef]
  materialActual: [MaterialActualRef]
}

type AddJobResponsePayload {
  jobResponse(
    filter: JobResponseFilter
    order: JobResponseOrder
    first: Int
    offset: Int
  ): [JobResponse]
  numUids: Int
}

input AddLibreServiceInput {
  name: String!
  heartbeat: DateTime
}

type AddLibreServicePayload {
  libreService(
    filter: LibreServiceFilter
    order: LibreServiceOrder
    first: Int
    offset: Int
  ): [LibreService]
  numUids: Int
}

input AddMaterialActualInput {
  isActive: Boolean
  jobResponse: JobResponseRef!
  materialDefinition: MaterialDefinitionRef
  materialLot: MaterialLotRef
  materialSubLot: MaterialSubLotRef
  materialUse: MaterialUse
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type AddMaterialActualPayload {
  materialActual(
    filter: MaterialActualFilter
    order: MaterialActualOrder
    first: Int
    offset: Int
  ): [MaterialActual]
  numUids: Int
}

input AddMaterialAlternateInput {
  isActive: Boolean
  material: MaterialDefinitionRef!
  alternateMaterial: MaterialDefinitionRef!
  effectiveDateTime: DateTime!
  priorityOrder: Int!
}

type AddMaterialAlternatePayload {
  materialAlternate(
    filter: MaterialAlternateFilter
    order: MaterialAlternateOrder
    first: Int
    offset: Int
  ): [MaterialAlternate]
  numUids: Int
}

input AddMaterialClassInput {
  isActive: Boolean
  code: String!
  description: String
  properties: [PropertyRef]
  scheduleSortOrder: Int
  parent: MaterialClassRef
  children: [MaterialClassRef]
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
}

type AddMaterialClassPayload {
  materialClass(
    filter: MaterialClassFilter
    order: MaterialClassOrder
    first: Int
    offset: Int
  ): [MaterialClass]
  numUids: Int
}

input AddMaterialDefinitionInput {
  isActive: Boolean
  code: String!
  name: String
  materialClass: MaterialClassRef
  materialActual: [MaterialActualRef]
  description: String
  properties: [PropertyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  scheduleSortOrder: Int
  baseUnitOfMeasure: UnitOfMeasureRef!
  uomConversions: [UnitOfMeasureConversionRef]
  workSpecifications: [MaterialSpecificationRef]
  operationsDefinitions: [OperationsDefinitionRef]
  lots: [MaterialLotRef]
  sublots: [MaterialSubLotRef]
  units: [MaterialUnitRef]
  value: Float
  valueCurrency: String
  weightKG: Float
  supplier: String
  serialMask: String
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  alternates: [MaterialAlternateRef]
  shipmentItems: [ShipmentItemRef]
  OrderLines: [OrderLineRef]
  transferrableMaterials: [MaterialDefinitionRef]
  customerMaterialCode: String
}

type AddMaterialDefinitionPayload {
  materialDefinition(
    filter: MaterialDefinitionFilter
    order: MaterialDefinitionOrder
    first: Int
    offset: Int
  ): [MaterialDefinition]
  numUids: Int
}

input AddMaterialEventRulesetInput {
  name: String!
  triggerWhen: [RulesetTriggerOption]
  segment: OperationsSegmentRef
  targetMaterial: String!
  targetMaterialOp: String!
  eventDefs: [EventDefinitionRef]
}

type AddMaterialEventRulesetPayload {
  materialEventRuleset(
    filter: MaterialEventRulesetFilter
    order: MaterialEventRulesetOrder
    first: Int
    offset: Int
  ): [MaterialEventRuleset]
  numUids: Int
}

input AddMaterialLotInput {
  isActive: Boolean
  code: String!
  description: String
  properties: [PropertyRef]
  material: MaterialDefinitionRef!
  quantity: String
  dataType: DataType
  unitOfMeasure: UnitOfMeasureRef
  materialActual: [MaterialActualRef]
  isAssembledFromLot: [MaterialLotRef]
  isComponentOfLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  childSubLot: [MaterialSubLotRef]
}

type AddMaterialLotPayload {
  materialLot(
    filter: MaterialLotFilter
    order: MaterialLotOrder
    first: Int
    offset: Int
  ): [MaterialLot]
  numUids: Int
}

input AddMaterialSpecificationInput {
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  billOfMaterial: BillOfMaterialRef
  material: MaterialDefinitionRef
  materialClass: MaterialClassRef
  description: String
  materialUse: MaterialUse!
  allowedStates: [MaterialStatusRef]
  isTracked: Boolean
  isBackFlushed: Boolean
  backFlushFromLocation: EquipmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

type AddMaterialSpecificationPayload {
  materialSpecification(
    filter: MaterialSpecificationFilter
    order: MaterialSpecificationOrder
    first: Int
    offset: Int
  ): [MaterialSpecification]
  numUids: Int
}

input AddMaterialStateModelInput {
  isActive: Boolean
  name: String!
  states: [MaterialStateTransitionRef!]!
  inventoryHandlingRules: [InventoryHandlingRuleRef]
}

type AddMaterialStateModelPayload {
  materialStateModel(
    filter: MaterialStateModelFilter
    order: MaterialStateModelOrder
    first: Int
    offset: Int
  ): [MaterialStateModel]
  numUids: Int
}

input AddMaterialStateTransitionInput {
  status: MaterialStatusRef!
  to: [MaterialStatusRef]
  canReceive: Boolean
  canPack: Boolean
  isPlanned: Boolean
}

type AddMaterialStateTransitionPayload {
  materialStateTransition(
    filter: MaterialStateTransitionFilter
    first: Int
    offset: Int
  ): [MaterialStateTransition]
  numUids: Int
}

input AddMaterialStatusInput {
  isActive: Boolean
  code: String!
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
}

type AddMaterialStatusPayload {
  materialStatus(
    filter: MaterialStatusFilter
    order: MaterialStatusOrder
    first: Int
    offset: Int
  ): [MaterialStatus]
  numUids: Int
}

input AddMaterialSubLotInput {
  isActive: Boolean
  code: String!
  material: MaterialDefinitionRef!
  materialActual: [MaterialActualRef]
  description: String
  status: MaterialStatusRef!
  storageLocation: EquipmentRef
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isAssembledFromLot: [MaterialLotRef]
  parentLot: MaterialLotRef
  parentSubLot: MaterialSubLotRef
  childSubLot: MaterialSubLotRef
  quantity: String
  dataType: DataType
  unitOfMeasure: UnitOfMeasureRef
  properties: [PropertyRef]
}

type AddMaterialSubLotPayload {
  materialSubLot(
    filter: MaterialSubLotFilter
    order: MaterialSubLotOrder
    first: Int
    offset: Int
  ): [MaterialSubLot]
  numUids: Int
}

input AddMaterialUnitInput {
  isActive: Boolean
  serialNumber: String!
  material: MaterialDefinitionRef!
  properties: [PropertyRef]
}

type AddMaterialUnitPayload {
  materialUnit(
    filter: MaterialUnitFilter
    order: MaterialUnitOrder
    first: Int
    offset: Int
  ): [MaterialUnit]
  numUids: Int
}

input AddMenuInput {
  label: String!
  access: [RoleRef!]!
  parent: MenuRef
  children: [MenuRef!]
  menuPage: String
  icon: String
  isSection: Boolean!
  isPage: Boolean!
  orderNumber: Int
}

type AddMenuPayload {
  menu(filter: MenuFilter, order: MenuOrder, first: Int, offset: Int): [Menu]
  numUids: Int
}

input AddOperationsDefinitionInput {
  isActive: Boolean
  name: String!
  material: MaterialDefinitionRef
  version: String
  description: String
  operationsType: WorkType!
  hierarchyScope: String
  billOfMaterial: BillOfMaterialRef
  segments: [OperationsSegmentRef]
}

type AddOperationsDefinitionPayload {
  operationsDefinition(
    filter: OperationsDefinitionFilter
    order: OperationsDefinitionOrder
    first: Int
    offset: Int
  ): [OperationsDefinition]
  numUids: Int
}

input AddOperationsRequestInput {
  isActive: Boolean
  code: String!
  operationsType: WorkType!
  plannedStartDateTime: DateTime
  plannedEndDateTime: DateTime
  priority: String
  operationsDefinition: OperationsDefinitionRef!
  requestState: RequestStateRef!
  quantity: Float!
  quantityUoM: UnitOfMeasureRef!
  jobOrders: [JobOrderRef]
  equipment: EquipmentRef
  properties: [PropertyRef]
}

type AddOperationsRequestPayload {
  operationsRequest(
    filter: OperationsRequestFilter
    order: OperationsRequestOrder
    first: Int
    offset: Int
  ): [OperationsRequest]
  numUids: Int
}

input AddOperationsSegmentInput {
  isActive: Boolean
  name: String!
  version: String
  type: SegmentType
  uiComponent: String
  description: String
  parent: OperationsSegmentRef
  children: [OperationsSegmentRef]
  workType: WorkType
  workDefinitionType: String
  duration: Float
  glAccountWIP: String
  glAccountWIPInvoice: String
  glAccountFixedOverhead: String
  glAccountVariableOverhead: String
  glAccountDirectLabour: String
  invoiceSettings: [SegmentInvoiceSettingRef]
  costAmountFixedOverhead: Float
  costDriverFixedOverhead: CostDriver
  costAmountVariableOverhead: Float
  costAmountDirectLabourRate: Float
  durationUoM: UnitOfMeasureRef
  orderStartRuleset: OrderStartRulesetRef
  materialSpecifications: [MaterialSpecificationRef]
  materialEventRuleset: MaterialEventRulesetRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  stateEventRuleset: StateEventRulesetRef
  personnelSpecifications: [PersonnelSpecificationRef]
  parameterSpecifications: [ParameterSpecificationRef]
  hierarchyScope: String
  inflows: [SegmentDependencyRef]
  outflows: [SegmentDependencyRef]
  operationsDefinition: OperationsDefinitionRef
  jobOrders: [JobOrderRef]
  mpmPlanRate: Float
  mpmIdealSetupTime: Float
  mpmIdealChangeoverTime: Float
  mpmEnableSmartChangeover: Boolean
  mpmChangeoverFamily: String
  mpmThresholdRunRate: Float
  mpmThresholdRunDuration: Float
  mpmThresholdSlowRate: Float
  mpmThresholdSlowDuration: Float
  mpmThresholdMicrostopDuration: Float
  mpmEnableAutoIdent: Boolean
  mpmAutoIdentMatchCode: PropertyRef
  positionX: Int
  positionY: Int
}

type AddOperationsSegmentPayload {
  operationsSegment(
    filter: OperationsSegmentFilter
    order: OperationsSegmentOrder
    first: Int
    offset: Int
  ): [OperationsSegment]
  numUids: Int
}

input AddOrderInput {
  isActive: Boolean
  orderType: OrderType!
  customerOrderNumber: String
  customerReference: String
  deliveryTerms: IncoTerms
  status: OrderStatus!
  shipFromPartner: PartnerRef
  shipToPartner: PartnerRef
  invoiceFromPartner: PartnerRef
  invoiceToPartner: PartnerRef
  warehouse: EquipmentRef
  lines: [OrderLineRef]
  shipments: [ShipmentRef]
  notes: String
  createdDateTime: DateTime
}

input AddOrderLineInput {
  isActive: Boolean
  order: OrderRef
  orderLineNumber: Int!
  material: MaterialDefinitionRef!
  quantity: Int!
  defectiveSerialNumbers: String
  isReturn: Boolean
  workflowInstance: WorkflowInstanceRef
}

type AddOrderLinePayload {
  orderLine(
    filter: OrderLineFilter
    order: OrderLineOrder
    first: Int
    offset: Int
  ): [OrderLine]
  numUids: Int
}

type AddOrderPayload {
  order(
    filter: OrderFilter
    order: OrderOrder
    first: Int
    offset: Int
  ): [Order]
  numUids: Int
}

input AddOrderStartRulesetInput {
  name: String!
  segment: OperationsSegmentRef
  eventDefs: [EventDefinitionRef]
}

type AddOrderStartRulesetPayload {
  orderStartRuleset(
    filter: OrderStartRulesetFilter
    order: OrderStartRulesetOrder
    first: Int
    offset: Int
  ): [OrderStartRuleset]
  numUids: Int
}

input AddParameterSpecificationInput {
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  material: MaterialDefinitionRef
  property: PropertyRef!
  valueDefault: String
  valueSetPoint: String
  valueUpperSpecLimit: Float
  valueLowerSpecLimit: Float
  valueUpperControlLimit: Float
  valueLowerControlLimit: Float
}

type AddParameterSpecificationPayload {
  parameterSpecification(
    filter: ParameterSpecificationFilter
    order: ParameterSpecificationOrder
    first: Int
    offset: Int
  ): [ParameterSpecification]
  numUids: Int
}

input AddPartnerInput {
  isActive: Boolean
  companyCode: String!
  name: String
  vatNumber: String
  registrationNumber: String
  contactName: String
  contactEmail: String
  contactPhone: String
  shippingAddress: AddressRef
  billingAddress: AddressRef
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  carriers: [CarrierRef]
  fromOrders: [OrderRef]
  toOrders: [OrderRef]
  shippingAccounts: [ShippingAccountRef]
}

type AddPartnerPayload {
  partner(
    filter: PartnerFilter
    order: PartnerOrder
    first: Int
    offset: Int
  ): [Partner]
  numUids: Int
}

input AddPayloadFieldDefinitionInput {
  isActive: Boolean
  name: String!
  expression: String!
  fieldType: PayloadFieldType
}

type AddPayloadFieldDefinitionPayload {
  payloadFieldDefinition(
    filter: PayloadFieldDefinitionFilter
    order: PayloadFieldDefinitionOrder
    first: Int
    offset: Int
  ): [PayloadFieldDefinition]
  numUids: Int
}

input AddPersonInput {
  isActive: Boolean
  name: String!
  description: String
  properties: [PropertyRef]
  memberOf: [PersonnelClassRef]
  personnelActual: [PersonnelActualRef]
}

input AddPersonnelActualInput {
  isActive: Boolean
  jobResponse: JobResponseRef!
  person: PersonRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type AddPersonnelActualPayload {
  personnelActual(
    filter: PersonnelActualFilter
    order: PersonnelActualOrder
    first: Int
    offset: Int
  ): [PersonnelActual]
  numUids: Int
}

input AddPersonnelClassInput {
  isActive: Boolean
  name: String!
  description: String
  properties: [PropertyRef]
  persons: [PersonRef]
  isTestedBy: [TestSpecificationRef]
}

type AddPersonnelClassPayload {
  personnelClass(
    filter: PersonnelClassFilter
    order: PersonnelClassOrder
    first: Int
    offset: Int
  ): [PersonnelClass]
  numUids: Int
}

input AddPersonnelSpecificationInput {
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  person: PersonRef
  personnelClass: PersonnelClassRef
  description: String
  personnelUse: String
  quantity: Float
  uom: UnitOfMeasureRef
}

type AddPersonnelSpecificationPayload {
  personnelSpecification(
    filter: PersonnelSpecificationFilter
    order: PersonnelSpecificationOrder
    first: Int
    offset: Int
  ): [PersonnelSpecification]
  numUids: Int
}

type AddPersonPayload {
  person(
    filter: PersonFilter
    order: PersonOrder
    first: Int
    offset: Int
  ): [Person]
  numUids: Int
}

input AddPropertyInput {
  isActive: Boolean
  type: PropertyType
  name: String!
  description: String!
  dataType: DataType
  definedBy: PropertyRef
  address: String
  expression: String
  value: String
  unitOfMeasure: UnitOfMeasureRef
  storeHistory: Boolean
  isTestedBy: [TestSpecificationRef]
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  materialClass: MaterialClassRef
  operationsRequest: OperationsRequestRef
  jobOrder: JobOrderRef
  propertyOverrides: [EquipmentPropertyOverrideRef]
  propertyNameAliases: [PropertyNameAliasRef]
  eventTriggers: [EventDefinitionRef]
  eventPayloads: [EventDefinitionRef]
  parameterSpecifications: [ParameterSpecificationRef]
}

input AddPropertyNameAliasInput {
  property: PropertyRef!
  equipment: EquipmentRef!
  alias: String!
  system: String!
}

type AddPropertyNameAliasPayload {
  propertyNameAlias(
    filter: PropertyNameAliasFilter
    order: PropertyNameAliasOrder
    first: Int
    offset: Int
  ): [PropertyNameAlias]
  numUids: Int
}

type AddPropertyPayload {
  property(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  numUids: Int
}

input AddPropertyValueAliasInput {
  property: PropertyRef!
  value: String!
  alias: String!
  system: String!
}

type AddPropertyValueAliasPayload {
  propertyValueAlias(
    filter: PropertyValueAliasFilter
    order: PropertyValueAliasOrder
    first: Int
    offset: Int
  ): [PropertyValueAlias]
  numUids: Int
}

input AddQuantityLogInput {
  isActive: Boolean
  jobResponse: JobResponseRef!
  equipment: EquipmentRef
  type: MaterialUse!
  timestamp: DateTime
  quantity: Float!
  reasonCode: String
  reasonText: String
  comments: String
}

type AddQuantityLogPayload {
  quantityLog(
    filter: QuantityLogFilter
    order: QuantityLogOrder
    first: Int
    offset: Int
  ): [QuantityLog]
  numUids: Int
}

input AddReasonCategoryInput {
  isActive: Boolean
  reason: [ReasonRef]
  code: String!
  timeCategory: TimeCategory!
}

type AddReasonCategoryPayload {
  reasonCategory(
    filter: ReasonCategoryFilter
    order: ReasonCategoryOrder
    first: Int
    offset: Int
  ): [ReasonCategory]
  numUids: Int
}

input AddReasonInput {
  isActive: Boolean
  class: ReasonClass!
  category: ReasonCategoryRef
  label: String!
  text: String!
  erpCode: String!
  standardValue: Float
  valueUoM: UnitOfMeasureRef
  parent: ReasonRef
  children: [ReasonRef]
  equipmentClass: EquipmentClassRef
  equipment: EquipmentRef
  equipmentOverrides: [EquipmentReasonOverrideRef]
}

type AddReasonPayload {
  reason(
    filter: ReasonFilter
    order: ReasonOrder
    first: Int
    offset: Int
  ): [Reason]
  numUids: Int
}

input AddRequestStateInput {
  isActive: Boolean
  name: String!
  description: String
}

type AddRequestStatePayload {
  requestState(
    filter: RequestStateFilter
    order: RequestStateOrder
    first: Int
    offset: Int
  ): [RequestState]
  numUids: Int
}

type Address {
  id: ID!
  isActive: Boolean
  name: String
  street1: String
  street2: String
  number: String
  city: String
  state: String
  postCode: String
  countryCode: String
}

type AddressAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  street1Min: String
  street1Max: String
  street2Min: String
  street2Max: String
  numberMin: String
  numberMax: String
  cityMin: String
  cityMax: String
  stateMin: String
  stateMax: String
  postCodeMin: String
  postCodeMax: String
  countryCodeMin: String
  countryCodeMax: String
}

input AddressFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  has: [AddressHasFilter]
  and: [AddressFilter]
  or: [AddressFilter]
  not: AddressFilter
}

enum AddressHasFilter {
  isActive
  name
  street1
  street2
  number
  city
  state
  postCode
  countryCode
}

input AddressOrder {
  asc: AddressOrderable
  desc: AddressOrderable
  then: AddressOrder
}

enum AddressOrderable {
  name
  street1
  street2
  number
  city
  state
  postCode
  countryCode
}

input AddressPatch {
  isActive: Boolean
  name: String
  street1: String
  street2: String
  number: String
  city: String
  state: String
  postCode: String
  countryCode: String
}

input AddressRef {
  id: ID
  isActive: Boolean
  name: String
  street1: String
  street2: String
  number: String
  city: String
  state: String
  postCode: String
  countryCode: String
}

input AddRoleInput {
  name: String!
  hasMembers: [UserRoleRef]
  hasGrantedRights: [AccessRightRef]
  isActive: Boolean
  workflowNodes: [WorkflowNodeRef]
}

type AddRolePayload {
  role(filter: RoleFilter, order: RoleOrder, first: Int, offset: Int): [Role]
  numUids: Int
}

input AddSegmentDependencyInput {
  isActive: Boolean
  description: String
  from: OperationsSegmentRef!
  to: OperationsSegmentRef!
  dependencyType: DependencyType
  dependencyFactor: Float
  factorUoM: UnitOfMeasureRef
  condition: String
  transitionEventRuleset: TransitionEventRulesetRef
  jobOrderDependencies: [JobOrderDependencyRef]
}

type AddSegmentDependencyPayload {
  segmentDependency(
    filter: SegmentDependencyFilter
    order: SegmentDependencyOrder
    first: Int
    offset: Int
  ): [SegmentDependency]
  numUids: Int
}

input AddSegmentInvoiceSettingInput {
  partner: PartnerRef
  costPerHour: Float
  costPerUnit: Float
}

type AddSegmentInvoiceSettingPayload {
  segmentInvoiceSetting(
    filter: SegmentInvoiceSettingFilter
    order: SegmentInvoiceSettingOrder
    first: Int
    offset: Int
  ): [SegmentInvoiceSetting]
  numUids: Int
}

input AddShipmentInput {
  isActive: Boolean
  type: ShipmentType!
  transportCompany: TransportCompany
  transportCompanyShipmentId: String
  transportCompanyProductCode: String
  reference: String
  items: [ShipmentItemRef]
  customerReference: String
  emailTrackingEnabled: Boolean
  from: AddressRef
  to: AddressRef
  order: OrderRef!
  warehouse: EquipmentRef!
  consignmentNumber: String
  properties: [PropertyRef]
  dateTimeReceivedUTC: DateTime
  dateTimeDeliveredUTC: DateTime
  dateTimePackedUTC: DateTime
  dateTimeCreatedUTC: DateTime
  delivered: DeliveryRef
  status: ShipmentStatus
}

input AddShipmentItemInput {
  isActive: Boolean
  transportCompanyItemReference: String
  transportCompanyItemId: String
  trackingDetailsArticleId: String
  trackingDetailsBarcodeId: String
  trackingDetailsConsignmentId: String
  shipment: ShipmentRef
  status: ShipmentItemStatus!
  material: MaterialDefinitionRef
  plannedQuantity: Int
  isParcel: Boolean
  bin: EquipmentRef
  box: BoxRef
  weightKg: Float
}

type AddShipmentItemPayload {
  shipmentItem(
    filter: ShipmentItemFilter
    order: ShipmentItemOrder
    first: Int
    offset: Int
  ): [ShipmentItem]
  numUids: Int
}

type AddShipmentPayload {
  shipment(
    filter: ShipmentFilter
    order: ShipmentOrder
    first: Int
    offset: Int
  ): [Shipment]
  numUids: Int
}

input AddShippingAccountInput {
  isActive: Boolean
  partner: PartnerRef
  transportCompany: TransportCompany
  warehouse: EquipmentRef
  accountNumber: String
  username: String
  secret: String
}

type AddShippingAccountPayload {
  shippingAccount(
    filter: ShippingAccountFilter
    order: ShippingAccountOrder
    first: Int
    offset: Int
  ): [ShippingAccount]
  numUids: Int
}

input AddStateEventRulesetInput {
  name: String!
  triggerWhen: [RulesetTriggerOption]
  segment: OperationsSegmentRef
  targetState: String!
  eventDefs: [EventDefinitionRef]
}

type AddStateEventRulesetPayload {
  stateEventRuleset(
    filter: StateEventRulesetFilter
    order: StateEventRulesetOrder
    first: Int
    offset: Int
  ): [StateEventRuleset]
  numUids: Int
}

input AddTestResultInput {
  isActive: Boolean
  description: String
  result: String
  uom: UnitOfMeasureRef
  testDateTime: DateTime
}

type AddTestResultPayload {
  testResult(
    filter: TestResultFilter
    order: TestResultOrder
    first: Int
    offset: Int
  ): [TestResult]
  numUids: Int
}

input AddTestSpecificationInput {
  isActive: Boolean
  description: String
  version: String
}

type AddTestSpecificationPayload {
  testSpecification(
    filter: TestSpecificationFilter
    order: TestSpecificationOrder
    first: Int
    offset: Int
  ): [TestSpecification]
  numUids: Int
}

input AddTransitionEventRulesetInput {
  name: String!
  segmentDependency: SegmentDependencyRef
  eventDefs: [EventDefinitionRef]
}

type AddTransitionEventRulesetPayload {
  transitionEventRuleset(
    filter: TransitionEventRulesetFilter
    order: TransitionEventRulesetOrder
    first: Int
    offset: Int
  ): [TransitionEventRuleset]
  numUids: Int
}

input AddUnitOfMeasureConversionInput {
  isActive: Boolean
  fromUoM: UnitOfMeasureRef!
  toUoM: UnitOfMeasureRef!
  numerator: Float!
  denominator: Float!
  material: MaterialDefinitionRef!
}

type AddUnitOfMeasureConversionPayload {
  unitOfMeasureConversion(
    filter: UnitOfMeasureConversionFilter
    order: UnitOfMeasureConversionOrder
    first: Int
    offset: Int
  ): [UnitOfMeasureConversion]
  numUids: Int
}

input AddUnitOfMeasureInput {
  isActive: Boolean
  code: String!
  dataType: DataType
}

type AddUnitOfMeasurePayload {
  unitOfMeasure(
    filter: UnitOfMeasureFilter
    order: UnitOfMeasureOrder
    first: Int
    offset: Int
  ): [UnitOfMeasure]
  numUids: Int
}

input AddUserInput {
  username: String!
  name: String
  isType: UserType!
  hasRole: [UserRoleRef]
  tasks: [WorkflowNodeInstanceRef]
  isActive: Boolean
}

type AddUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input AddUserRoleInput {
  role: RoleRef!
  user: UserRef!
  responsibilities: [EquipmentRef]!
  isActive: Boolean
}

type AddUserRolePayload {
  userRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
  numUids: Int
}

input AddWorkCalendarDefinitionEntryInput {
  isActive: Boolean
  description: String
  hierarchyScope: EquipmentRef
  freq: Frequency!
  startDateTime: DateTime!
  endDateTime: DateTime
  count: Int
  interval: Int
  wkst: Weekday
  byWeekDay: [Weekday]
  byMonth: [Int]
  bySetPos: [Int]
  byMonthDay: [Int]
  byYearDay: [Int]
  byWeekNo: [Int]
  byHour: [Int]
  byMinute: [Int]
  bySecond: [Int]
  duration: String
  entryType: WorkCalendarEntryType!
  properties: [PropertyRef]
  calendarEntries: [WorkCalendarEntryRef]
  workCalendar: WorkCalendarRef
}

type AddWorkCalendarDefinitionEntryPayload {
  workCalendarDefinitionEntry(
    filter: WorkCalendarDefinitionEntryFilter
    order: WorkCalendarDefinitionEntryOrder
    first: Int
    offset: Int
  ): [WorkCalendarDefinitionEntry]
  numUids: Int
}

input AddWorkCalendarEntryInput {
  isActive: Boolean
  description: String
  definition: WorkCalendarDefinitionEntryRef
  hierarchyScope: EquipmentRef
  startDateTime: DateTime!
  finishDateTime: DateTime!
  entryType: WorkCalendarEntryType!
  properties: [PropertyRef]
  workCalendar: WorkCalendarRef
}

type AddWorkCalendarEntryPayload {
  workCalendarEntry(
    filter: WorkCalendarEntryFilter
    order: WorkCalendarEntryOrder
    first: Int
    offset: Int
  ): [WorkCalendarEntry]
  numUids: Int
}

input AddWorkCalendarInput {
  isActive: Boolean
  name: String!
  description: String
  definition: [WorkCalendarDefinitionEntryRef]
  entries: [WorkCalendarEntryRef]
  equipment: [EquipmentRef]
}

type AddWorkCalendarPayload {
  workCalendar(
    filter: WorkCalendarFilter
    order: WorkCalendarOrder
    first: Int
    offset: Int
  ): [WorkCalendar]
  numUids: Int
}

input AddWorkflowConnectionInput {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  connectionType: WorkflowConnectionTypeRef!
  workflowSpecification: WorkflowSpecificationRef!
  from: WorkflowNodeRef!
  to: WorkflowNodeRef!
  condition: String
  properties: [WorkflowPropertyRef]
}

type AddWorkflowConnectionPayload {
  workflowConnection(
    filter: WorkflowConnectionFilter
    order: WorkflowConnectionOrder
    first: Int
    offset: Int
  ): [WorkflowConnection]
  numUids: Int
}

input AddWorkflowConnectionTypeInput {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  name: String!
  description: String!
  connections: [WorkflowConnectionRef]
  properties: [WorkflowPropertyRef]
}

type AddWorkflowConnectionTypePayload {
  workflowConnectionType(
    filter: WorkflowConnectionTypeFilter
    order: WorkflowConnectionTypeOrder
    first: Int
    offset: Int
  ): [WorkflowConnectionType]
  numUids: Int
}

input AddWorkflowInstanceInput {
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  status: WorkflowNodeStatus
  workflowSpecification: WorkflowSpecificationRef
  equipment: EquipmentRef
  parent: WorkflowInstanceRef
  children: [WorkflowInstanceRef]
  nodeInstances: [WorkflowNodeInstanceRef]
  propertyInstances: [WorkflowPropertyInstanceRef]
  properties: [WorkflowInstancePropertyRef]
  orderLines: [OrderLineRef]
}

type AddWorkflowInstancePayload {
  workflowInstance(
    filter: WorkflowInstanceFilter
    order: WorkflowInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowInstance]
  numUids: Int
}

input AddWorkflowInstancePropertyInput {
  key: String!
  workflowInstance: WorkflowInstanceRef
  name: String!
  values: [WorkflowPropertyValueRef]
}

type AddWorkflowInstancePropertyPayload {
  workflowInstanceProperty(
    filter: WorkflowInstancePropertyFilter
    order: WorkflowInstancePropertyOrder
    first: Int
    offset: Int
  ): [WorkflowInstanceProperty]
  numUids: Int
}

input AddWorkflowNodeEventInput {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  nodeInstance: WorkflowNodeInstanceRef
  previous: WorkflowNodeEventRef
  next: WorkflowNodeEventRef
  status: WorkflowNodeStatus
  isProcessed: Boolean
  value: String
}

type AddWorkflowNodeEventPayload {
  workflowNodeEvent(
    filter: WorkflowNodeEventFilter
    order: WorkflowNodeEventOrder
    first: Int
    offset: Int
  ): [WorkflowNodeEvent]
  numUids: Int
}

input AddWorkflowNodeInput {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  name: String!
  description: String!
  uiComponent: String
  form: FormRef
  role: RoleRef
  nodeType: WorkflowNodeTypeRef!
  inflows: [WorkflowConnectionRef]
  outflows: [WorkflowConnectionRef]
  workflowSpecification: WorkflowSpecificationRef!
  properties: [WorkflowPropertyRef]
  nodeInstances: [WorkflowNodeInstanceRef]
  positionX: Int
  positionY: Int
  width: Int
  height: Int
}

input AddWorkflowNodeInstanceInput {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  status: WorkflowNodeStatus
  assignedUser: UserRef
  workflowInstance: WorkflowInstanceRef!
  node: WorkflowNodeRef!
  events: [WorkflowNodeEventRef]
}

type AddWorkflowNodeInstancePayload {
  workflowNodeInstance(
    filter: WorkflowNodeInstanceFilter
    order: WorkflowNodeInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowNodeInstance]
  numUids: Int
}

type AddWorkflowNodePayload {
  workflowNode(
    filter: WorkflowNodeFilter
    order: WorkflowNodeOrder
    first: Int
    offset: Int
  ): [WorkflowNode]
  numUids: Int
}

input AddWorkflowNodeTypeInput {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  name: String!
  description: String!
  nodeClass: WorkflowNodeClass!
  nodes: [WorkflowNodeRef]
  properties: [WorkflowPropertyRef]
}

type AddWorkflowNodeTypePayload {
  workflowNodeType(
    filter: WorkflowNodeTypeFilter
    order: WorkflowNodeTypeOrder
    first: Int
    offset: Int
  ): [WorkflowNodeType]
  numUids: Int
}

input AddWorkflowPropertyInput {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  propertyType: WorkflowPropertyType!
  name: String!
  description: String!
  definedBy: WorkflowPropertyRef
  dataType: DataType
  unitOfMeasure: UnitOfMeasureRef
  value: String
  nodeType: WorkflowNodeTypeRef
  node: WorkflowNodeRef
  connectionType: WorkflowConnectionTypeRef
  connection: WorkflowConnectionRef
  instances: [WorkflowPropertyInstanceRef]
}

input AddWorkflowPropertyInstanceInput {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  workflowInstance: WorkflowInstanceRef
  workflowProperty: WorkflowPropertyRef
  values: [WorkflowPropertyValueRef]
}

type AddWorkflowPropertyInstancePayload {
  workflowPropertyInstance(
    filter: WorkflowPropertyInstanceFilter
    order: WorkflowPropertyInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowPropertyInstance]
  numUids: Int
}

type AddWorkflowPropertyPayload {
  workflowProperty(
    filter: WorkflowPropertyFilter
    order: WorkflowPropertyOrder
    first: Int
    offset: Int
  ): [WorkflowProperty]
  numUids: Int
}

input AddWorkflowPropertyValueInput {
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  propertyInstance: WorkflowPropertyInstanceRef!
  value: String
  previous: WorkflowPropertyValueRef
  next: WorkflowPropertyValueRef
}

type AddWorkflowPropertyValuePayload {
  workflowPropertyValue(
    filter: WorkflowPropertyValueFilter
    order: WorkflowPropertyValueOrder
    first: Int
    offset: Int
  ): [WorkflowPropertyValue]
  numUids: Int
}

input AddWorkflowSpecificationInput {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  name: String!
  description: String!
  nodes: [WorkflowNodeRef]
  connections: [WorkflowConnectionRef]
  instances: [WorkflowInstanceRef]
}

type AddWorkflowSpecificationPayload {
  workflowSpecification(
    filter: WorkflowSpecificationFilter
    order: WorkflowSpecificationOrder
    first: Int
    offset: Int
  ): [WorkflowSpecification]
  numUids: Int
}

input AllEventsInTimeRangeFilter {
  From: DateTime!
  To: DateTime
}

type ASNStaging {
  errorList: [String]
  isValid: Boolean
  materialCode: String!
  orderNumber: String!
  quantity: Int!
  serialNumber: String
}

input ASNStagingInput {
  materialCode: String!
  orderNumber: String!
  quantity: Int!
  serialNumber: String
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

input BackfillCancelRequest {
  requestId: String!
}

input BackfillRequest {
  equipment: [String!]!
  startDateTime: DateTime!
  username: String!
}

type BackfillResponse {
  status: BackfillStatus!
  topic: String
  message: String
}

enum BackfillStatus {
  CREATED
  REJECTED
  CANCELED
}

type BillOfMaterial {
  id: ID!
  isActive: Boolean
  name: String!
  version: String!
  description: String
  materialSpecifications(
    filter: MaterialSpecificationFilter
    order: MaterialSpecificationOrder
    first: Int
    offset: Int
  ): [MaterialSpecification]
  operationsDefinition(filter: OperationsDefinitionFilter): OperationsDefinition
  materialSpecificationsAggregate(
    filter: MaterialSpecificationFilter
  ): MaterialSpecificationAggregateResult
}

type BillOfMaterialAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  versionMin: String
  versionMax: String
  descriptionMin: String
  descriptionMax: String
}

input BillOfMaterialFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  has: [BillOfMaterialHasFilter]
  and: [BillOfMaterialFilter]
  or: [BillOfMaterialFilter]
  not: BillOfMaterialFilter
}

enum BillOfMaterialHasFilter {
  isActive
  name
  version
  description
  materialSpecifications
  operationsDefinition
}

input BillOfMaterialOrder {
  asc: BillOfMaterialOrderable
  desc: BillOfMaterialOrderable
  then: BillOfMaterialOrder
}

enum BillOfMaterialOrderable {
  name
  version
  description
}

input BillOfMaterialPatch {
  isActive: Boolean
  version: String
  description: String
  materialSpecifications: [MaterialSpecificationRef]
  operationsDefinition: OperationsDefinitionRef
}

input BillOfMaterialRef {
  id: ID
  isActive: Boolean
  name: String
  version: String
  description: String
  materialSpecifications: [MaterialSpecificationRef]
  operationsDefinition: OperationsDefinitionRef
}

type Box {
  id: ID!
  name: String
  sizeHeightCm: Int
  sizeWidthCm: Int
  sizeDepthCm: Int
}

type BoxAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  sizeHeightCmMin: Int
  sizeHeightCmMax: Int
  sizeHeightCmSum: Int
  sizeHeightCmAvg: Float
  sizeWidthCmMin: Int
  sizeWidthCmMax: Int
  sizeWidthCmSum: Int
  sizeWidthCmAvg: Float
  sizeDepthCmMin: Int
  sizeDepthCmMax: Int
  sizeDepthCmSum: Int
  sizeDepthCmAvg: Float
}

input BoxFilter {
  id: [ID!]
  has: [BoxHasFilter]
  and: [BoxFilter]
  or: [BoxFilter]
  not: BoxFilter
}

enum BoxHasFilter {
  name
  sizeHeightCm
  sizeWidthCm
  sizeDepthCm
}

input BoxOrder {
  asc: BoxOrderable
  desc: BoxOrderable
  then: BoxOrder
}

enum BoxOrderable {
  name
  sizeHeightCm
  sizeWidthCm
  sizeDepthCm
}

input BoxPatch {
  name: String
  sizeHeightCm: Int
  sizeWidthCm: Int
  sizeDepthCm: Int
}

input BoxRef {
  id: ID
  name: String
  sizeHeightCm: Int
  sizeWidthCm: Int
  sizeDepthCm: Int
}

type Carrier {
  id: ID!
  code: String!
  isActive: Boolean
  storageLocation(filter: EquipmentFilter): Equipment!
  status(filter: MaterialStatusFilter): MaterialStatus!
  barcodeImage: String
  owner(filter: PartnerFilter): Partner
  contents: [CarrierContents]
  subLots: [CarrierSubLots]
}

type CarrierAggregateResult {
  count: Int
  codeMin: String
  codeMax: String
  barcodeImageMin: String
  barcodeImageMax: String
}

type CarrierContents {
  material: MaterialDefinition!
  owner: Partner
  quantity: Float
}

input CarrierFilter {
  id: [ID!]
  code: StringHashFilter
  isActive: Boolean
  has: [CarrierHasFilter]
  and: [CarrierFilter]
  or: [CarrierFilter]
  not: CarrierFilter
}

enum CarrierHasFilter {
  code
  isActive
  storageLocation
  status
  barcodeImage
  owner
}

input CarrierOrder {
  asc: CarrierOrderable
  desc: CarrierOrderable
  then: CarrierOrder
}

enum CarrierOrderable {
  code
  barcodeImage
}

input CarrierPatch {
  isActive: Boolean
  storageLocation: EquipmentRef
  status: MaterialStatusRef
  barcodeImage: String
  owner: PartnerRef
}

input CarrierRef {
  id: ID
  code: String
  isActive: Boolean
  storageLocation: EquipmentRef
  status: MaterialStatusRef
  barcodeImage: String
  owner: PartnerRef
}

type CarrierSubLots {
  material: MaterialDefinition!
  subLot: MaterialSubLot
  owner: Partner
}

input CompleteWorkflowTaskInput {
  user: CoreUserRef!
  properties: [ExtWorkflowPropertyRef]
  task: ExtWorkflowNodeInstanceRef!
}

input ConfirmASNInput {
  orderNumber: String!
  materialCode: String!
  serialNumber: String
  quantity: Int!
  isValid: Boolean
  errorList: [String]
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

input CoreUserRef {
  username: String!
}

enum CostDriver {
  PER_HOUR
  PER_UNIT
}

input CreateWorkflowInstanceInput {
  properties: [ExtWorkflowPropertyRef]
  user: CoreUserRef!
  equipment: ExtEquipmentRef!
  specification: ExtWorkflowSpecificationRef!
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

type DashboardConfig {
  id: ID!
  name: String!
  isActive: Boolean
  panels(
    filter: DashboardPanelConfigFilter
    order: DashboardPanelConfigOrder
    first: Int
    offset: Int
  ): [DashboardPanelConfig]
  panelsAggregate(
    filter: DashboardPanelConfigFilter
  ): DashboardPanelConfigAggregateResult
}

type DashboardConfigAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input DashboardConfigFilter {
  id: [ID!]
  name: StringHashFilter
  isActive: Boolean
  has: [DashboardConfigHasFilter]
  and: [DashboardConfigFilter]
  or: [DashboardConfigFilter]
  not: DashboardConfigFilter
}

enum DashboardConfigHasFilter {
  name
  isActive
  panels
}

input DashboardConfigOrder {
  asc: DashboardConfigOrderable
  desc: DashboardConfigOrderable
  then: DashboardConfigOrder
}

enum DashboardConfigOrderable {
  name
}

input DashboardConfigPatch {
  isActive: Boolean
  panels: [DashboardPanelConfigRef]
}

input DashboardConfigRef {
  id: ID
  name: String
  isActive: Boolean
  panels: [DashboardPanelConfigRef]
}

type DashboardPanelConfig {
  id: ID!
  dashboard(filter: DashboardConfigFilter): DashboardConfig
  widgetName: String
  properties(
    filter: DashboardWidgetConfigPropertyFilter
    order: DashboardWidgetConfigPropertyOrder
    first: Int
    offset: Int
  ): [DashboardWidgetConfigProperty]
  x: Int
  y: Int
  w: Int
  h: Int
  propertiesAggregate(
    filter: DashboardWidgetConfigPropertyFilter
  ): DashboardWidgetConfigPropertyAggregateResult
}

type DashboardPanelConfigAggregateResult {
  count: Int
  widgetNameMin: String
  widgetNameMax: String
  xMin: Int
  xMax: Int
  xSum: Int
  xAvg: Float
  yMin: Int
  yMax: Int
  ySum: Int
  yAvg: Float
  wMin: Int
  wMax: Int
  wSum: Int
  wAvg: Float
  hMin: Int
  hMax: Int
  hSum: Int
  hAvg: Float
}

input DashboardPanelConfigFilter {
  id: [ID!]
  widgetName: StringHashFilter
  has: [DashboardPanelConfigHasFilter]
  and: [DashboardPanelConfigFilter]
  or: [DashboardPanelConfigFilter]
  not: DashboardPanelConfigFilter
}

enum DashboardPanelConfigHasFilter {
  dashboard
  widgetName
  properties
  x
  y
  w
  h
}

input DashboardPanelConfigOrder {
  asc: DashboardPanelConfigOrderable
  desc: DashboardPanelConfigOrderable
  then: DashboardPanelConfigOrder
}

enum DashboardPanelConfigOrderable {
  widgetName
  x
  y
  w
  h
}

input DashboardPanelConfigPatch {
  dashboard: DashboardConfigRef
  widgetName: String
  properties: [DashboardWidgetConfigPropertyRef]
  x: Int
  y: Int
  w: Int
  h: Int
}

input DashboardPanelConfigRef {
  id: ID
  dashboard: DashboardConfigRef
  widgetName: String
  properties: [DashboardWidgetConfigPropertyRef]
  x: Int
  y: Int
  w: Int
  h: Int
}

type DashboardWidgetConfigProperty {
  id: ID!
  panel(filter: DashboardPanelConfigFilter): DashboardPanelConfig
  key: String!
  value: String!
}

type DashboardWidgetConfigPropertyAggregateResult {
  count: Int
  keyMin: String
  keyMax: String
  valueMin: String
  valueMax: String
}

input DashboardWidgetConfigPropertyFilter {
  id: [ID!]
  has: [DashboardWidgetConfigPropertyHasFilter]
  and: [DashboardWidgetConfigPropertyFilter]
  or: [DashboardWidgetConfigPropertyFilter]
  not: DashboardWidgetConfigPropertyFilter
}

enum DashboardWidgetConfigPropertyHasFilter {
  panel
  key
  value
}

input DashboardWidgetConfigPropertyOrder {
  asc: DashboardWidgetConfigPropertyOrderable
  desc: DashboardWidgetConfigPropertyOrderable
  then: DashboardWidgetConfigPropertyOrder
}

enum DashboardWidgetConfigPropertyOrderable {
  key
  value
}

input DashboardWidgetConfigPropertyPatch {
  panel: DashboardPanelConfigRef
  key: String
  value: String
}

input DashboardWidgetConfigPropertyRef {
  id: ID
  panel: DashboardPanelConfigRef
  key: String
  value: String
}

type DataError {
  message: String
}

# Data Providers are the client libraries that have been implemented in the edge agent.
# We need to make these plugins that that the library can be extended easily.
# At the moment, MQTT is all we have. We will add OPC-UA next
enum DataProvider {
  MQTT
  OPCUA
}

enum DataType {
  BOOL
  INT
  INT32
  FLOAT64
  FLOAT
  STRING
}

scalar DateTime

input DateTimeFilter {
  eq: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
  between: DateTimeRange
}

input DateTimeRange {
  min: DateTime!
  max: DateTime!
}

type DeleteAccessRightPayload {
  accessRight(filter: AccessRightFilter, first: Int, offset: Int): [AccessRight]
  msg: String
  numUids: Int
}

type DeleteACLPayload {
  aCL(filter: ACLFilter, first: Int, offset: Int): [ACL]
  msg: String
  numUids: Int
}

type DeleteAddressPayload {
  address(
    filter: AddressFilter
    order: AddressOrder
    first: Int
    offset: Int
  ): [Address]
  msg: String
  numUids: Int
}

type DeleteBillOfMaterialPayload {
  billOfMaterial(
    filter: BillOfMaterialFilter
    order: BillOfMaterialOrder
    first: Int
    offset: Int
  ): [BillOfMaterial]
  msg: String
  numUids: Int
}

type DeleteBoxPayload {
  box(filter: BoxFilter, order: BoxOrder, first: Int, offset: Int): [Box]
  msg: String
  numUids: Int
}

type DeleteCarrierPayload {
  carrier(
    filter: CarrierFilter
    order: CarrierOrder
    first: Int
    offset: Int
  ): [Carrier]
  msg: String
  numUids: Int
}

type DeleteDashboardConfigPayload {
  dashboardConfig(
    filter: DashboardConfigFilter
    order: DashboardConfigOrder
    first: Int
    offset: Int
  ): [DashboardConfig]
  msg: String
  numUids: Int
}

type DeleteDashboardPanelConfigPayload {
  dashboardPanelConfig(
    filter: DashboardPanelConfigFilter
    order: DashboardPanelConfigOrder
    first: Int
    offset: Int
  ): [DashboardPanelConfig]
  msg: String
  numUids: Int
}

type DeleteDashboardWidgetConfigPropertyPayload {
  dashboardWidgetConfigProperty(
    filter: DashboardWidgetConfigPropertyFilter
    order: DashboardWidgetConfigPropertyOrder
    first: Int
    offset: Int
  ): [DashboardWidgetConfigProperty]
  msg: String
  numUids: Int
}

type DeleteDeliveryPayload {
  delivery(
    filter: DeliveryFilter
    order: DeliveryOrder
    first: Int
    offset: Int
  ): [Delivery]
  msg: String
  numUids: Int
}

type DeleteEquipmentActualPayload {
  equipmentActual(
    filter: EquipmentActualFilter
    order: EquipmentActualOrder
    first: Int
    offset: Int
  ): [EquipmentActual]
  msg: String
  numUids: Int
}

type DeleteEquipmentClassPayload {
  equipmentClass(
    filter: EquipmentClassFilter
    order: EquipmentClassOrder
    first: Int
    offset: Int
  ): [EquipmentClass]
  msg: String
  numUids: Int
}

type DeleteEquipmentNameAliasPayload {
  equipmentNameAlias(
    filter: EquipmentNameAliasFilter
    order: EquipmentNameAliasOrder
    first: Int
    offset: Int
  ): [EquipmentNameAlias]
  msg: String
  numUids: Int
}

type DeleteEquipmentPayload {
  equipment(
    filter: EquipmentFilter
    order: EquipmentOrder
    first: Int
    offset: Int
  ): [Equipment]
  msg: String
  numUids: Int
}

type DeleteEquipmentPropertyOverridePayload {
  equipmentPropertyOverride(
    filter: EquipmentPropertyOverrideFilter
    order: EquipmentPropertyOverrideOrder
    first: Int
    offset: Int
  ): [EquipmentPropertyOverride]
  msg: String
  numUids: Int
}

type DeleteEquipmentReasonOverridePayload {
  equipmentReasonOverride(
    filter: EquipmentReasonOverrideFilter
    order: EquipmentReasonOverrideOrder
    first: Int
    offset: Int
  ): [EquipmentReasonOverride]
  msg: String
  numUids: Int
}

type DeleteEquipmentRelationPayload {
  equipmentRelation(
    filter: EquipmentRelationFilter
    first: Int
    offset: Int
  ): [EquipmentRelation]
  msg: String
  numUids: Int
}

type DeleteEquipmentSpecificationPayload {
  equipmentSpecification(
    filter: EquipmentSpecificationFilter
    order: EquipmentSpecificationOrder
    first: Int
    offset: Int
  ): [EquipmentSpecification]
  msg: String
  numUids: Int
}

type DeleteEventDefinitionPayload {
  eventDefinition(
    filter: EventDefinitionFilter
    order: EventDefinitionOrder
    first: Int
    offset: Int
  ): [EventDefinition]
  msg: String
  numUids: Int
}

type DeleteEventLogPayload {
  eventLog(
    filter: EventLogFilter
    order: EventLogOrder
    first: Int
    offset: Int
  ): [EventLog]
  msg: String
  numUids: Int
}

type DeleteFormPayload {
  form(filter: FormFilter, order: FormOrder, first: Int, offset: Int): [Form]
  msg: String
  numUids: Int
}

type DeleteGeneralLedgerAccountPayload {
  generalLedgerAccount(
    filter: GeneralLedgerAccountFilter
    order: GeneralLedgerAccountOrder
    first: Int
    offset: Int
  ): [GeneralLedgerAccount]
  msg: String
  numUids: Int
}

type DeleteInterfaceMessageLogPayload {
  interfaceMessageLog(
    filter: InterfaceMessageLogFilter
    order: InterfaceMessageLogOrder
    first: Int
    offset: Int
  ): [InterfaceMessageLog]
  msg: String
  numUids: Int
}

type DeleteInventoryHandlingPolicyPayload {
  inventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
    order: InventoryHandlingPolicyOrder
    first: Int
    offset: Int
  ): [InventoryHandlingPolicy]
  msg: String
  numUids: Int
}

type DeleteInventoryHandlingRulePayload {
  inventoryHandlingRule(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  msg: String
  numUids: Int
}

type DeleteInventoryHoldingPolicyPayload {
  inventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    order: InventoryHoldingPolicyOrder
    first: Int
    offset: Int
  ): [InventoryHoldingPolicy]
  msg: String
  numUids: Int
}

type DeleteJobOrderDependencyPayload {
  jobOrderDependency(
    filter: JobOrderDependencyFilter
    order: JobOrderDependencyOrder
    first: Int
    offset: Int
  ): [JobOrderDependency]
  msg: String
  numUids: Int
}

type DeleteJobOrderDispatchStateModelPayload {
  jobOrderDispatchStateModel(
    filter: JobOrderDispatchStateModelFilter
    first: Int
    offset: Int
  ): [JobOrderDispatchStateModel]
  msg: String
  numUids: Int
}

type DeleteJobOrderNotePayload {
  jobOrderNote(
    filter: JobOrderNoteFilter
    order: JobOrderNoteOrder
    first: Int
    offset: Int
  ): [JobOrderNote]
  msg: String
  numUids: Int
}

type DeleteJobOrderPayload {
  jobOrder(
    filter: JobOrderFilter
    order: JobOrderOrder
    first: Int
    offset: Int
  ): [JobOrder]
  msg: String
  numUids: Int
}

type DeleteJobResponsePayload {
  jobResponse(
    filter: JobResponseFilter
    order: JobResponseOrder
    first: Int
    offset: Int
  ): [JobResponse]
  msg: String
  numUids: Int
}

type DeleteLibreServicePayload {
  libreService(
    filter: LibreServiceFilter
    order: LibreServiceOrder
    first: Int
    offset: Int
  ): [LibreService]
  msg: String
  numUids: Int
}

type DeleteMaterialActualPayload {
  materialActual(
    filter: MaterialActualFilter
    order: MaterialActualOrder
    first: Int
    offset: Int
  ): [MaterialActual]
  msg: String
  numUids: Int
}

type DeleteMaterialAlternatePayload {
  materialAlternate(
    filter: MaterialAlternateFilter
    order: MaterialAlternateOrder
    first: Int
    offset: Int
  ): [MaterialAlternate]
  msg: String
  numUids: Int
}

type DeleteMaterialClassPayload {
  materialClass(
    filter: MaterialClassFilter
    order: MaterialClassOrder
    first: Int
    offset: Int
  ): [MaterialClass]
  msg: String
  numUids: Int
}

type DeleteMaterialDefinitionPayload {
  materialDefinition(
    filter: MaterialDefinitionFilter
    order: MaterialDefinitionOrder
    first: Int
    offset: Int
  ): [MaterialDefinition]
  msg: String
  numUids: Int
}

type DeleteMaterialEventRulesetPayload {
  materialEventRuleset(
    filter: MaterialEventRulesetFilter
    order: MaterialEventRulesetOrder
    first: Int
    offset: Int
  ): [MaterialEventRuleset]
  msg: String
  numUids: Int
}

type DeleteMaterialLotPayload {
  materialLot(
    filter: MaterialLotFilter
    order: MaterialLotOrder
    first: Int
    offset: Int
  ): [MaterialLot]
  msg: String
  numUids: Int
}

type DeleteMaterialSpecificationPayload {
  materialSpecification(
    filter: MaterialSpecificationFilter
    order: MaterialSpecificationOrder
    first: Int
    offset: Int
  ): [MaterialSpecification]
  msg: String
  numUids: Int
}

type DeleteMaterialStateModelPayload {
  materialStateModel(
    filter: MaterialStateModelFilter
    order: MaterialStateModelOrder
    first: Int
    offset: Int
  ): [MaterialStateModel]
  msg: String
  numUids: Int
}

type DeleteMaterialStateTransitionPayload {
  materialStateTransition(
    filter: MaterialStateTransitionFilter
    first: Int
    offset: Int
  ): [MaterialStateTransition]
  msg: String
  numUids: Int
}

type DeleteMaterialStatusPayload {
  materialStatus(
    filter: MaterialStatusFilter
    order: MaterialStatusOrder
    first: Int
    offset: Int
  ): [MaterialStatus]
  msg: String
  numUids: Int
}

type DeleteMaterialSubLotPayload {
  materialSubLot(
    filter: MaterialSubLotFilter
    order: MaterialSubLotOrder
    first: Int
    offset: Int
  ): [MaterialSubLot]
  msg: String
  numUids: Int
}

type DeleteMaterialUnitPayload {
  materialUnit(
    filter: MaterialUnitFilter
    order: MaterialUnitOrder
    first: Int
    offset: Int
  ): [MaterialUnit]
  msg: String
  numUids: Int
}

type DeleteMenuPayload {
  menu(filter: MenuFilter, order: MenuOrder, first: Int, offset: Int): [Menu]
  msg: String
  numUids: Int
}

type DeleteOperationsDefinitionPayload {
  operationsDefinition(
    filter: OperationsDefinitionFilter
    order: OperationsDefinitionOrder
    first: Int
    offset: Int
  ): [OperationsDefinition]
  msg: String
  numUids: Int
}

type DeleteOperationsRequestPayload {
  operationsRequest(
    filter: OperationsRequestFilter
    order: OperationsRequestOrder
    first: Int
    offset: Int
  ): [OperationsRequest]
  msg: String
  numUids: Int
}

type DeleteOperationsSegmentPayload {
  operationsSegment(
    filter: OperationsSegmentFilter
    order: OperationsSegmentOrder
    first: Int
    offset: Int
  ): [OperationsSegment]
  msg: String
  numUids: Int
}

type DeleteOrderLinePayload {
  orderLine(
    filter: OrderLineFilter
    order: OrderLineOrder
    first: Int
    offset: Int
  ): [OrderLine]
  msg: String
  numUids: Int
}

type DeleteOrderPayload {
  order(
    filter: OrderFilter
    order: OrderOrder
    first: Int
    offset: Int
  ): [Order]
  msg: String
  numUids: Int
}

type DeleteOrderStartRulesetPayload {
  orderStartRuleset(
    filter: OrderStartRulesetFilter
    order: OrderStartRulesetOrder
    first: Int
    offset: Int
  ): [OrderStartRuleset]
  msg: String
  numUids: Int
}

type DeleteParameterSpecificationPayload {
  parameterSpecification(
    filter: ParameterSpecificationFilter
    order: ParameterSpecificationOrder
    first: Int
    offset: Int
  ): [ParameterSpecification]
  msg: String
  numUids: Int
}

type DeletePartnerPayload {
  partner(
    filter: PartnerFilter
    order: PartnerOrder
    first: Int
    offset: Int
  ): [Partner]
  msg: String
  numUids: Int
}

type DeletePayloadFieldDefinitionPayload {
  payloadFieldDefinition(
    filter: PayloadFieldDefinitionFilter
    order: PayloadFieldDefinitionOrder
    first: Int
    offset: Int
  ): [PayloadFieldDefinition]
  msg: String
  numUids: Int
}

type DeletePersonnelActualPayload {
  personnelActual(
    filter: PersonnelActualFilter
    order: PersonnelActualOrder
    first: Int
    offset: Int
  ): [PersonnelActual]
  msg: String
  numUids: Int
}

type DeletePersonnelClassPayload {
  personnelClass(
    filter: PersonnelClassFilter
    order: PersonnelClassOrder
    first: Int
    offset: Int
  ): [PersonnelClass]
  msg: String
  numUids: Int
}

type DeletePersonnelSpecificationPayload {
  personnelSpecification(
    filter: PersonnelSpecificationFilter
    order: PersonnelSpecificationOrder
    first: Int
    offset: Int
  ): [PersonnelSpecification]
  msg: String
  numUids: Int
}

type DeletePersonPayload {
  person(
    filter: PersonFilter
    order: PersonOrder
    first: Int
    offset: Int
  ): [Person]
  msg: String
  numUids: Int
}

type DeletePropertyNameAliasPayload {
  propertyNameAlias(
    filter: PropertyNameAliasFilter
    order: PropertyNameAliasOrder
    first: Int
    offset: Int
  ): [PropertyNameAlias]
  msg: String
  numUids: Int
}

type DeletePropertyPayload {
  property(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  msg: String
  numUids: Int
}

type DeletePropertyValueAliasPayload {
  propertyValueAlias(
    filter: PropertyValueAliasFilter
    order: PropertyValueAliasOrder
    first: Int
    offset: Int
  ): [PropertyValueAlias]
  msg: String
  numUids: Int
}

type DeleteQuantityLogPayload {
  quantityLog(
    filter: QuantityLogFilter
    order: QuantityLogOrder
    first: Int
    offset: Int
  ): [QuantityLog]
  msg: String
  numUids: Int
}

type DeleteReasonCategoryPayload {
  reasonCategory(
    filter: ReasonCategoryFilter
    order: ReasonCategoryOrder
    first: Int
    offset: Int
  ): [ReasonCategory]
  msg: String
  numUids: Int
}

type DeleteReasonPayload {
  reason(
    filter: ReasonFilter
    order: ReasonOrder
    first: Int
    offset: Int
  ): [Reason]
  msg: String
  numUids: Int
}

type DeleteRequestStatePayload {
  requestState(
    filter: RequestStateFilter
    order: RequestStateOrder
    first: Int
    offset: Int
  ): [RequestState]
  msg: String
  numUids: Int
}

type DeleteRolePayload {
  role(filter: RoleFilter, order: RoleOrder, first: Int, offset: Int): [Role]
  msg: String
  numUids: Int
}

type DeleteSegmentDependencyPayload {
  segmentDependency(
    filter: SegmentDependencyFilter
    order: SegmentDependencyOrder
    first: Int
    offset: Int
  ): [SegmentDependency]
  msg: String
  numUids: Int
}

type DeleteSegmentInvoiceSettingPayload {
  segmentInvoiceSetting(
    filter: SegmentInvoiceSettingFilter
    order: SegmentInvoiceSettingOrder
    first: Int
    offset: Int
  ): [SegmentInvoiceSetting]
  msg: String
  numUids: Int
}

type DeleteShipmentItemPayload {
  shipmentItem(
    filter: ShipmentItemFilter
    order: ShipmentItemOrder
    first: Int
    offset: Int
  ): [ShipmentItem]
  msg: String
  numUids: Int
}

type DeleteShipmentPayload {
  shipment(
    filter: ShipmentFilter
    order: ShipmentOrder
    first: Int
    offset: Int
  ): [Shipment]
  msg: String
  numUids: Int
}

type DeleteShippingAccountPayload {
  shippingAccount(
    filter: ShippingAccountFilter
    order: ShippingAccountOrder
    first: Int
    offset: Int
  ): [ShippingAccount]
  msg: String
  numUids: Int
}

type DeleteStateEventRulesetPayload {
  stateEventRuleset(
    filter: StateEventRulesetFilter
    order: StateEventRulesetOrder
    first: Int
    offset: Int
  ): [StateEventRuleset]
  msg: String
  numUids: Int
}

type DeleteTestResultPayload {
  testResult(
    filter: TestResultFilter
    order: TestResultOrder
    first: Int
    offset: Int
  ): [TestResult]
  msg: String
  numUids: Int
}

type DeleteTestSpecificationPayload {
  testSpecification(
    filter: TestSpecificationFilter
    order: TestSpecificationOrder
    first: Int
    offset: Int
  ): [TestSpecification]
  msg: String
  numUids: Int
}

type DeleteTransitionEventRulesetPayload {
  transitionEventRuleset(
    filter: TransitionEventRulesetFilter
    order: TransitionEventRulesetOrder
    first: Int
    offset: Int
  ): [TransitionEventRuleset]
  msg: String
  numUids: Int
}

type DeleteUnitOfMeasureConversionPayload {
  unitOfMeasureConversion(
    filter: UnitOfMeasureConversionFilter
    order: UnitOfMeasureConversionOrder
    first: Int
    offset: Int
  ): [UnitOfMeasureConversion]
  msg: String
  numUids: Int
}

type DeleteUnitOfMeasurePayload {
  unitOfMeasure(
    filter: UnitOfMeasureFilter
    order: UnitOfMeasureOrder
    first: Int
    offset: Int
  ): [UnitOfMeasure]
  msg: String
  numUids: Int
}

type DeleteUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  msg: String
  numUids: Int
}

type DeleteUserRolePayload {
  userRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
  msg: String
  numUids: Int
}

type DeleteWorkCalendarDefinitionEntryPayload {
  workCalendarDefinitionEntry(
    filter: WorkCalendarDefinitionEntryFilter
    order: WorkCalendarDefinitionEntryOrder
    first: Int
    offset: Int
  ): [WorkCalendarDefinitionEntry]
  msg: String
  numUids: Int
}

type DeleteWorkCalendarEntryPayload {
  workCalendarEntry(
    filter: WorkCalendarEntryFilter
    order: WorkCalendarEntryOrder
    first: Int
    offset: Int
  ): [WorkCalendarEntry]
  msg: String
  numUids: Int
}

type DeleteWorkCalendarPayload {
  workCalendar(
    filter: WorkCalendarFilter
    order: WorkCalendarOrder
    first: Int
    offset: Int
  ): [WorkCalendar]
  msg: String
  numUids: Int
}

type DeleteWorkflowConnectionPayload {
  workflowConnection(
    filter: WorkflowConnectionFilter
    order: WorkflowConnectionOrder
    first: Int
    offset: Int
  ): [WorkflowConnection]
  msg: String
  numUids: Int
}

type DeleteWorkflowConnectionTypePayload {
  workflowConnectionType(
    filter: WorkflowConnectionTypeFilter
    order: WorkflowConnectionTypeOrder
    first: Int
    offset: Int
  ): [WorkflowConnectionType]
  msg: String
  numUids: Int
}

type DeleteWorkflowInstancePayload {
  workflowInstance(
    filter: WorkflowInstanceFilter
    order: WorkflowInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowInstance]
  msg: String
  numUids: Int
}

type DeleteWorkflowInstancePropertyPayload {
  workflowInstanceProperty(
    filter: WorkflowInstancePropertyFilter
    order: WorkflowInstancePropertyOrder
    first: Int
    offset: Int
  ): [WorkflowInstanceProperty]
  msg: String
  numUids: Int
}

type DeleteWorkflowNodeEventPayload {
  workflowNodeEvent(
    filter: WorkflowNodeEventFilter
    order: WorkflowNodeEventOrder
    first: Int
    offset: Int
  ): [WorkflowNodeEvent]
  msg: String
  numUids: Int
}

type DeleteWorkflowNodeInstancePayload {
  workflowNodeInstance(
    filter: WorkflowNodeInstanceFilter
    order: WorkflowNodeInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowNodeInstance]
  msg: String
  numUids: Int
}

type DeleteWorkflowNodePayload {
  workflowNode(
    filter: WorkflowNodeFilter
    order: WorkflowNodeOrder
    first: Int
    offset: Int
  ): [WorkflowNode]
  msg: String
  numUids: Int
}

type DeleteWorkflowNodeTypePayload {
  workflowNodeType(
    filter: WorkflowNodeTypeFilter
    order: WorkflowNodeTypeOrder
    first: Int
    offset: Int
  ): [WorkflowNodeType]
  msg: String
  numUids: Int
}

type DeleteWorkflowPropertyInstancePayload {
  workflowPropertyInstance(
    filter: WorkflowPropertyInstanceFilter
    order: WorkflowPropertyInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowPropertyInstance]
  msg: String
  numUids: Int
}

type DeleteWorkflowPropertyPayload {
  workflowProperty(
    filter: WorkflowPropertyFilter
    order: WorkflowPropertyOrder
    first: Int
    offset: Int
  ): [WorkflowProperty]
  msg: String
  numUids: Int
}

type DeleteWorkflowPropertyValuePayload {
  workflowPropertyValue(
    filter: WorkflowPropertyValueFilter
    order: WorkflowPropertyValueOrder
    first: Int
    offset: Int
  ): [WorkflowPropertyValue]
  msg: String
  numUids: Int
}

type DeleteWorkflowSpecificationPayload {
  workflowSpecification(
    filter: WorkflowSpecificationFilter
    order: WorkflowSpecificationOrder
    first: Int
    offset: Int
  ): [WorkflowSpecification]
  msg: String
  numUids: Int
}

type Delivery {
  id: ID!
  dateTime: DateTime!
  shipments(
    filter: ShipmentFilter
    order: ShipmentOrder
    first: Int
    offset: Int
  ): [Shipment]
  location(filter: EquipmentFilter): Equipment
  operator(filter: UserFilter): User
  partner(filter: PartnerFilter): Partner
  transportCompany: TransportCompany
  transportCompanyDeliveryId: String
  shipmentsAggregate(filter: ShipmentFilter): ShipmentAggregateResult
}

type DeliveryAggregateResult {
  count: Int
  dateTimeMin: DateTime
  dateTimeMax: DateTime
  transportCompanyDeliveryIdMin: String
  transportCompanyDeliveryIdMax: String
}

input DeliveryFilter {
  id: [ID!]
  has: [DeliveryHasFilter]
  and: [DeliveryFilter]
  or: [DeliveryFilter]
  not: DeliveryFilter
}

enum DeliveryHasFilter {
  dateTime
  shipments
  location
  operator
  partner
  transportCompany
  transportCompanyDeliveryId
}

input DeliveryOrder {
  asc: DeliveryOrderable
  desc: DeliveryOrderable
  then: DeliveryOrder
}

enum DeliveryOrderable {
  dateTime
  transportCompanyDeliveryId
}

input DeliveryPatch {
  dateTime: DateTime
  shipments: [ShipmentRef]
  location: EquipmentRef
  operator: UserRef
  partner: PartnerRef
  transportCompany: TransportCompany
  transportCompanyDeliveryId: String
}

input DeliveryRef {
  id: ID
  dateTime: DateTime
  shipments: [ShipmentRef]
  location: EquipmentRef
  operator: UserRef
  partner: PartnerRef
  transportCompany: TransportCompany
  transportCompanyDeliveryId: String
}

enum DependencyType {
  StartAfterStart
  StartAfterEnd
  EndAfterEnd
  EndAfterStart
  CanRunParallel
  CannotRunParallel
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

enum DispatchStatus {
  CREATED
  RELEASED
  PENDING
  ACTIVE
  PARKED
  COMPLETE
  CLOSED
  CANCELED
}

input DispatchStatus_hash {
  eq: DispatchStatus
  in: [DispatchStatus]
}

type Equipment {
  id: ID!
  isActive: Boolean
  userRoles(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
  name: String!
  label: String
  displayName: String
  description: String
  erpAssetID: String
  parent(filter: EquipmentFilter): Equipment
  children(
    filter: EquipmentFilter
    order: EquipmentOrder
    first: Int
    offset: Int
  ): [Equipment]
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass
  equipmentLevel: EquipmentElementLevel
  equipmentActual(
    filter: EquipmentActualFilter
    order: EquipmentActualOrder
    first: Int
    offset: Int
  ): [EquipmentActual]
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  propertyNameAliases(
    filter: PropertyNameAliasFilter
    order: PropertyNameAliasOrder
    first: Int
    offset: Int
  ): [PropertyNameAlias]
  carriers(
    filter: CarrierFilter
    order: CarrierOrder
    first: Int
    offset: Int
  ): [Carrier]
  materialSubLots(
    filter: MaterialSubLotFilter
    order: MaterialSubLotOrder
    first: Int
    offset: Int
  ): [MaterialSubLot]
  inventoryHandlingRules(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  operationsRequests(
    filter: OperationsRequestFilter
    order: OperationsRequestOrder
    first: Int
    offset: Int
  ): [OperationsRequest]
  dataProvider: DataProvider
  dataProviderConnection: String
  addressTemplate: String
  timeZoneName: String
  workSpecifications(
    filter: EquipmentSpecificationFilter
    order: EquipmentSpecificationOrder
    first: Int
    offset: Int
  ): [EquipmentSpecification]
  workflowInstances(
    filter: WorkflowInstanceFilter
    order: WorkflowInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowInstance]
  workCalendar(filter: WorkCalendarFilter): WorkCalendar
  jobResponses(
    filter: JobResponseFilter
    order: JobResponseOrder
    first: Int
    offset: Int
  ): [JobResponse]
  jobOrders(
    filter: JobOrderFilter
    order: JobOrderOrder
    first: Int
    offset: Int
  ): [JobOrder]
  shipments(
    filter: ShipmentFilter
    order: ShipmentOrder
    first: Int
    offset: Int
  ): [Shipment]
  shipmentItems(
    filter: ShipmentItemFilter
    order: ShipmentItemOrder
    first: Int
    offset: Int
  ): [ShipmentItem]
  orders(
    filter: OrderFilter
    order: OrderOrder
    first: Int
    offset: Int
  ): [Order]
  events(
    filter: EventLogFilter
    order: EventLogOrder
    first: Int
    offset: Int
  ): [EventLog]
  quantities(
    filter: QuantityLogFilter
    order: QuantityLogOrder
    first: Int
    offset: Int
  ): [QuantityLog]
  allowAdhocWorklog: Boolean
  reasons(
    filter: ReasonFilter
    order: ReasonOrder
    first: Int
    offset: Int
  ): [Reason]
  reasonOverrides(
    filter: EquipmentReasonOverrideFilter
    order: EquipmentReasonOverrideOrder
    first: Int
    offset: Int
  ): [EquipmentReasonOverride]
  propertyOverrides(
    filter: EquipmentPropertyOverrideFilter
    order: EquipmentPropertyOverrideOrder
    first: Int
    offset: Int
  ): [EquipmentPropertyOverride]
  mpmEnableJobInterlock: Boolean
  mpmPermissiveOutputName: String
  mpmEnableAutoIdentMatching: Boolean
  mpmAutoIdentMatchSource: String
  mpmEnableSetupStartDetection: Boolean
  mpmEnableSetupCloseDetection: Boolean
  mpmEnableORCWarning: Boolean
  mpmORCWarnTrigger: mpmORCWarnTriggers
  mpmEnableORCRevokePermissive: Boolean
  mpmORCRevokePermissiveTrigger: mpmORCRevokeTriggers
  mpmEnableORCBlockNextOrder: Boolean
  mpmEnableCallMaintenanceEvent: Boolean
  mpmEnableMaintenanceHandover: Boolean
  mpmEnableManualShiftStart: Boolean
  mpmEnableManualShiftEnd: Boolean
  mpmEnableManualBreak: Boolean
  mpmEnableManualPlannedMaint: Boolean
  ocsEnabled: Boolean
  ocsPageState: String
  ocsWorkflowSelector: String
  ocsChosenStopTime: DateTime
  inflows(
    filter: EquipmentRelationFilter
    first: Int
    offset: Int
  ): [EquipmentRelation]
  outflows(
    filter: EquipmentRelationFilter
    first: Int
    offset: Int
  ): [EquipmentRelation]
  userRolesAggregate(filter: UserRoleFilter): UserRoleAggregateResult
  childrenAggregate(filter: EquipmentFilter): EquipmentAggregateResult
  equipmentActualAggregate(
    filter: EquipmentActualFilter
  ): EquipmentActualAggregateResult
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  propertyNameAliasesAggregate(
    filter: PropertyNameAliasFilter
  ): PropertyNameAliasAggregateResult
  carriersAggregate(filter: CarrierFilter): CarrierAggregateResult
  materialSubLotsAggregate(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
  inventoryHandlingRulesAggregate(
    filter: InventoryHandlingRuleFilter
  ): InventoryHandlingRuleAggregateResult
  operationsRequestsAggregate(
    filter: OperationsRequestFilter
  ): OperationsRequestAggregateResult
  workSpecificationsAggregate(
    filter: EquipmentSpecificationFilter
  ): EquipmentSpecificationAggregateResult
  workflowInstancesAggregate(
    filter: WorkflowInstanceFilter
  ): WorkflowInstanceAggregateResult
  jobResponsesAggregate(filter: JobResponseFilter): JobResponseAggregateResult
  jobOrdersAggregate(filter: JobOrderFilter): JobOrderAggregateResult
  shipmentsAggregate(filter: ShipmentFilter): ShipmentAggregateResult
  shipmentItemsAggregate(
    filter: ShipmentItemFilter
  ): ShipmentItemAggregateResult
  ordersAggregate(filter: OrderFilter): OrderAggregateResult
  eventsAggregate(filter: EventLogFilter): EventLogAggregateResult
  quantitiesAggregate(filter: QuantityLogFilter): QuantityLogAggregateResult
  reasonsAggregate(filter: ReasonFilter): ReasonAggregateResult
  reasonOverridesAggregate(
    filter: EquipmentReasonOverrideFilter
  ): EquipmentReasonOverrideAggregateResult
  propertyOverridesAggregate(
    filter: EquipmentPropertyOverrideFilter
  ): EquipmentPropertyOverrideAggregateResult
  inflowsAggregate(
    filter: EquipmentRelationFilter
  ): EquipmentRelationAggregateResult
  outflowsAggregate(
    filter: EquipmentRelationFilter
  ): EquipmentRelationAggregateResult
  reasonList: [Reason]
  reasonListWithOverrides(filter: ReasonFilter): [Reason]

  #  PropertyList contains a list properties that are inherited by this equipment's class. Properties that defined at multiple levels
  # in the class inheritance are child dominant. Domination is on property name only.
  propertyList(filter: PropertyListFilter): [Property]

  #  PropertyListWithOverrides contains a list of properties directly associated with this equipment, and properties that are
  # inherited by this equipments's class. Properties directly assocated with this equipment are dominant over class inherited properties.
  propertyListWithOverrides(filter: PropertyListFilter): [Property]

  # deprecated
  eventsByTimeRange(filter: TimeRangeFilter): [EventLog]
  eventsByField(filter: EventsByFieldFilter!): [EventsByField]
  jobResponsesByTimeRange(filter: TimeRangeFilter): [JobResponse]
  maintenanceCallsByTimeRange(filter: TimeRangeFilter!): [MaintenanceLog]
  currentStatus: EventsByField
  eventSummaryByReason(
    filter: EventSummaryByReasonFilter
  ): [EventSummaryByReason]
  kpi(filter: TimeRangeFilter!): Kpi
  kpiByWorkCalendarEntry(filter: TimeRangeFilter!): [KpiByWorkCalendarEntry]
  propertyValues(filter: PropertyValuesFilter!): [PropertyValue]
  backfillStatus: EquipmentBackfillStatus
  materialEquipment(filter: MaterialEquipmentFilter): [MaterialEquipment]
}

type EquipmentActual {
  id: ID!
  isActive: Boolean
  jobResponse(filter: JobResponseFilter): JobResponse!
  equipment(filter: EquipmentFilter): Equipment
  quantity: Float
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type EquipmentActualAggregateResult {
  count: Int
  quantityMin: Float
  quantityMax: Float
  quantitySum: Float
  quantityAvg: Float
}

input EquipmentActualFilter {
  id: [ID!]
  isActive: Boolean
  has: [EquipmentActualHasFilter]
  and: [EquipmentActualFilter]
  or: [EquipmentActualFilter]
  not: EquipmentActualFilter
}

enum EquipmentActualHasFilter {
  isActive
  jobResponse
  equipment
  quantity
  quantityUoM
}

input EquipmentActualOrder {
  asc: EquipmentActualOrderable
  desc: EquipmentActualOrderable
  then: EquipmentActualOrder
}

enum EquipmentActualOrderable {
  quantity
}

input EquipmentActualPatch {
  isActive: Boolean
  jobResponse: JobResponseRef
  equipment: EquipmentRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

input EquipmentActualRef {
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  equipment: EquipmentRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type EquipmentAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  labelMin: String
  labelMax: String
  displayNameMin: String
  displayNameMax: String
  descriptionMin: String
  descriptionMax: String
  erpAssetIDMin: String
  erpAssetIDMax: String
  dataProviderConnectionMin: String
  dataProviderConnectionMax: String
  addressTemplateMin: String
  addressTemplateMax: String
  timeZoneNameMin: String
  timeZoneNameMax: String
  mpmPermissiveOutputNameMin: String
  mpmPermissiveOutputNameMax: String
  mpmAutoIdentMatchSourceMin: String
  mpmAutoIdentMatchSourceMax: String
  ocsPageStateMin: String
  ocsPageStateMax: String
  ocsWorkflowSelectorMin: String
  ocsWorkflowSelectorMax: String
  ocsChosenStopTimeMin: DateTime
  ocsChosenStopTimeMax: DateTime
}

enum EquipmentBackfillStatus {
  READY
  INITIALIZING
  RUNNING
  COMPLETE
  ERROR
  CANCELED
}

# EquipmentClasses are used to manage configuration that is common to a number of similar equipment
# The data properties that an equipment is expected to have are defined on the equipment class
type EquipmentClass {
  id: ID!
  isActive: Boolean
  name: String!
  label: String
  displayName: String
  description: String
  parent(filter: EquipmentClassFilter): EquipmentClass
  children(
    filter: EquipmentClassFilter
    order: EquipmentClassOrder
    first: Int
    offset: Int
  ): [EquipmentClass]
  equipments(
    filter: EquipmentFilter
    order: EquipmentOrder
    first: Int
    offset: Int
  ): [Equipment]
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  eventDefinitions(
    filter: EventDefinitionFilter
    order: EventDefinitionOrder
    first: Int
    offset: Int
  ): [EventDefinition]
  equipmentSpecifications(
    filter: EquipmentSpecificationFilter
    order: EquipmentSpecificationOrder
    first: Int
    offset: Int
  ): [EquipmentSpecification]
  reasons(
    filter: ReasonFilter
    order: ReasonOrder
    first: Int
    offset: Int
  ): [Reason]
  equipmentLevel: EquipmentElementLevel
  addressTemplate: String
  image: String
  dashboardConfig(filter: DashboardConfigFilter): DashboardConfig
  childrenAggregate(filter: EquipmentClassFilter): EquipmentClassAggregateResult
  equipmentsAggregate(filter: EquipmentFilter): EquipmentAggregateResult
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  eventDefinitionsAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
  equipmentSpecificationsAggregate(
    filter: EquipmentSpecificationFilter
  ): EquipmentSpecificationAggregateResult
  reasonsAggregate(filter: ReasonFilter): ReasonAggregateResult
  propertyList(filter: PropertyListFilter): [Property]
}

type EquipmentClassAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  labelMin: String
  labelMax: String
  displayNameMin: String
  displayNameMax: String
  descriptionMin: String
  descriptionMax: String
  addressTemplateMin: String
  addressTemplateMax: String
  imageMin: String
  imageMax: String
}

input EquipmentClassFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  label: StringHashFilter
  displayName: StringHashFilter
  description: StringHashFilter
  has: [EquipmentClassHasFilter]
  and: [EquipmentClassFilter]
  or: [EquipmentClassFilter]
  not: EquipmentClassFilter
}

enum EquipmentClassHasFilter {
  isActive
  name
  label
  displayName
  description
  parent
  children
  equipments
  properties
  eventDefinitions
  equipmentSpecifications
  reasons
  equipmentLevel
  addressTemplate
  image
  dashboardConfig
}

input EquipmentClassOrder {
  asc: EquipmentClassOrderable
  desc: EquipmentClassOrderable
  then: EquipmentClassOrder
}

enum EquipmentClassOrderable {
  name
  label
  displayName
  description
  addressTemplate
  image
}

input EquipmentClassPatch {
  isActive: Boolean
  name: String
  label: String
  displayName: String
  description: String
  parent: EquipmentClassRef
  children: [EquipmentClassRef]
  equipments: [EquipmentRef]
  properties: [PropertyRef]
  eventDefinitions: [EventDefinitionRef]
  equipmentSpecifications: [EquipmentSpecificationRef]
  reasons: [ReasonRef]
  equipmentLevel: EquipmentElementLevel
  addressTemplate: String
  image: String
  dashboardConfig: DashboardConfigRef
}

input EquipmentClassRef {
  id: ID
  isActive: Boolean
  name: String
  label: String
  displayName: String
  description: String
  parent: EquipmentClassRef
  children: [EquipmentClassRef]
  equipments: [EquipmentRef]
  properties: [PropertyRef]
  eventDefinitions: [EventDefinitionRef]
  equipmentSpecifications: [EquipmentSpecificationRef]
  reasons: [ReasonRef]
  equipmentLevel: EquipmentElementLevel
  addressTemplate: String
  image: String
  dashboardConfig: DashboardConfigRef
}

enum EquipmentElementLevel {
  Enterprise
  Site
  Area
  ProcessCell
  Unit
  ProductionLine
  WorkCell
  ProductionUnit
  Warehouse
  StorageZone
  StorageUnit
  WorkCenter
  WorkUnit
  EquipmentModule
  ControlModule
  Other
}

input EquipmentElementLevel_hash {
  eq: EquipmentElementLevel
  in: [EquipmentElementLevel]
}

input EquipmentFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  label: StringHashFilter
  displayName: StringHashFilter
  description: StringHashFilter
  erpAssetID: StringHashFilter
  equipmentLevel: EquipmentElementLevel_hash
  has: [EquipmentHasFilter]
  and: [EquipmentFilter]
  or: [EquipmentFilter]
  not: EquipmentFilter
}

enum EquipmentHasFilter {
  isActive
  userRoles
  name
  label
  displayName
  description
  erpAssetID
  parent
  children
  equipmentClass
  equipmentLevel
  equipmentActual
  properties
  propertyNameAliases
  carriers
  materialSubLots
  inventoryHandlingRules
  operationsRequests
  dataProvider
  dataProviderConnection
  addressTemplate
  timeZoneName
  workSpecifications
  workflowInstances
  workCalendar
  jobResponses
  jobOrders
  shipments
  shipmentItems
  orders
  events
  quantities
  allowAdhocWorklog
  reasons
  reasonOverrides
  propertyOverrides
  mpmEnableJobInterlock
  mpmPermissiveOutputName
  mpmEnableAutoIdentMatching
  mpmAutoIdentMatchSource
  mpmEnableSetupStartDetection
  mpmEnableSetupCloseDetection
  mpmEnableORCWarning
  mpmORCWarnTrigger
  mpmEnableORCRevokePermissive
  mpmORCRevokePermissiveTrigger
  mpmEnableORCBlockNextOrder
  mpmEnableCallMaintenanceEvent
  mpmEnableMaintenanceHandover
  mpmEnableManualShiftStart
  mpmEnableManualShiftEnd
  mpmEnableManualBreak
  mpmEnableManualPlannedMaint
  ocsEnabled
  ocsPageState
  ocsWorkflowSelector
  ocsChosenStopTime
  inflows
  outflows
}

type EquipmentNameAlias {
  id: ID!
  equipment(filter: EquipmentFilter): Equipment!
  alias: String!
  system: String!
}

type EquipmentNameAliasAggregateResult {
  count: Int
  aliasMin: String
  aliasMax: String
  systemMin: String
  systemMax: String
}

input EquipmentNameAliasFilter {
  id: [ID!]
  alias: StringFullTextFilter
  system: StringFullTextFilter
  has: [EquipmentNameAliasHasFilter]
  and: [EquipmentNameAliasFilter]
  or: [EquipmentNameAliasFilter]
  not: EquipmentNameAliasFilter
}

enum EquipmentNameAliasHasFilter {
  equipment
  alias
  system
}

input EquipmentNameAliasOrder {
  asc: EquipmentNameAliasOrderable
  desc: EquipmentNameAliasOrderable
  then: EquipmentNameAliasOrder
}

enum EquipmentNameAliasOrderable {
  alias
  system
}

input EquipmentNameAliasPatch {
  equipment: EquipmentRef
  alias: String
  system: String
}

input EquipmentNameAliasRef {
  id: ID
  equipment: EquipmentRef
  alias: String
  system: String
}

input EquipmentOrder {
  asc: EquipmentOrderable
  desc: EquipmentOrderable
  then: EquipmentOrder
}

enum EquipmentOrderable {
  name
  label
  displayName
  description
  erpAssetID
  dataProviderConnection
  addressTemplate
  timeZoneName
  mpmPermissiveOutputName
  mpmAutoIdentMatchSource
  ocsPageState
  ocsWorkflowSelector
  ocsChosenStopTime
}

input EquipmentPatch {
  isActive: Boolean
  userRoles: [UserRoleRef]
  name: String
  label: String
  displayName: String
  description: String
  erpAssetID: String
  parent: EquipmentRef
  children: [EquipmentRef]
  equipmentClass: EquipmentClassRef
  equipmentLevel: EquipmentElementLevel
  equipmentActual: [EquipmentActualRef]
  properties: [PropertyRef]
  propertyNameAliases: [PropertyNameAliasRef]
  carriers: [CarrierRef]
  materialSubLots: [MaterialSubLotRef]
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  operationsRequests: [OperationsRequestRef]
  dataProvider: DataProvider
  dataProviderConnection: String
  addressTemplate: String
  timeZoneName: String
  workSpecifications: [EquipmentSpecificationRef]
  workflowInstances: [WorkflowInstanceRef]
  workCalendar: WorkCalendarRef
  jobResponses: [JobResponseRef]
  jobOrders: [JobOrderRef]
  shipments: [ShipmentRef]
  shipmentItems: [ShipmentItemRef]
  orders: [OrderRef]
  events: [EventLogRef]
  quantities: [QuantityLogRef]
  allowAdhocWorklog: Boolean
  reasons: [ReasonRef]
  reasonOverrides: [EquipmentReasonOverrideRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  mpmEnableJobInterlock: Boolean
  mpmPermissiveOutputName: String
  mpmEnableAutoIdentMatching: Boolean
  mpmAutoIdentMatchSource: String
  mpmEnableSetupStartDetection: Boolean
  mpmEnableSetupCloseDetection: Boolean
  mpmEnableORCWarning: Boolean
  mpmORCWarnTrigger: mpmORCWarnTriggers
  mpmEnableORCRevokePermissive: Boolean
  mpmORCRevokePermissiveTrigger: mpmORCRevokeTriggers
  mpmEnableORCBlockNextOrder: Boolean
  mpmEnableCallMaintenanceEvent: Boolean
  mpmEnableMaintenanceHandover: Boolean
  mpmEnableManualShiftStart: Boolean
  mpmEnableManualShiftEnd: Boolean
  mpmEnableManualBreak: Boolean
  mpmEnableManualPlannedMaint: Boolean
  ocsEnabled: Boolean
  ocsPageState: String
  ocsWorkflowSelector: String
  ocsChosenStopTime: DateTime
  inflows: [EquipmentRelationRef]
  outflows: [EquipmentRelationRef]
}

type EquipmentPropertyOverride {
  id: ID!
  isActive: Boolean
  equipment(filter: EquipmentFilter): Equipment!
  property(filter: PropertyFilter): Property!
  address: String
  expression: String
  value: String
  storeHistory: Boolean
  ignore: Boolean
}

type EquipmentPropertyOverrideAggregateResult {
  count: Int
  addressMin: String
  addressMax: String
  expressionMin: String
  expressionMax: String
  valueMin: String
  valueMax: String
}

input EquipmentPropertyOverrideFilter {
  id: [ID!]
  isActive: Boolean
  has: [EquipmentPropertyOverrideHasFilter]
  and: [EquipmentPropertyOverrideFilter]
  or: [EquipmentPropertyOverrideFilter]
  not: EquipmentPropertyOverrideFilter
}

enum EquipmentPropertyOverrideHasFilter {
  isActive
  equipment
  property
  address
  expression
  value
  storeHistory
  ignore
}

input EquipmentPropertyOverrideOrder {
  asc: EquipmentPropertyOverrideOrderable
  desc: EquipmentPropertyOverrideOrderable
  then: EquipmentPropertyOverrideOrder
}

enum EquipmentPropertyOverrideOrderable {
  address
  expression
  value
}

input EquipmentPropertyOverridePatch {
  isActive: Boolean
  equipment: EquipmentRef
  property: PropertyRef
  address: String
  expression: String
  value: String
  storeHistory: Boolean
  ignore: Boolean
}

input EquipmentPropertyOverrideRef {
  id: ID
  isActive: Boolean
  equipment: EquipmentRef
  property: PropertyRef
  address: String
  expression: String
  value: String
  storeHistory: Boolean
  ignore: Boolean
}

# EquipmentReasonOverrides are used to make equipment specific changes to equipment class reasons.
# This allows 'Master Lists' of reasons to be defined on the equipment class and for overrides to the master
# reasons to be made at the equipment level
type EquipmentReasonOverride {
  id: ID!
  isActive: Boolean
  equipment(filter: EquipmentFilter): Equipment
  reason(filter: ReasonFilter): Reason
  ignore: Boolean
  standardValue: Float
}

type EquipmentReasonOverrideAggregateResult {
  count: Int
  standardValueMin: Float
  standardValueMax: Float
  standardValueSum: Float
  standardValueAvg: Float
}

input EquipmentReasonOverrideFilter {
  id: [ID!]
  isActive: Boolean
  has: [EquipmentReasonOverrideHasFilter]
  and: [EquipmentReasonOverrideFilter]
  or: [EquipmentReasonOverrideFilter]
  not: EquipmentReasonOverrideFilter
}

enum EquipmentReasonOverrideHasFilter {
  isActive
  equipment
  reason
  ignore
  standardValue
}

input EquipmentReasonOverrideOrder {
  asc: EquipmentReasonOverrideOrderable
  desc: EquipmentReasonOverrideOrderable
  then: EquipmentReasonOverrideOrder
}

enum EquipmentReasonOverrideOrderable {
  standardValue
}

input EquipmentReasonOverridePatch {
  isActive: Boolean
  equipment: EquipmentRef
  reason: ReasonRef
  ignore: Boolean
  standardValue: Float
}

input EquipmentReasonOverrideRef {
  id: ID
  isActive: Boolean
  equipment: EquipmentRef
  reason: ReasonRef
  ignore: Boolean
  standardValue: Float
}

input EquipmentRef {
  id: ID
  isActive: Boolean
  userRoles: [UserRoleRef]
  name: String
  label: String
  displayName: String
  description: String
  erpAssetID: String
  parent: EquipmentRef
  children: [EquipmentRef]
  equipmentClass: EquipmentClassRef
  equipmentLevel: EquipmentElementLevel
  equipmentActual: [EquipmentActualRef]
  properties: [PropertyRef]
  propertyNameAliases: [PropertyNameAliasRef]
  carriers: [CarrierRef]
  materialSubLots: [MaterialSubLotRef]
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  operationsRequests: [OperationsRequestRef]
  dataProvider: DataProvider
  dataProviderConnection: String
  addressTemplate: String
  timeZoneName: String
  workSpecifications: [EquipmentSpecificationRef]
  workflowInstances: [WorkflowInstanceRef]
  workCalendar: WorkCalendarRef
  jobResponses: [JobResponseRef]
  jobOrders: [JobOrderRef]
  shipments: [ShipmentRef]
  shipmentItems: [ShipmentItemRef]
  orders: [OrderRef]
  events: [EventLogRef]
  quantities: [QuantityLogRef]
  allowAdhocWorklog: Boolean
  reasons: [ReasonRef]
  reasonOverrides: [EquipmentReasonOverrideRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  mpmEnableJobInterlock: Boolean
  mpmPermissiveOutputName: String
  mpmEnableAutoIdentMatching: Boolean
  mpmAutoIdentMatchSource: String
  mpmEnableSetupStartDetection: Boolean
  mpmEnableSetupCloseDetection: Boolean
  mpmEnableORCWarning: Boolean
  mpmORCWarnTrigger: mpmORCWarnTriggers
  mpmEnableORCRevokePermissive: Boolean
  mpmORCRevokePermissiveTrigger: mpmORCRevokeTriggers
  mpmEnableORCBlockNextOrder: Boolean
  mpmEnableCallMaintenanceEvent: Boolean
  mpmEnableMaintenanceHandover: Boolean
  mpmEnableManualShiftStart: Boolean
  mpmEnableManualShiftEnd: Boolean
  mpmEnableManualBreak: Boolean
  mpmEnableManualPlannedMaint: Boolean
  ocsEnabled: Boolean
  ocsPageState: String
  ocsWorkflowSelector: String
  ocsChosenStopTime: DateTime
  inflows: [EquipmentRelationRef]
  outflows: [EquipmentRelationRef]
}

type EquipmentRelation {
  id: ID!
  isActive: Boolean
  from(filter: EquipmentFilter): Equipment!
  to(filter: EquipmentFilter): Equipment
  type: EquipmentRelationshipType!
}

type EquipmentRelationAggregateResult {
  count: Int
}

input EquipmentRelationFilter {
  id: [ID!]
  isActive: Boolean
  has: [EquipmentRelationHasFilter]
  and: [EquipmentRelationFilter]
  or: [EquipmentRelationFilter]
  not: EquipmentRelationFilter
}

enum EquipmentRelationHasFilter {
  isActive
  from
  to
  type
}

input EquipmentRelationPatch {
  isActive: Boolean
  from: EquipmentRef
  to: EquipmentRef
  type: EquipmentRelationshipType
}

input EquipmentRelationRef {
  id: ID
  isActive: Boolean
  from: EquipmentRef
  to: EquipmentRef
  type: EquipmentRelationshipType
}

enum EquipmentRelationshipType {
  PERMANENT
  TEMPORARY
}

type EquipmentSpecification {
  id: ID!
  isActive: Boolean
  jobOrder(filter: JobOrderFilter): JobOrder
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment
  equipment(filter: EquipmentFilter): Equipment
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass
  description: String
  quantity: Float
  uom(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type EquipmentSpecificationAggregateResult {
  count: Int
  descriptionMin: String
  descriptionMax: String
  quantityMin: Float
  quantityMax: Float
  quantitySum: Float
  quantityAvg: Float
}

input EquipmentSpecificationFilter {
  id: [ID!]
  isActive: Boolean
  has: [EquipmentSpecificationHasFilter]
  and: [EquipmentSpecificationFilter]
  or: [EquipmentSpecificationFilter]
  not: EquipmentSpecificationFilter
}

enum EquipmentSpecificationHasFilter {
  isActive
  jobOrder
  operationsSegment
  equipment
  equipmentClass
  description
  quantity
  uom
}

input EquipmentSpecificationOrder {
  asc: EquipmentSpecificationOrderable
  desc: EquipmentSpecificationOrderable
  then: EquipmentSpecificationOrder
}

enum EquipmentSpecificationOrderable {
  description
  quantity
}

input EquipmentSpecificationPatch {
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  description: String
  quantity: Float
  uom: UnitOfMeasureRef
}

input EquipmentSpecificationRef {
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  description: String
  quantity: Float
  uom: UnitOfMeasureRef
}

# Multiple equipment events can be defined for an Equipment Template.
type EventDefinition {
  id: ID!
  isActive: Boolean
  name: String!
  messageClass: MessageClass!
  triggerProperties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  triggerExpression: String!
  delayOption: Boolean
  delayTime: Int
  payloadProperties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  payloadFields(
    filter: PayloadFieldDefinitionFilter
    order: PayloadFieldDefinitionOrder
    first: Int
    offset: Int
  ): [PayloadFieldDefinition]
  orderStartRuleset(filter: OrderStartRulesetFilter): OrderStartRuleset
  stateEventRuleset(filter: StateEventRulesetFilter): StateEventRuleset
  materialEventRuleset(filter: MaterialEventRulesetFilter): MaterialEventRuleset
  transitionEventRuleset(
    filter: TransitionEventRulesetFilter
  ): TransitionEventRuleset
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass
  triggerPropertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  payloadPropertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  payloadFieldsAggregate(
    filter: PayloadFieldDefinitionFilter
  ): PayloadFieldDefinitionAggregateResult
}

type EventDefinitionAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  triggerExpressionMin: String
  triggerExpressionMax: String
  delayTimeMin: Int
  delayTimeMax: Int
  delayTimeSum: Int
  delayTimeAvg: Float
}

input EventDefinitionFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  has: [EventDefinitionHasFilter]
  and: [EventDefinitionFilter]
  or: [EventDefinitionFilter]
  not: EventDefinitionFilter
}

enum EventDefinitionHasFilter {
  isActive
  name
  messageClass
  triggerProperties
  triggerExpression
  delayOption
  delayTime
  payloadProperties
  payloadFields
  orderStartRuleset
  stateEventRuleset
  materialEventRuleset
  transitionEventRuleset
  equipmentClass
}

input EventDefinitionOrder {
  asc: EventDefinitionOrderable
  desc: EventDefinitionOrderable
  then: EventDefinitionOrder
}

enum EventDefinitionOrderable {
  name
  triggerExpression
  delayTime
}

input EventDefinitionPatch {
  isActive: Boolean
  name: String
  messageClass: MessageClass
  triggerProperties: [PropertyRef]
  triggerExpression: String
  delayOption: Boolean
  delayTime: Int
  payloadProperties: [PropertyRef]
  payloadFields: [PayloadFieldDefinitionRef]
  orderStartRuleset: OrderStartRulesetRef
  stateEventRuleset: StateEventRulesetRef
  materialEventRuleset: MaterialEventRulesetRef
  transitionEventRuleset: TransitionEventRulesetRef
  equipmentClass: EquipmentClassRef
}

input EventDefinitionRef {
  id: ID
  isActive: Boolean
  name: String
  messageClass: MessageClass
  triggerProperties: [PropertyRef]
  triggerExpression: String
  delayOption: Boolean
  delayTime: Int
  payloadProperties: [PropertyRef]
  payloadFields: [PayloadFieldDefinitionRef]
  orderStartRuleset: OrderStartRulesetRef
  stateEventRuleset: StateEventRulesetRef
  materialEventRuleset: MaterialEventRulesetRef
  transitionEventRuleset: TransitionEventRulesetRef
  equipmentClass: EquipmentClassRef
}

type EventLog {
  id: ID!
  isActive: Boolean
  jobResponse(filter: JobResponseFilter): JobResponse!
  equipment(filter: EquipmentFilter): Equipment
  startDateTime: DateTime
  endDateTime: DateTime
  duration: Float
  reasonCode: String
  reasonText: String
  reasonCategoryCode: String
  reasonValue: Float
  reasonValueUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  comments: String
}

type EventLogAggregateResult {
  count: Int
  startDateTimeMin: DateTime
  startDateTimeMax: DateTime
  endDateTimeMin: DateTime
  endDateTimeMax: DateTime
  durationMin: Float
  durationMax: Float
  durationSum: Float
  durationAvg: Float
  reasonCodeMin: String
  reasonCodeMax: String
  reasonTextMin: String
  reasonTextMax: String
  reasonCategoryCodeMin: String
  reasonCategoryCodeMax: String
  reasonValueMin: Float
  reasonValueMax: Float
  reasonValueSum: Float
  reasonValueAvg: Float
  commentsMin: String
  commentsMax: String
}

input EventLogFilter {
  id: [ID!]
  isActive: Boolean
  startDateTime: DateTimeFilter
  endDateTime: DateTimeFilter
  reasonCode: StringHashFilter
  reasonText: StringHashFilter
  reasonCategoryCode: StringHashFilter
  comments: StringHashFilter
  has: [EventLogHasFilter]
  and: [EventLogFilter]
  or: [EventLogFilter]
  not: EventLogFilter
}

enum EventLogHasFilter {
  isActive
  jobResponse
  equipment
  startDateTime
  endDateTime
  duration
  reasonCode
  reasonText
  reasonCategoryCode
  reasonValue
  reasonValueUoM
  comments
}

input EventLogOrder {
  asc: EventLogOrderable
  desc: EventLogOrderable
  then: EventLogOrder
}

enum EventLogOrderable {
  startDateTime
  endDateTime
  duration
  reasonCode
  reasonText
  reasonCategoryCode
  reasonValue
  comments
}

input EventLogPatch {
  isActive: Boolean
  jobResponse: JobResponseRef
  equipment: EquipmentRef
  startDateTime: DateTime
  endDateTime: DateTime
  duration: Float
  reasonCode: String
  reasonText: String
  reasonCategoryCode: String
  reasonValue: Float
  reasonValueUoM: UnitOfMeasureRef
  comments: String
}

input EventLogRef {
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  equipment: EquipmentRef
  startDateTime: DateTime
  endDateTime: DateTime
  duration: Float
  reasonCode: String
  reasonText: String
  reasonCategoryCode: String
  reasonValue: Float
  reasonValueUoM: UnitOfMeasureRef
  comments: String
}

type EventLogTs {
  equipment: Equipment
  eventTime: DateTime
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  ISO22400Status: String
  PackMLStatus: String
  reasonValue: Float
  reasonValueUoM: String
  comment: String
  previousTime: DateTime
}

# input for splitEventLog or updateEventLog methods
input EventLogTsInput {
  # a reference to the equipment the event is on
  equipment: ExtEquipmentRef!

  # the start time of the inputted event
  eventStartTime: DateTime!
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  packMLStatus: String
  reasonValue: Float
  reasonValueUoM: String
  comment: String
}

# An event from the eventLog
type EventsByField {
  # The start of the event
  startDateTime: DateTime

  # The end of the event
  endDateTime: DateTime

  # The elapsed time between startDateTime and endDateTime
  duration: Int
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: String
  packMLStatus: String
  comment: String

  # The id of the work calendar entry associated with this event
  shiftId: String

  # The description of the work calendar entry associated with this event
  shiftDescription: String
  shiftStartDateTime: DateTime
  shiftFinishDateTime: DateTime

  # Returns the duration if packML is execute, otherwise returns 0. Useful for visualisation tools
  availability: Int
}

# the filter for an eventsByField query
input EventsByFieldFilter {
  # limits the number of results that return
  topN: Int

  # when used with filterValue, returns all records except those that contain the value
  # specified by filterValue in the field specified by this variable
  filterField: String

  # when used with filterField, returns all records except those that contain the
  # value specified by this variable in the field specified by filterfield
  filterValue: String

  # returns all events between this timestamp and the timestamp specified by to.
  # If only from is specified, to defaults to the current time
  from: DateTime

  # returns all events between this timestamp and the timestamp specified by from.
  # If only from is specified, this value defaults to the current time
  to: DateTime

  # when true, changes the start time of the first response in the event list to be the start of the job response,
  # or the filter's from field if the original time is earlier than the modified time
  interpolateAtRangeBoundary: Boolean

  # if the the query result would be empty,
  # instead return the last result within the last 4 weeks of the start of the query
  findPreviousWhenEmpty: Boolean

  # records will only return if the field specified by this variable is null
  returnUnassignedField: String

  # will associate and split events based on work calendar entries when set to true
  provideShiftInformation: Boolean
}

# aggregated information about a group of events
type EventSummaryByReason {
  iSO22400Status: String
  packMLStatus: String
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: String
  comment: String

  # the number of events in the group
  count: Int

  # the total duration of the group of events
  durationSum: Int
}

# the filter for an eventSummaryByReason query
input EventSummaryByReasonFilter {
  # limits the number of results that return
  topN: Int

  # specifies the field that events will group on. the default value is reasonText
  groupBy: String

  # specifies whether the results should be sorted by duration or by count.
  # Valid inputs are 'duration' and 'count'
  sortBy: String

  # if set to true, will only perform grouping and aggregations on events that have
  # packmlStatus != execute
  downtimeOnly: Boolean
  from: DateTime
  to: DateTime
}

input ExtCarrierRef {
  id: ID
}

input ExtDeliveryRef {
  id: ID
}

input ExtEquipmentRef {
  id: ID
  name: String
}

input ExtJobResponseRef {
  id: ID
}

input ExtMaterialDefinitionRef {
  id: ID
  code: String
}

input ExtMaterialLotRef {
  id: ID
}

input ExtMaterialStatusRef {
  id: ID
  code: String
}

input ExtMaterialSubLotRef {
  id: ID
  code: String
}

input ExtPartnerRef {
  id: ID
}

input ExtShipmentItemRef {
  id: ID
}

input ExtShipmentRef {
  id: ID
}

input ExtUnitOfMeasureRef {
  id: ID
}

input ExtUserRef {
  id: ID
  username: String
}

input ExtWorkflowNodeInstanceRef {
  id: String!
}

input ExtWorkflowPropertyRef {
  name: String!
  value: String!
}

input ExtWorkflowSpecificationRef {
  id: String!
}

input FloatFilter {
  eq: Float
  in: [Float]
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: FloatRange
}

input FloatRange {
  min: Float!
  max: Float!
}

type Form {
  id: ID!
  isActive: Boolean
  name: String!
  workflowNodes(
    filter: WorkflowNodeFilter
    order: WorkflowNodeOrder
    first: Int
    offset: Int
  ): [WorkflowNode]
  jsonSchema: String
  uiSchema: String
  workflowNodesAggregate(
    filter: WorkflowNodeFilter
  ): WorkflowNodeAggregateResult
}

type FormAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  jsonSchemaMin: String
  jsonSchemaMax: String
  uiSchemaMin: String
  uiSchemaMax: String
}

input FormFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  has: [FormHasFilter]
  and: [FormFilter]
  or: [FormFilter]
  not: FormFilter
}

enum FormHasFilter {
  isActive
  name
  workflowNodes
  jsonSchema
  uiSchema
}

input FormOrder {
  asc: FormOrderable
  desc: FormOrderable
  then: FormOrder
}

enum FormOrderable {
  name
  jsonSchema
  uiSchema
}

input FormPatch {
  isActive: Boolean
  workflowNodes: [WorkflowNodeRef]
  jsonSchema: String
  uiSchema: String
}

input FormRef {
  id: ID
  isActive: Boolean
  name: String
  workflowNodes: [WorkflowNodeRef]
  jsonSchema: String
  uiSchema: String
}

enum Frequency {
  YEARLY
  MONTHLY
  WEEKLY
  DAILY
  HOURLY
  MINUTELY
  SECONDLY
}

type GeneralLedgerAccount {
  id: ID!
  code: String!
  name: String
  type: String
}

type GeneralLedgerAccountAggregateResult {
  count: Int
  codeMin: String
  codeMax: String
  nameMin: String
  nameMax: String
  typeMin: String
  typeMax: String
}

input GeneralLedgerAccountFilter {
  id: [ID!]
  code: StringHashFilter
  has: [GeneralLedgerAccountHasFilter]
  and: [GeneralLedgerAccountFilter]
  or: [GeneralLedgerAccountFilter]
  not: GeneralLedgerAccountFilter
}

enum GeneralLedgerAccountHasFilter {
  code
  name
  type
}

input GeneralLedgerAccountOrder {
  asc: GeneralLedgerAccountOrderable
  desc: GeneralLedgerAccountOrderable
  then: GeneralLedgerAccountOrder
}

enum GeneralLedgerAccountOrderable {
  code
  name
  type
}

input GeneralLedgerAccountPatch {
  name: String
  type: String
}

input GeneralLedgerAccountRef {
  id: ID
  code: String
  name: String
  type: String
}

input GenerateMutationParams {
  add: Boolean
  update: Boolean
  delete: Boolean
}

input GenerateQueryParams {
  get: Boolean
  query: Boolean
  password: Boolean
  aggregate: Boolean
}

input GetPackingReturnInstructionsPDFInput {
  OrderNumber: String!
  SerialNumbers: [String!]!
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

enum IncoTerms {
  DAP
  DDP
  CPT
}

type InputError {
  message: String
}

# The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
# Int64 can represent values in range [-(2^63),(2^63 - 1)].
scalar Int64

input Int64Filter {
  eq: Int64
  in: [Int64]
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
  between: Int64Range
}

input Int64Range {
  min: Int64!
  max: Int64!
}

type InterfaceMessageLog {
  id: ID!
  createdDateTime: DateTime
  level: String
  message: String
  component: String
  status: String
  errorMessage: String
  payload: String
}

type InterfaceMessageLogAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  levelMin: String
  levelMax: String
  messageMin: String
  messageMax: String
  componentMin: String
  componentMax: String
  statusMin: String
  statusMax: String
  errorMessageMin: String
  errorMessageMax: String
  payloadMin: String
  payloadMax: String
}

input InterfaceMessageLogFilter {
  id: [ID!]
  createdDateTime: DateTimeFilter
  level: StringTermFilter
  message: StringTermFilter
  component: StringTermFilter
  status: StringTermFilter
  has: [InterfaceMessageLogHasFilter]
  and: [InterfaceMessageLogFilter]
  or: [InterfaceMessageLogFilter]
  not: InterfaceMessageLogFilter
}

enum InterfaceMessageLogHasFilter {
  createdDateTime
  level
  message
  component
  status
  errorMessage
  payload
}

input InterfaceMessageLogOrder {
  asc: InterfaceMessageLogOrderable
  desc: InterfaceMessageLogOrderable
  then: InterfaceMessageLogOrder
}

enum InterfaceMessageLogOrderable {
  createdDateTime
  level
  message
  component
  status
  errorMessage
  payload
}

input InterfaceMessageLogPatch {
  createdDateTime: DateTime
  level: String
  message: String
  component: String
  status: String
  errorMessage: String
  payload: String
}

input InterfaceMessageLogRef {
  id: ID
  createdDateTime: DateTime
  level: String
  message: String
  component: String
  status: String
  errorMessage: String
  payload: String
}

input IntersectsFilter {
  polygon: PolygonRef
  multiPolygon: MultiPolygonRef
}

input IntFilter {
  eq: Int
  in: [Int]
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: IntRange
}

input IntRange {
  min: Int!
  max: Int!
}

type InventoryHandlingPolicy {
  id: ID!
  isActive: Boolean
  name: String!
  materialClass(
    filter: MaterialClassFilter
    order: MaterialClassOrder
    first: Int
    offset: Int
  ): [MaterialClass]
  verifySerialNumberOnReceipt: Boolean
  verifySerialNumberOnPacking: Boolean
  trackBySerialNumber: Boolean
  trackByCarrier: Boolean
  rules(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  materialClassAggregate(
    filter: MaterialClassFilter
  ): MaterialClassAggregateResult
  rulesAggregate(
    filter: InventoryHandlingRuleFilter
  ): InventoryHandlingRuleAggregateResult
}

type InventoryHandlingPolicyAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input InventoryHandlingPolicyFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  has: [InventoryHandlingPolicyHasFilter]
  and: [InventoryHandlingPolicyFilter]
  or: [InventoryHandlingPolicyFilter]
  not: InventoryHandlingPolicyFilter
}

enum InventoryHandlingPolicyHasFilter {
  isActive
  name
  materialClass
  verifySerialNumberOnReceipt
  verifySerialNumberOnPacking
  trackBySerialNumber
  trackByCarrier
  rules
}

input InventoryHandlingPolicyOrder {
  asc: InventoryHandlingPolicyOrderable
  desc: InventoryHandlingPolicyOrderable
  then: InventoryHandlingPolicyOrder
}

enum InventoryHandlingPolicyOrderable {
  name
}

input InventoryHandlingPolicyPatch {
  isActive: Boolean
  materialClass: [MaterialClassRef]
  verifySerialNumberOnReceipt: Boolean
  verifySerialNumberOnPacking: Boolean
  trackBySerialNumber: Boolean
  trackByCarrier: Boolean
  rules: [InventoryHandlingRuleRef]
}

input InventoryHandlingPolicyRef {
  id: ID
  isActive: Boolean
  name: String
  materialClass: [MaterialClassRef]
  verifySerialNumberOnReceipt: Boolean
  verifySerialNumberOnPacking: Boolean
  trackBySerialNumber: Boolean
  trackByCarrier: Boolean
  rules: [InventoryHandlingRuleRef]
}

type InventoryHandlingRule {
  id: ID!
  isActive: Boolean
  customer(filter: PartnerFilter): Partner!
  stockType: StockType!
  warehouse(
    filter: EquipmentFilter
    order: EquipmentOrder
    first: Int
    offset: Int
  ): [Equipment!]!
  stateModel(filter: MaterialStateModelFilter): MaterialStateModel!
  inventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
  ): InventoryHandlingPolicy!
  inventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    order: InventoryHoldingPolicyOrder
    first: Int
    offset: Int
  ): [InventoryHoldingPolicy]
  warehouseAggregate(filter: EquipmentFilter): EquipmentAggregateResult
  inventoryHoldingPolicyAggregate(
    filter: InventoryHoldingPolicyFilter
  ): InventoryHoldingPolicyAggregateResult
}

type InventoryHandlingRuleAggregateResult {
  count: Int
}

input InventoryHandlingRuleFilter {
  id: [ID!]
  isActive: Boolean
  stockType: StockType_hash
  has: [InventoryHandlingRuleHasFilter]
  and: [InventoryHandlingRuleFilter]
  or: [InventoryHandlingRuleFilter]
  not: InventoryHandlingRuleFilter
}

enum InventoryHandlingRuleHasFilter {
  isActive
  customer
  stockType
  warehouse
  stateModel
  inventoryHandlingPolicy
  inventoryHoldingPolicy
}

input InventoryHandlingRulePatch {
  isActive: Boolean
  customer: PartnerRef
  stockType: StockType
  warehouse: [EquipmentRef!]
  stateModel: MaterialStateModelRef
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
}

input InventoryHandlingRuleRef {
  id: ID
  isActive: Boolean
  customer: PartnerRef
  stockType: StockType
  warehouse: [EquipmentRef!]
  stateModel: MaterialStateModelRef
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
}

# The settings used to plan for when more material should be processed or purchased
type InventoryHoldingPolicy {
  id: ID!
  isActive: Boolean
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
  inventoryHandlingRule(
    filter: InventoryHandlingRuleFilter
  ): InventoryHandlingRule!
  materialStatus(filter: MaterialStatusFilter): MaterialStatus!
  inventoryMax: Int
  inventoryMin: Int
}

type InventoryHoldingPolicyAggregateResult {
  count: Int
  inventoryMaxMin: Int
  inventoryMaxMax: Int
  inventoryMaxSum: Int
  inventoryMaxAvg: Float
  inventoryMinMin: Int
  inventoryMinMax: Int
  inventoryMinSum: Int
  inventoryMinAvg: Float
}

input InventoryHoldingPolicyFilter {
  id: [ID!]
  isActive: Boolean
  has: [InventoryHoldingPolicyHasFilter]
  and: [InventoryHoldingPolicyFilter]
  or: [InventoryHoldingPolicyFilter]
  not: InventoryHoldingPolicyFilter
}

enum InventoryHoldingPolicyHasFilter {
  isActive
  material
  inventoryHandlingRule
  materialStatus
  inventoryMax
  inventoryMin
}

input InventoryHoldingPolicyOrder {
  asc: InventoryHoldingPolicyOrderable
  desc: InventoryHoldingPolicyOrderable
  then: InventoryHoldingPolicyOrder
}

enum InventoryHoldingPolicyOrderable {
  inventoryMax
  inventoryMin
}

input InventoryHoldingPolicyPatch {
  isActive: Boolean
  material: MaterialDefinitionRef
  inventoryHandlingRule: InventoryHandlingRuleRef
  materialStatus: MaterialStatusRef
  inventoryMax: Int
  inventoryMin: Int
}

input InventoryHoldingPolicyRef {
  id: ID
  isActive: Boolean
  material: MaterialDefinitionRef
  inventoryHandlingRule: InventoryHandlingRuleRef
  materialStatus: MaterialStatusRef
  inventoryMax: Int
  inventoryMin: Int
}

type InventoryTransaction {
  user: User
  owner: Partner
  timestamp: DateTime!
  effectiveTimestamp: DateTime
  materialSubLot: MaterialSubLot
  carrier: Carrier
  status: MaterialStatus!
  storageLocation: Equipment
  material: MaterialDefinition
  materialUse: MaterialUse
  shipmentItem: ShipmentItem
  quantity: Float!
  jobResponse: JobResponse
  shipment: Shipment
  materialLot: MaterialLot
  reason: String
  comment: String
}

input InventoryTransactionInput {
  user: ExtUserRef
  owner: ExtPartnerRef
  effectiveDateTime: DateTime
  materialSubLot: ExtMaterialSubLotRef
  carrier: ExtCarrierRef
  status: ExtMaterialStatusRef
  storageLocation: ExtEquipmentRef
  material: ExtMaterialDefinitionRef
  materialUse: MaterialUse
  shipment: ExtShipmentRef
  shipmentItem: ExtShipmentItemRef
  quantity: Float
}

input InventoryTransactionsRawFilter {
  materialSubLot: ExtMaterialSubLotRef
  carrier: ExtCarrierRef
  material: ExtMaterialDefinitionRef
  storageLocation: ExtEquipmentRef
  status: ExtMaterialStatusRef
  shipment: ExtShipmentRef
  shipmentItem: ExtShipmentItemRef
  jobResponse: ExtJobResponseRef
  from: DateTime
  to: DateTime
}

type JobOrder {
  id: ID!
  isActive: Boolean
  createdDateTime: DateTime
  name: String!
  version: String
  description: String
  parent(filter: JobOrderFilter): JobOrder
  children(
    filter: JobOrderFilter
    order: JobOrderOrder
    first: Int
    offset: Int
  ): [JobOrder]
  workType: WorkType
  workDefinitionType: String
  duration: Float
  durationUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  materialSpecifications(
    filter: MaterialSpecificationFilter
    order: MaterialSpecificationOrder
    first: Int
    offset: Int
  ): [MaterialSpecification]
  equipmentSpecifications(
    filter: EquipmentSpecificationFilter
    order: EquipmentSpecificationOrder
    first: Int
    offset: Int
  ): [EquipmentSpecification]
  personnelSpecifications(
    filter: PersonnelSpecificationFilter
    order: PersonnelSpecificationOrder
    first: Int
    offset: Int
  ): [PersonnelSpecification]
  parameterSpecifications(
    filter: ParameterSpecificationFilter
    order: ParameterSpecificationOrder
    first: Int
    offset: Int
  ): [ParameterSpecification]
  scheduledStartDateTime: DateTime
  scheduledEndDateTime: DateTime
  scheduledDuration: Float
  equipment(filter: EquipmentFilter): Equipment
  quantity: Float
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  priority: Int
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  hierarchyScope: String
  dispatchStatus: DispatchStatus
  operationsRequest(filter: OperationsRequestFilter): OperationsRequest
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment
  jobResponses(
    filter: JobResponseFilter
    order: JobResponseOrder
    first: Int
    offset: Int
  ): [JobResponse]
  jobOrderNotes(
    filter: JobOrderNoteFilter
    order: JobOrderNoteOrder
    first: Int
    offset: Int
  ): [JobOrderNote]
  inflows(
    filter: JobOrderDependencyFilter
    order: JobOrderDependencyOrder
    first: Int
    offset: Int
  ): [JobOrderDependency]
  outflows(
    filter: JobOrderDependencyFilter
    order: JobOrderDependencyOrder
    first: Int
    offset: Int
  ): [JobOrderDependency]
  previous(
    filter: JobOrderFilter
    order: JobOrderOrder
    first: Int
    offset: Int
  ): [JobOrder]
  next(
    filter: JobOrderFilter
    order: JobOrderOrder
    first: Int
    offset: Int
  ): [JobOrder]
  childrenAggregate(filter: JobOrderFilter): JobOrderAggregateResult
  materialSpecificationsAggregate(
    filter: MaterialSpecificationFilter
  ): MaterialSpecificationAggregateResult
  equipmentSpecificationsAggregate(
    filter: EquipmentSpecificationFilter
  ): EquipmentSpecificationAggregateResult
  personnelSpecificationsAggregate(
    filter: PersonnelSpecificationFilter
  ): PersonnelSpecificationAggregateResult
  parameterSpecificationsAggregate(
    filter: ParameterSpecificationFilter
  ): ParameterSpecificationAggregateResult
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  jobResponsesAggregate(filter: JobResponseFilter): JobResponseAggregateResult
  jobOrderNotesAggregate(
    filter: JobOrderNoteFilter
  ): JobOrderNoteAggregateResult
  inflowsAggregate(
    filter: JobOrderDependencyFilter
  ): JobOrderDependencyAggregateResult
  outflowsAggregate(
    filter: JobOrderDependencyFilter
  ): JobOrderDependencyAggregateResult
  previousAggregate(filter: JobOrderFilter): JobOrderAggregateResult
  nextAggregate(filter: JobOrderFilter): JobOrderAggregateResult
  lastEvent(filter: LastEventFilter): EventsByField
}

type JobOrderAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  nameMin: String
  nameMax: String
  versionMin: String
  versionMax: String
  descriptionMin: String
  descriptionMax: String
  workDefinitionTypeMin: String
  workDefinitionTypeMax: String
  durationMin: Float
  durationMax: Float
  durationSum: Float
  durationAvg: Float
  scheduledStartDateTimeMin: DateTime
  scheduledStartDateTimeMax: DateTime
  scheduledEndDateTimeMin: DateTime
  scheduledEndDateTimeMax: DateTime
  scheduledDurationMin: Float
  scheduledDurationMax: Float
  scheduledDurationSum: Float
  scheduledDurationAvg: Float
  quantityMin: Float
  quantityMax: Float
  quantitySum: Float
  quantityAvg: Float
  priorityMin: Int
  priorityMax: Int
  prioritySum: Int
  priorityAvg: Float
  hierarchyScopeMin: String
  hierarchyScopeMax: String
}

#  Defines the planned relationship between JobOrders. The JobOrderDependency is created from a copy
# of the SegmentDependency during the production dispatch activity
type JobOrderDependency {
  id: ID!
  isActive: Boolean
  description: String
  from(filter: JobOrderFilter): JobOrder!
  to(filter: JobOrderFilter): JobOrder!
  dependencyType: DependencyType
  dependencyFactor: Float
  factorUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  condition: String
  segmentDependency(filter: SegmentDependencyFilter): SegmentDependency
}

type JobOrderDependencyAggregateResult {
  count: Int
  descriptionMin: String
  descriptionMax: String
  dependencyFactorMin: Float
  dependencyFactorMax: Float
  dependencyFactorSum: Float
  dependencyFactorAvg: Float
  conditionMin: String
  conditionMax: String
}

input JobOrderDependencyFilter {
  id: [ID!]
  isActive: Boolean
  has: [JobOrderDependencyHasFilter]
  and: [JobOrderDependencyFilter]
  or: [JobOrderDependencyFilter]
  not: JobOrderDependencyFilter
}

enum JobOrderDependencyHasFilter {
  isActive
  description
  from
  to
  dependencyType
  dependencyFactor
  factorUoM
  condition
  segmentDependency
}

input JobOrderDependencyOrder {
  asc: JobOrderDependencyOrderable
  desc: JobOrderDependencyOrderable
  then: JobOrderDependencyOrder
}

enum JobOrderDependencyOrderable {
  description
  dependencyFactor
  condition
}

input JobOrderDependencyPatch {
  isActive: Boolean
  description: String
  from: JobOrderRef
  to: JobOrderRef
  dependencyType: DependencyType
  dependencyFactor: Float
  factorUoM: UnitOfMeasureRef
  condition: String
  segmentDependency: SegmentDependencyRef
}

input JobOrderDependencyRef {
  id: ID
  isActive: Boolean
  description: String
  from: JobOrderRef
  to: JobOrderRef
  dependencyType: DependencyType
  dependencyFactor: Float
  factorUoM: UnitOfMeasureRef
  condition: String
  segmentDependency: SegmentDependencyRef
}

#  Define the allowable DispatchStatus transitions for JobOrder.dispatchStatus
type JobOrderDispatchStateModel {
  fromStatus: DispatchStatus!
  allowedTransition: [DispatchStatus]
}

type JobOrderDispatchStateModelAggregateResult {
  count: Int
}

input JobOrderDispatchStateModelFilter {
  has: [JobOrderDispatchStateModelHasFilter]
  and: [JobOrderDispatchStateModelFilter]
  or: [JobOrderDispatchStateModelFilter]
  not: JobOrderDispatchStateModelFilter
}

enum JobOrderDispatchStateModelHasFilter {
  fromStatus
  allowedTransition
}

input JobOrderDispatchStateModelPatch {
  fromStatus: DispatchStatus
  allowedTransition: [DispatchStatus]
}

input JobOrderDispatchStateModelRef {
  fromStatus: DispatchStatus
  allowedTransition: [DispatchStatus]
}

input JobOrderFilter {
  id: [ID!]
  isActive: Boolean
  createdDateTime: DateTimeFilter
  name: StringHashFilter_StringRegExpFilter
  description: StringHashFilter
  workType: WorkType_hash
  workDefinitionType: StringHashFilter
  scheduledStartDateTime: DateTimeFilter
  scheduledEndDateTime: DateTimeFilter
  dispatchStatus: DispatchStatus_hash
  has: [JobOrderHasFilter]
  and: [JobOrderFilter]
  or: [JobOrderFilter]
  not: JobOrderFilter
}

enum JobOrderHasFilter {
  isActive
  createdDateTime
  name
  version
  description
  parent
  children
  workType
  workDefinitionType
  duration
  durationUoM
  materialSpecifications
  equipmentSpecifications
  personnelSpecifications
  parameterSpecifications
  scheduledStartDateTime
  scheduledEndDateTime
  scheduledDuration
  equipment
  quantity
  quantityUoM
  priority
  properties
  hierarchyScope
  dispatchStatus
  operationsRequest
  operationsSegment
  jobResponses
  jobOrderNotes
  inflows
  outflows
  previous
  next
}

type JobOrderNote {
  id: ID!
  comment: String
  createdDateTime: DateTime
  editedDateTime: DateTime
  createdBy(filter: UserFilter): User
  modifiedBy(filter: UserFilter): User
  isActive: Boolean
  jobOrder(filter: JobOrderFilter): JobOrder
}

type JobOrderNoteAggregateResult {
  count: Int
  commentMin: String
  commentMax: String
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  editedDateTimeMin: DateTime
  editedDateTimeMax: DateTime
}

input JobOrderNoteFilter {
  id: [ID!]
  has: [JobOrderNoteHasFilter]
  and: [JobOrderNoteFilter]
  or: [JobOrderNoteFilter]
  not: JobOrderNoteFilter
}

enum JobOrderNoteHasFilter {
  comment
  createdDateTime
  editedDateTime
  createdBy
  modifiedBy
  isActive
  jobOrder
}

input JobOrderNoteOrder {
  asc: JobOrderNoteOrderable
  desc: JobOrderNoteOrderable
  then: JobOrderNoteOrder
}

enum JobOrderNoteOrderable {
  comment
  createdDateTime
  editedDateTime
}

input JobOrderNotePatch {
  comment: String
  createdDateTime: DateTime
  editedDateTime: DateTime
  createdBy: UserRef
  modifiedBy: UserRef
  isActive: Boolean
  jobOrder: JobOrderRef
}

input JobOrderNoteRef {
  id: ID
  comment: String
  createdDateTime: DateTime
  editedDateTime: DateTime
  createdBy: UserRef
  modifiedBy: UserRef
  isActive: Boolean
  jobOrder: JobOrderRef
}

input JobOrderOrder {
  asc: JobOrderOrderable
  desc: JobOrderOrderable
  then: JobOrderOrder
}

enum JobOrderOrderable {
  createdDateTime
  name
  version
  description
  workDefinitionType
  duration
  scheduledStartDateTime
  scheduledEndDateTime
  scheduledDuration
  quantity
  priority
  hierarchyScope
}

input JobOrderPatch {
  isActive: Boolean
  createdDateTime: DateTime
  version: String
  description: String
  parent: JobOrderRef
  children: [JobOrderRef]
  workType: WorkType
  workDefinitionType: String
  duration: Float
  durationUoM: UnitOfMeasureRef
  materialSpecifications: [MaterialSpecificationRef]
  equipmentSpecifications: [EquipmentSpecificationRef]
  personnelSpecifications: [PersonnelSpecificationRef]
  parameterSpecifications: [ParameterSpecificationRef]
  scheduledStartDateTime: DateTime
  scheduledEndDateTime: DateTime
  scheduledDuration: Float
  equipment: EquipmentRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  priority: Int
  properties: [PropertyRef]
  hierarchyScope: String
  dispatchStatus: DispatchStatus
  operationsRequest: OperationsRequestRef
  operationsSegment: OperationsSegmentRef
  jobResponses: [JobResponseRef]
  jobOrderNotes: [JobOrderNoteRef]
  inflows: [JobOrderDependencyRef]
  outflows: [JobOrderDependencyRef]
  previous: [JobOrderRef]
  next: [JobOrderRef]
}

input JobOrderRef {
  id: ID
  isActive: Boolean
  createdDateTime: DateTime
  name: String
  version: String
  description: String
  parent: JobOrderRef
  children: [JobOrderRef]
  workType: WorkType
  workDefinitionType: String
  duration: Float
  durationUoM: UnitOfMeasureRef
  materialSpecifications: [MaterialSpecificationRef]
  equipmentSpecifications: [EquipmentSpecificationRef]
  personnelSpecifications: [PersonnelSpecificationRef]
  parameterSpecifications: [ParameterSpecificationRef]
  scheduledStartDateTime: DateTime
  scheduledEndDateTime: DateTime
  scheduledDuration: Float
  equipment: EquipmentRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  priority: Int
  properties: [PropertyRef]
  hierarchyScope: String
  dispatchStatus: DispatchStatus
  operationsRequest: OperationsRequestRef
  operationsSegment: OperationsSegmentRef
  jobResponses: [JobResponseRef]
  jobOrderNotes: [JobOrderNoteRef]
  inflows: [JobOrderDependencyRef]
  outflows: [JobOrderDependencyRef]
  previous: [JobOrderRef]
  next: [JobOrderRef]
}

type JobOrderStaging {
  orderNo: String
  errList: [String]
  isValid: Boolean
  segment: String
  equipment: String
  operationsRequest: String
}

input JobOrderStagingInput {
  orderNo: String!
  segment: String!
  operationsRequest: String!
}

input JobOrderStatusPatch {
  dispatchStatus: DispatchStatus
}

type JobResponse {
  id: ID!
  isActive: Boolean
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  operator(filter: UserFilter): User
  equipment(filter: EquipmentFilter): Equipment
  startDateTime: DateTime
  endDateTime: DateTime
  productionDate: String
  actualDuration: Float
  jobOrder(filter: JobOrderFilter): JobOrder
  events(
    filter: EventLogFilter
    order: EventLogOrder
    first: Int
    offset: Int
  ): [EventLog]
  quantities(
    filter: QuantityLogFilter
    order: QuantityLogOrder
    first: Int
    offset: Int
  ): [QuantityLog]
  personnelActual(
    filter: PersonnelActualFilter
    order: PersonnelActualOrder
    first: Int
    offset: Int
  ): [PersonnelActual]
  equipmentActual(
    filter: EquipmentActualFilter
    order: EquipmentActualOrder
    first: Int
    offset: Int
  ): [EquipmentActual]
  materialActual(
    filter: MaterialActualFilter
    order: MaterialActualOrder
    first: Int
    offset: Int
  ): [MaterialActual]
  eventsAggregate(filter: EventLogFilter): EventLogAggregateResult
  quantitiesAggregate(filter: QuantityLogFilter): QuantityLogAggregateResult
  personnelActualAggregate(
    filter: PersonnelActualFilter
  ): PersonnelActualAggregateResult
  equipmentActualAggregate(
    filter: EquipmentActualFilter
  ): EquipmentActualAggregateResult
  materialActualAggregate(
    filter: MaterialActualFilter
  ): MaterialActualAggregateResult
  duration: Float

  # deprecated
  eventList: [EventLog]
  eventsByField(filter: EventsByFieldFilter): [EventsByField]
  eventSummaryByReason(
    filter: EventSummaryByReasonFilter
  ): [EventSummaryByReason]
  quantitySummary(filter: QuantitySummaryFilter): [QuantitySummary]
  runRateSummary(filter: RunRateFilter): RunRateSummary
  maintenanceCalls: [MaintenanceLog]
}

type JobResponseAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  startDateTimeMin: DateTime
  startDateTimeMax: DateTime
  endDateTimeMin: DateTime
  endDateTimeMax: DateTime
  productionDateMin: String
  productionDateMax: String
  actualDurationMin: Float
  actualDurationMax: Float
  actualDurationSum: Float
  actualDurationAvg: Float
}

input JobResponseFilter {
  id: [ID!]
  isActive: Boolean
  startDateTime: DateTimeFilter
  endDateTime: DateTimeFilter
  productionDate: StringHashFilter
  has: [JobResponseHasFilter]
  and: [JobResponseFilter]
  or: [JobResponseFilter]
  not: JobResponseFilter
}

enum JobResponseHasFilter {
  isActive
  createdDateTime
  modifiedDateTime
  operator
  equipment
  startDateTime
  endDateTime
  productionDate
  actualDuration
  jobOrder
  events
  quantities
  personnelActual
  equipmentActual
  materialActual
}

input JobResponseOrder {
  asc: JobResponseOrderable
  desc: JobResponseOrderable
  then: JobResponseOrder
}

enum JobResponseOrderable {
  createdDateTime
  modifiedDateTime
  startDateTime
  endDateTime
  productionDate
  actualDuration
}

input JobResponsePatch {
  isActive: Boolean
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  operator: UserRef
  equipment: EquipmentRef
  startDateTime: DateTime
  endDateTime: DateTime
  productionDate: String
  actualDuration: Float
  jobOrder: JobOrderRef
  events: [EventLogRef]
  quantities: [QuantityLogRef]
  personnelActual: [PersonnelActualRef]
  equipmentActual: [EquipmentActualRef]
  materialActual: [MaterialActualRef]
}

input JobResponseRef {
  id: ID
  isActive: Boolean
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  operator: UserRef
  equipment: EquipmentRef
  startDateTime: DateTime
  endDateTime: DateTime
  productionDate: String
  actualDuration: Float
  jobOrder: JobOrderRef
  events: [EventLogRef]
  quantities: [QuantityLogRef]
  personnelActual: [PersonnelActualRef]
  equipmentActual: [EquipmentActualRef]
  materialActual: [MaterialActualRef]
}

type Kpi {
  effectiveness: Float
  effectivenessUnit: String
  availability: Float
  availabilityUnit: String
  quality: Float
  qualityUnit: String
  OEE: Float
  OEEUnit: String
  equipment: Equipment
  rawData: RawKpi
}

type KpiByWorkCalendarEntry {
  effectiveness: Float
  effectivenessUnit: String
  availability: Float
  availabilityUnit: String
  quality: Float
  qualityUnit: String
  OEE: Float
  OEEUnit: String
  workCalendarEntry: WorkCalendarEntry
  equipment: Equipment
  rawData: RawKpi
}

input LastEventFilter {
  includeField: String
  includeValue: String
}

# Store the heartbeat timestamps of connected libre-services.
# microservices can subscribe to this entity to check the status of their subscription
type LibreService {
  id: ID!
  name: String!
  heartbeat: DateTime
}

type LibreServiceAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  heartbeatMin: DateTime
  heartbeatMax: DateTime
}

input LibreServiceFilter {
  id: [ID!]
  name: StringHashFilter
  has: [LibreServiceHasFilter]
  and: [LibreServiceFilter]
  or: [LibreServiceFilter]
  not: LibreServiceFilter
}

enum LibreServiceHasFilter {
  name
  heartbeat
}

input LibreServiceOrder {
  asc: LibreServiceOrderable
  desc: LibreServiceOrderable
  then: LibreServiceOrder
}

enum LibreServiceOrderable {
  name
  heartbeat
}

input LibreServicePatch {
  heartbeat: DateTime
}

input LibreServiceRef {
  id: ID
  name: String
  heartbeat: DateTime
}

enum MachineState {
  Stopped
  Resetting
  Idle
  Starting
  Execute
  Unholding
  Held
  Holding
  Completing
  Complete
  Unsuspending
  Suspended
  Suspending
  Aborting
  Aborted
  Clearing
  Stopping
}

# An event from the maintenanceLog
type MaintenanceLog {
  time: DateTime
  requestType: String
  comment: String
  priority: String
  state: String
  type: String
  workflowInstanceID: String
}

type MaterialActual {
  id: ID!
  isActive: Boolean
  jobResponse(filter: JobResponseFilter): JobResponse!
  materialDefinition(filter: MaterialDefinitionFilter): MaterialDefinition
  materialLot(filter: MaterialLotFilter): MaterialLot
  materialSubLot(filter: MaterialSubLotFilter): MaterialSubLot
  materialUse: MaterialUse
  quantity: Float
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type MaterialActualAggregateResult {
  count: Int
  quantityMin: Float
  quantityMax: Float
  quantitySum: Float
  quantityAvg: Float
}

input MaterialActualFilter {
  id: [ID!]
  isActive: Boolean
  has: [MaterialActualHasFilter]
  and: [MaterialActualFilter]
  or: [MaterialActualFilter]
  not: MaterialActualFilter
}

enum MaterialActualHasFilter {
  isActive
  jobResponse
  materialDefinition
  materialLot
  materialSubLot
  materialUse
  quantity
  quantityUoM
}

input MaterialActualOrder {
  asc: MaterialActualOrderable
  desc: MaterialActualOrderable
  then: MaterialActualOrder
}

enum MaterialActualOrderable {
  quantity
}

input MaterialActualPatch {
  isActive: Boolean
  jobResponse: JobResponseRef
  materialDefinition: MaterialDefinitionRef
  materialLot: MaterialLotRef
  materialSubLot: MaterialSubLotRef
  materialUse: MaterialUse
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

input MaterialActualRef {
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  materialDefinition: MaterialDefinitionRef
  materialLot: MaterialLotRef
  materialSubLot: MaterialSubLotRef
  materialUse: MaterialUse
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type MaterialAlternate {
  id: ID!
  isActive: Boolean
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
  alternateMaterial(filter: MaterialDefinitionFilter): MaterialDefinition!
  effectiveDateTime: DateTime!
  priorityOrder: Int!
}

type MaterialAlternateAggregateResult {
  count: Int
  effectiveDateTimeMin: DateTime
  effectiveDateTimeMax: DateTime
  priorityOrderMin: Int
  priorityOrderMax: Int
  priorityOrderSum: Int
  priorityOrderAvg: Float
}

input MaterialAlternateFilter {
  id: [ID!]
  isActive: Boolean
  has: [MaterialAlternateHasFilter]
  and: [MaterialAlternateFilter]
  or: [MaterialAlternateFilter]
  not: MaterialAlternateFilter
}

enum MaterialAlternateHasFilter {
  isActive
  material
  alternateMaterial
  effectiveDateTime
  priorityOrder
}

input MaterialAlternateOrder {
  asc: MaterialAlternateOrderable
  desc: MaterialAlternateOrderable
  then: MaterialAlternateOrder
}

enum MaterialAlternateOrderable {
  effectiveDateTime
  priorityOrder
}

input MaterialAlternatePatch {
  isActive: Boolean
  material: MaterialDefinitionRef
  alternateMaterial: MaterialDefinitionRef
  effectiveDateTime: DateTime
  priorityOrder: Int
}

input MaterialAlternateRef {
  id: ID
  isActive: Boolean
  material: MaterialDefinitionRef
  alternateMaterial: MaterialDefinitionRef
  effectiveDateTime: DateTime
  priorityOrder: Int
}

# A unique identification of a specific material class, within the scope
# of the information exchanged (production capability, production
# schedule, production performance, …)
# The ID shall be used in other parts of the model when the material
# class needs to be identified, such as the production capability for
# this material class, or a production response identifying the
# material class used.
type MaterialClass {
  id: ID!
  isActive: Boolean
  code: String!
  description: String
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  scheduleSortOrder: Int
  parent(filter: MaterialClassFilter): MaterialClass
  children(
    filter: MaterialClassFilter
    order: MaterialClassOrder
    first: Int
    offset: Int
  ): [MaterialClass]
  inventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
  ): InventoryHandlingPolicy
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  childrenAggregate(filter: MaterialClassFilter): MaterialClassAggregateResult
}

type MaterialClassAggregateResult {
  count: Int
  codeMin: String
  codeMax: String
  descriptionMin: String
  descriptionMax: String
  scheduleSortOrderMin: Int
  scheduleSortOrderMax: Int
  scheduleSortOrderSum: Int
  scheduleSortOrderAvg: Float
}

input MaterialClassFilter {
  id: [ID!]
  isActive: Boolean
  code: StringHashFilter
  has: [MaterialClassHasFilter]
  and: [MaterialClassFilter]
  or: [MaterialClassFilter]
  not: MaterialClassFilter
}

enum MaterialClassHasFilter {
  isActive
  code
  description
  properties
  scheduleSortOrder
  parent
  children
  inventoryHandlingPolicy
}

input MaterialClassOrder {
  asc: MaterialClassOrderable
  desc: MaterialClassOrderable
  then: MaterialClassOrder
}

enum MaterialClassOrderable {
  code
  description
  scheduleSortOrder
}

input MaterialClassPatch {
  isActive: Boolean
  description: String
  properties: [PropertyRef]
  scheduleSortOrder: Int
  parent: MaterialClassRef
  children: [MaterialClassRef]
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
}

input MaterialClassRef {
  id: ID
  isActive: Boolean
  code: String
  description: String
  properties: [PropertyRef]
  scheduleSortOrder: Int
  parent: MaterialClassRef
  children: [MaterialClassRef]
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
}

type MaterialDefinition {
  id: ID!
  isActive: Boolean
  code: String!
  name: String
  materialClass(filter: MaterialClassFilter): MaterialClass
  materialActual(
    filter: MaterialActualFilter
    order: MaterialActualOrder
    first: Int
    offset: Int
  ): [MaterialActual]
  description: String
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  parameterSpecifications(
    filter: ParameterSpecificationFilter
    order: ParameterSpecificationOrder
    first: Int
    offset: Int
  ): [ParameterSpecification]
  scheduleSortOrder: Int
  baseUnitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure!
  uomConversions(
    filter: UnitOfMeasureConversionFilter
    order: UnitOfMeasureConversionOrder
    first: Int
    offset: Int
  ): [UnitOfMeasureConversion]
  workSpecifications(
    filter: MaterialSpecificationFilter
    order: MaterialSpecificationOrder
    first: Int
    offset: Int
  ): [MaterialSpecification]
  operationsDefinitions(
    filter: OperationsDefinitionFilter
    order: OperationsDefinitionOrder
    first: Int
    offset: Int
  ): [OperationsDefinition]
  lots(
    filter: MaterialLotFilter
    order: MaterialLotOrder
    first: Int
    offset: Int
  ): [MaterialLot]
  sublots(
    filter: MaterialSubLotFilter
    order: MaterialSubLotOrder
    first: Int
    offset: Int
  ): [MaterialSubLot]
  units(
    filter: MaterialUnitFilter
    order: MaterialUnitOrder
    first: Int
    offset: Int
  ): [MaterialUnit]
  value: Float
  valueCurrency: String
  weightKG: Float
  supplier: String
  serialMask: String
  inventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
  ): InventoryHandlingPolicy
  inventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    order: InventoryHoldingPolicyOrder
    first: Int
    offset: Int
  ): [InventoryHoldingPolicy]
  alternates(
    filter: MaterialAlternateFilter
    order: MaterialAlternateOrder
    first: Int
    offset: Int
  ): [MaterialAlternate]
  shipmentItems(
    filter: ShipmentItemFilter
    order: ShipmentItemOrder
    first: Int
    offset: Int
  ): [ShipmentItem]
  OrderLines(
    filter: OrderLineFilter
    order: OrderLineOrder
    first: Int
    offset: Int
  ): [OrderLine]
  transferrableMaterials(
    filter: MaterialDefinitionFilter
    order: MaterialDefinitionOrder
    first: Int
    offset: Int
  ): [MaterialDefinition]
  customerMaterialCode: String
  materialActualAggregate(
    filter: MaterialActualFilter
  ): MaterialActualAggregateResult
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  parameterSpecificationsAggregate(
    filter: ParameterSpecificationFilter
  ): ParameterSpecificationAggregateResult
  uomConversionsAggregate(
    filter: UnitOfMeasureConversionFilter
  ): UnitOfMeasureConversionAggregateResult
  workSpecificationsAggregate(
    filter: MaterialSpecificationFilter
  ): MaterialSpecificationAggregateResult
  operationsDefinitionsAggregate(
    filter: OperationsDefinitionFilter
  ): OperationsDefinitionAggregateResult
  lotsAggregate(filter: MaterialLotFilter): MaterialLotAggregateResult
  sublotsAggregate(filter: MaterialSubLotFilter): MaterialSubLotAggregateResult
  unitsAggregate(filter: MaterialUnitFilter): MaterialUnitAggregateResult
  inventoryHoldingPolicyAggregate(
    filter: InventoryHoldingPolicyFilter
  ): InventoryHoldingPolicyAggregateResult
  alternatesAggregate(
    filter: MaterialAlternateFilter
  ): MaterialAlternateAggregateResult
  shipmentItemsAggregate(
    filter: ShipmentItemFilter
  ): ShipmentItemAggregateResult
  OrderLinesAggregate(filter: OrderLineFilter): OrderLineAggregateResult
  transferrableMaterialsAggregate(
    filter: MaterialDefinitionFilter
  ): MaterialDefinitionAggregateResult
  materialEquipment(filter: MaterialEquipmentFilter): [MaterialEquipment]
}

type MaterialDefinitionAggregateResult {
  count: Int
  codeMin: String
  codeMax: String
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
  scheduleSortOrderMin: Int
  scheduleSortOrderMax: Int
  scheduleSortOrderSum: Int
  scheduleSortOrderAvg: Float
  valueMin: Float
  valueMax: Float
  valueSum: Float
  valueAvg: Float
  valueCurrencyMin: String
  valueCurrencyMax: String
  weightKGMin: Float
  weightKGMax: Float
  weightKGSum: Float
  weightKGAvg: Float
  supplierMin: String
  supplierMax: String
  serialMaskMin: String
  serialMaskMax: String
  customerMaterialCodeMin: String
  customerMaterialCodeMax: String
}

input MaterialDefinitionFilter {
  id: [ID!]
  isActive: Boolean
  code: StringHashFilter
  name: StringHashFilter
  customerMaterialCode: StringHashFilter
  has: [MaterialDefinitionHasFilter]
  and: [MaterialDefinitionFilter]
  or: [MaterialDefinitionFilter]
  not: MaterialDefinitionFilter
}

enum MaterialDefinitionHasFilter {
  isActive
  code
  name
  materialClass
  materialActual
  description
  properties
  parameterSpecifications
  scheduleSortOrder
  baseUnitOfMeasure
  uomConversions
  workSpecifications
  operationsDefinitions
  lots
  sublots
  units
  value
  valueCurrency
  weightKG
  supplier
  serialMask
  inventoryHandlingPolicy
  inventoryHoldingPolicy
  alternates
  shipmentItems
  OrderLines
  transferrableMaterials
  customerMaterialCode
}

input MaterialDefinitionOrder {
  asc: MaterialDefinitionOrderable
  desc: MaterialDefinitionOrderable
  then: MaterialDefinitionOrder
}

enum MaterialDefinitionOrderable {
  code
  name
  description
  scheduleSortOrder
  value
  valueCurrency
  weightKG
  supplier
  serialMask
  customerMaterialCode
}

input MaterialDefinitionPatch {
  isActive: Boolean
  name: String
  materialClass: MaterialClassRef
  materialActual: [MaterialActualRef]
  description: String
  properties: [PropertyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  scheduleSortOrder: Int
  baseUnitOfMeasure: UnitOfMeasureRef
  uomConversions: [UnitOfMeasureConversionRef]
  workSpecifications: [MaterialSpecificationRef]
  operationsDefinitions: [OperationsDefinitionRef]
  lots: [MaterialLotRef]
  sublots: [MaterialSubLotRef]
  units: [MaterialUnitRef]
  value: Float
  valueCurrency: String
  weightKG: Float
  supplier: String
  serialMask: String
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  alternates: [MaterialAlternateRef]
  shipmentItems: [ShipmentItemRef]
  OrderLines: [OrderLineRef]
  transferrableMaterials: [MaterialDefinitionRef]
  customerMaterialCode: String
}

input MaterialDefinitionRef {
  id: ID
  isActive: Boolean
  code: String
  name: String
  materialClass: MaterialClassRef
  materialActual: [MaterialActualRef]
  description: String
  properties: [PropertyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  scheduleSortOrder: Int
  baseUnitOfMeasure: UnitOfMeasureRef
  uomConversions: [UnitOfMeasureConversionRef]
  workSpecifications: [MaterialSpecificationRef]
  operationsDefinitions: [OperationsDefinitionRef]
  lots: [MaterialLotRef]
  sublots: [MaterialSubLotRef]
  units: [MaterialUnitRef]
  value: Float
  valueCurrency: String
  weightKG: Float
  supplier: String
  serialMask: String
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  alternates: [MaterialAlternateRef]
  shipmentItems: [ShipmentItemRef]
  OrderLines: [OrderLineRef]
  transferrableMaterials: [MaterialDefinitionRef]
  customerMaterialCode: String
}

type MaterialEquipment {
  material: MaterialDefinition
  equipment: Equipment
  planningSummaryByState(filter: StateFilter): [MaterialEquipmentState]
}

input MaterialEquipmentFilter {
  materialID: [String]
  equipmentID: [String]
  siteID: [String]
}

type MaterialEquipmentState {
  state: MaterialStateTransitionAttributes
  inventoryMin: Int
  inventoryMax: Int
  stockOnHand: Float
  productionOrderQuantity: Float
  saleOrderQty: Float
  planQty: Float
}

type MaterialEventRuleset {
  id: ID!
  name: String!
  triggerWhen: [RulesetTriggerOption]
  segment(filter: OperationsSegmentFilter): OperationsSegment
  targetMaterial: String!
  targetMaterialOp: String!
  eventDefs(
    filter: EventDefinitionFilter
    order: EventDefinitionOrder
    first: Int
    offset: Int
  ): [EventDefinition]
  eventDefsAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
}

type MaterialEventRulesetAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  targetMaterialMin: String
  targetMaterialMax: String
  targetMaterialOpMin: String
  targetMaterialOpMax: String
}

input MaterialEventRulesetFilter {
  id: [ID!]
  has: [MaterialEventRulesetHasFilter]
  and: [MaterialEventRulesetFilter]
  or: [MaterialEventRulesetFilter]
  not: MaterialEventRulesetFilter
}

enum MaterialEventRulesetHasFilter {
  name
  triggerWhen
  segment
  targetMaterial
  targetMaterialOp
  eventDefs
}

input MaterialEventRulesetOrder {
  asc: MaterialEventRulesetOrderable
  desc: MaterialEventRulesetOrderable
  then: MaterialEventRulesetOrder
}

enum MaterialEventRulesetOrderable {
  name
  targetMaterial
  targetMaterialOp
}

input MaterialEventRulesetPatch {
  name: String
  triggerWhen: [RulesetTriggerOption]
  segment: OperationsSegmentRef
  targetMaterial: String
  targetMaterialOp: String
  eventDefs: [EventDefinitionRef]
}

input MaterialEventRulesetRef {
  id: ID
  name: String
  triggerWhen: [RulesetTriggerOption]
  segment: OperationsSegmentRef
  targetMaterial: String
  targetMaterialOp: String
  eventDefs: [EventDefinitionRef]
}

# A uniquely identified specific amount of material, either countable or weighable shall be presented as a material lot.
# A material lot describes the planned or actual total quantity or amount of material available, its current state
# and its specific property values.
# ref-IEC62264-2 5.4.6
type MaterialLot {
  id: ID!
  isActive: Boolean
  code: String!
  description: String
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
  quantity: String
  dataType: DataType
  unitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure
  materialActual(
    filter: MaterialActualFilter
    order: MaterialActualOrder
    first: Int
    offset: Int
  ): [MaterialActual]
  isAssembledFromLot(
    filter: MaterialLotFilter
    order: MaterialLotOrder
    first: Int
    offset: Int
  ): [MaterialLot]
  isComponentOfLot(
    filter: MaterialLotFilter
    order: MaterialLotOrder
    first: Int
    offset: Int
  ): [MaterialLot]
  isAssembledFromSubLot(
    filter: MaterialSubLotFilter
    order: MaterialSubLotOrder
    first: Int
    offset: Int
  ): [MaterialSubLot]
  isComponentOfSubLot(
    filter: MaterialSubLotFilter
    order: MaterialSubLotOrder
    first: Int
    offset: Int
  ): [MaterialSubLot]
  childSubLot(
    filter: MaterialSubLotFilter
    order: MaterialSubLotOrder
    first: Int
    offset: Int
  ): [MaterialSubLot]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  materialActualAggregate(
    filter: MaterialActualFilter
  ): MaterialActualAggregateResult
  isAssembledFromLotAggregate(
    filter: MaterialLotFilter
  ): MaterialLotAggregateResult
  isComponentOfLotAggregate(
    filter: MaterialLotFilter
  ): MaterialLotAggregateResult
  isAssembledFromSubLotAggregate(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
  isComponentOfSubLotAggregate(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
  childSubLotAggregate(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
}

type MaterialLotAggregateResult {
  count: Int
  codeMin: String
  codeMax: String
  descriptionMin: String
  descriptionMax: String
  quantityMin: String
  quantityMax: String
}

input MaterialLotFilter {
  id: [ID!]
  isActive: Boolean
  code: StringHashFilter
  has: [MaterialLotHasFilter]
  and: [MaterialLotFilter]
  or: [MaterialLotFilter]
  not: MaterialLotFilter
}

enum MaterialLotHasFilter {
  isActive
  code
  description
  properties
  material
  quantity
  dataType
  unitOfMeasure
  materialActual
  isAssembledFromLot
  isComponentOfLot
  isAssembledFromSubLot
  isComponentOfSubLot
  childSubLot
}

input MaterialLotOrder {
  asc: MaterialLotOrderable
  desc: MaterialLotOrderable
  then: MaterialLotOrder
}

enum MaterialLotOrderable {
  code
  description
  quantity
}

input MaterialLotPatch {
  isActive: Boolean
  description: String
  properties: [PropertyRef]
  material: MaterialDefinitionRef
  quantity: String
  dataType: DataType
  unitOfMeasure: UnitOfMeasureRef
  materialActual: [MaterialActualRef]
  isAssembledFromLot: [MaterialLotRef]
  isComponentOfLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  childSubLot: [MaterialSubLotRef]
}

input MaterialLotRef {
  id: ID
  isActive: Boolean
  code: String
  description: String
  properties: [PropertyRef]
  material: MaterialDefinitionRef
  quantity: String
  dataType: DataType
  unitOfMeasure: UnitOfMeasureRef
  materialActual: [MaterialActualRef]
  isAssembledFromLot: [MaterialLotRef]
  isComponentOfLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  childSubLot: [MaterialSubLotRef]
}

input MaterialQuantityMovement {
  materialDefinition: ExtMaterialDefinitionRef!
  quantity: Float!
}

type MaterialSpecification {
  id: ID!
  isActive: Boolean
  jobOrder(filter: JobOrderFilter): JobOrder
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment
  billOfMaterial(filter: BillOfMaterialFilter): BillOfMaterial
  material(filter: MaterialDefinitionFilter): MaterialDefinition
  materialClass(filter: MaterialClassFilter): MaterialClass
  description: String
  materialUse: MaterialUse!
  allowedStates(
    filter: MaterialStatusFilter
    order: MaterialStatusOrder
    first: Int
    offset: Int
  ): [MaterialStatus]
  isTracked: Boolean
  isBackFlushed: Boolean
  backFlushFromLocation(filter: EquipmentFilter): Equipment
  quantity: Float
  uom(filter: UnitOfMeasureFilter): UnitOfMeasure
  allowedStatesAggregate(
    filter: MaterialStatusFilter
  ): MaterialStatusAggregateResult
}

type MaterialSpecificationAggregateResult {
  count: Int
  descriptionMin: String
  descriptionMax: String
  quantityMin: Float
  quantityMax: Float
  quantitySum: Float
  quantityAvg: Float
}

input MaterialSpecificationFilter {
  id: [ID!]
  isActive: Boolean
  materialUse: MaterialUse_hash
  isBackFlushed: Boolean
  has: [MaterialSpecificationHasFilter]
  and: [MaterialSpecificationFilter]
  or: [MaterialSpecificationFilter]
  not: MaterialSpecificationFilter
}

enum MaterialSpecificationHasFilter {
  isActive
  jobOrder
  operationsSegment
  billOfMaterial
  material
  materialClass
  description
  materialUse
  allowedStates
  isTracked
  isBackFlushed
  backFlushFromLocation
  quantity
  uom
}

input MaterialSpecificationOrder {
  asc: MaterialSpecificationOrderable
  desc: MaterialSpecificationOrderable
  then: MaterialSpecificationOrder
}

enum MaterialSpecificationOrderable {
  description
  quantity
}

input MaterialSpecificationPatch {
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  billOfMaterial: BillOfMaterialRef
  material: MaterialDefinitionRef
  materialClass: MaterialClassRef
  description: String
  materialUse: MaterialUse
  allowedStates: [MaterialStatusRef]
  isTracked: Boolean
  isBackFlushed: Boolean
  backFlushFromLocation: EquipmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

input MaterialSpecificationRef {
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  billOfMaterial: BillOfMaterialRef
  material: MaterialDefinitionRef
  materialClass: MaterialClassRef
  description: String
  materialUse: MaterialUse
  allowedStates: [MaterialStatusRef]
  isTracked: Boolean
  isBackFlushed: Boolean
  backFlushFromLocation: EquipmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

type MaterialStateModel {
  id: ID!
  isActive: Boolean
  name: String!
  states(
    filter: MaterialStateTransitionFilter
    first: Int
    offset: Int
  ): [MaterialStateTransition!]!
  inventoryHandlingRules(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  statesAggregate(
    filter: MaterialStateTransitionFilter
  ): MaterialStateTransitionAggregateResult
  inventoryHandlingRulesAggregate(
    filter: InventoryHandlingRuleFilter
  ): InventoryHandlingRuleAggregateResult
}

type MaterialStateModelAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input MaterialStateModelFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  has: [MaterialStateModelHasFilter]
  and: [MaterialStateModelFilter]
  or: [MaterialStateModelFilter]
  not: MaterialStateModelFilter
}

enum MaterialStateModelHasFilter {
  isActive
  name
  states
  inventoryHandlingRules
}

input MaterialStateModelOrder {
  asc: MaterialStateModelOrderable
  desc: MaterialStateModelOrderable
  then: MaterialStateModelOrder
}

enum MaterialStateModelOrderable {
  name
}

input MaterialStateModelPatch {
  isActive: Boolean
  states: [MaterialStateTransitionRef!]
  inventoryHandlingRules: [InventoryHandlingRuleRef]
}

input MaterialStateModelRef {
  id: ID
  isActive: Boolean
  name: String
  states: [MaterialStateTransitionRef!]
  inventoryHandlingRules: [InventoryHandlingRuleRef]
}

type MaterialStateTransition {
  id: ID!
  status(filter: MaterialStatusFilter): MaterialStatus!
  to(
    filter: MaterialStatusFilter
    order: MaterialStatusOrder
    first: Int
    offset: Int
  ): [MaterialStatus]
  canReceive: Boolean
  canPack: Boolean
  isPlanned: Boolean
  toAggregate(filter: MaterialStatusFilter): MaterialStatusAggregateResult
}

type MaterialStateTransitionAggregateResult {
  count: Int
}

type MaterialStateTransitionAttributes {
  id: ID!
  status: MaterialStatus
  canReceive: Boolean
  canPack: Boolean
  isPlanned: Boolean
}

input MaterialStateTransitionFilter {
  id: [ID!]
  canReceive: Boolean
  canPack: Boolean
  isPlanned: Boolean
  has: [MaterialStateTransitionHasFilter]
  and: [MaterialStateTransitionFilter]
  or: [MaterialStateTransitionFilter]
  not: MaterialStateTransitionFilter
}

enum MaterialStateTransitionHasFilter {
  status
  to
  canReceive
  canPack
  isPlanned
}

input MaterialStateTransitionPatch {
  status: MaterialStatusRef
  to: [MaterialStatusRef]
  canReceive: Boolean
  canPack: Boolean
  isPlanned: Boolean
}

input MaterialStateTransitionRef {
  id: ID
  status: MaterialStatusRef
  to: [MaterialStatusRef]
  canReceive: Boolean
  canPack: Boolean
  isPlanned: Boolean
}

type MaterialStatus {
  id: ID!
  isActive: Boolean
  code: String!
  inventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    order: InventoryHoldingPolicyOrder
    first: Int
    offset: Int
  ): [InventoryHoldingPolicy]
  inventoryHoldingPolicyAggregate(
    filter: InventoryHoldingPolicyFilter
  ): InventoryHoldingPolicyAggregateResult
}

type MaterialStatusAggregateResult {
  count: Int
  codeMin: String
  codeMax: String
}

input MaterialStatusFilter {
  id: [ID!]
  isActive: Boolean
  code: StringHashFilter
  has: [MaterialStatusHasFilter]
  and: [MaterialStatusFilter]
  or: [MaterialStatusFilter]
  not: MaterialStatusFilter
}

enum MaterialStatusHasFilter {
  isActive
  code
  inventoryHoldingPolicy
}

input MaterialStatusOrder {
  asc: MaterialStatusOrderable
  desc: MaterialStatusOrderable
  then: MaterialStatusOrder
}

enum MaterialStatusOrderable {
  code
}

input MaterialStatusPatch {
  isActive: Boolean
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
}

input MaterialStatusRef {
  id: ID
  isActive: Boolean
  code: String
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
}

# Each separately identifiable quantity of the same material lot shall be presented as a material sublot.
# A material lot by be stored in separately identifiable quantities. All material sublots are part of the
# material lot, so they have the material lot's property values. A material sublot may be just a single item.
# ref-IEC62264-2 5.4.8
type MaterialSubLot {
  id: ID!
  isActive: Boolean
  code: String!
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
  materialActual(
    filter: MaterialActualFilter
    order: MaterialActualOrder
    first: Int
    offset: Int
  ): [MaterialActual]
  description: String
  status(filter: MaterialStatusFilter): MaterialStatus!
  storageLocation(filter: EquipmentFilter): Equipment
  isAssembledFromSubLot(
    filter: MaterialSubLotFilter
    order: MaterialSubLotOrder
    first: Int
    offset: Int
  ): [MaterialSubLot]
  isComponentOfSubLot(
    filter: MaterialSubLotFilter
    order: MaterialSubLotOrder
    first: Int
    offset: Int
  ): [MaterialSubLot]
  isComponentOfLot(
    filter: MaterialLotFilter
    order: MaterialLotOrder
    first: Int
    offset: Int
  ): [MaterialLot]
  isAssembledFromLot(
    filter: MaterialLotFilter
    order: MaterialLotOrder
    first: Int
    offset: Int
  ): [MaterialLot]
  parentLot(filter: MaterialLotFilter): MaterialLot
  parentSubLot(filter: MaterialSubLotFilter): MaterialSubLot
  childSubLot(filter: MaterialSubLotFilter): MaterialSubLot
  quantity: String
  dataType: DataType
  unitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  materialActualAggregate(
    filter: MaterialActualFilter
  ): MaterialActualAggregateResult
  isAssembledFromSubLotAggregate(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
  isComponentOfSubLotAggregate(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
  isComponentOfLotAggregate(
    filter: MaterialLotFilter
  ): MaterialLotAggregateResult
  isAssembledFromLotAggregate(
    filter: MaterialLotFilter
  ): MaterialLotAggregateResult
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  carrier: Carrier
}

type MaterialSubLotAggregateResult {
  count: Int
  codeMin: String
  codeMax: String
  descriptionMin: String
  descriptionMax: String
  quantityMin: String
  quantityMax: String
}

input MaterialSubLotFilter {
  id: [ID!]
  isActive: Boolean
  code: StringHashFilter
  has: [MaterialSubLotHasFilter]
  and: [MaterialSubLotFilter]
  or: [MaterialSubLotFilter]
  not: MaterialSubLotFilter
}

enum MaterialSubLotHasFilter {
  isActive
  code
  material
  materialActual
  description
  status
  storageLocation
  isAssembledFromSubLot
  isComponentOfSubLot
  isComponentOfLot
  isAssembledFromLot
  parentLot
  parentSubLot
  childSubLot
  quantity
  dataType
  unitOfMeasure
  properties
}

input MaterialSubLotOrder {
  asc: MaterialSubLotOrderable
  desc: MaterialSubLotOrderable
  then: MaterialSubLotOrder
}

enum MaterialSubLotOrderable {
  code
  description
  quantity
}

input MaterialSubLotPatch {
  isActive: Boolean
  material: MaterialDefinitionRef
  materialActual: [MaterialActualRef]
  description: String
  status: MaterialStatusRef
  storageLocation: EquipmentRef
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isAssembledFromLot: [MaterialLotRef]
  parentLot: MaterialLotRef
  parentSubLot: MaterialSubLotRef
  childSubLot: MaterialSubLotRef
  quantity: String
  dataType: DataType
  unitOfMeasure: UnitOfMeasureRef
  properties: [PropertyRef]
}

input MaterialSubLotRef {
  id: ID
  isActive: Boolean
  code: String
  material: MaterialDefinitionRef
  materialActual: [MaterialActualRef]
  description: String
  status: MaterialStatusRef
  storageLocation: EquipmentRef
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isAssembledFromLot: [MaterialLotRef]
  parentLot: MaterialLotRef
  parentSubLot: MaterialSubLotRef
  childSubLot: MaterialSubLotRef
  quantity: String
  dataType: DataType
  unitOfMeasure: UnitOfMeasureRef
  properties: [PropertyRef]
}

type MaterialUnit {
  id: ID!
  isActive: Boolean
  serialNumber: String!
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
}

type MaterialUnitAggregateResult {
  count: Int
  serialNumberMin: String
  serialNumberMax: String
}

input MaterialUnitFilter {
  id: [ID!]
  isActive: Boolean
  serialNumber: StringHashFilter
  has: [MaterialUnitHasFilter]
  and: [MaterialUnitFilter]
  or: [MaterialUnitFilter]
  not: MaterialUnitFilter
}

enum MaterialUnitHasFilter {
  isActive
  serialNumber
  material
  properties
}

input MaterialUnitOrder {
  asc: MaterialUnitOrderable
  desc: MaterialUnitOrderable
  then: MaterialUnitOrder
}

enum MaterialUnitOrderable {
  serialNumber
}

input MaterialUnitPatch {
  isActive: Boolean
  material: MaterialDefinitionRef
  properties: [PropertyRef]
}

input MaterialUnitRef {
  id: ID
  isActive: Boolean
  serialNumber: String
  material: MaterialDefinitionRef
  properties: [PropertyRef]
}

enum MaterialUse {
  Initial
  Produced
  ByProduct
  CoProduct
  Consumable
  Consumed
  Transferred
  Scrap
  Rework
  Received
  Packed
  Shipped
}

input MaterialUse_hash {
  eq: MaterialUse
  in: [MaterialUse]
}

type Menu {
  id: ID!
  label: String!
  access(
    filter: RoleFilter
    order: RoleOrder
    first: Int
    offset: Int
  ): [Role!]!
  parent(filter: MenuFilter): Menu
  children(
    filter: MenuFilter
    order: MenuOrder
    first: Int
    offset: Int
  ): [Menu!]
  menuPage: String
  icon: String
  isSection: Boolean!
  isPage: Boolean!
  orderNumber: Int
  accessAggregate(filter: RoleFilter): RoleAggregateResult
  childrenAggregate(filter: MenuFilter): MenuAggregateResult
}

type MenuAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
  menuPageMin: String
  menuPageMax: String
  iconMin: String
  iconMax: String
  orderNumberMin: Int
  orderNumberMax: Int
  orderNumberSum: Int
  orderNumberAvg: Float
}

input MenuFilter {
  id: [ID!]
  label: StringHashFilter
  has: [MenuHasFilter]
  and: [MenuFilter]
  or: [MenuFilter]
  not: MenuFilter
}

enum MenuHasFilter {
  label
  access
  parent
  children
  menuPage
  icon
  isSection
  isPage
  orderNumber
}

input MenuOrder {
  asc: MenuOrderable
  desc: MenuOrderable
  then: MenuOrder
}

enum MenuOrderable {
  label
  menuPage
  icon
  orderNumber
}

input MenuPatch {
  label: String
  access: [RoleRef!]
  parent: MenuRef
  children: [MenuRef!]
  menuPage: String
  icon: String
  isSection: Boolean
  isPage: Boolean
  orderNumber: Int
}

input MenuRef {
  id: ID
  label: String
  access: [RoleRef!]
  parent: MenuRef
  children: [MenuRef!]
  menuPage: String
  icon: String
  isSection: Boolean
  isPage: Boolean
  orderNumber: Int
}

enum MessageClass {
  EventLog
  QuantityLog
  PerformanceLog
  AttendanceLog
  JobRequest
  JobResponse
  OperationsRequestStart
  JobOrderStateChange
  JobOrderTransition
}

enum Mode {
  BATCH
  SINGLE
}

input MoveMaterialQuantitiesBetweenCarriersInput {
  materialQuantities: [MaterialQuantityMovement]!
  carrierInitial: ExtCarrierRef!
  carrierDestination: ExtCarrierRef!
  user: ExtUserRef!
}

input MoveMaterialSubLotsInput {
  materialSubLots: [ExtMaterialSubLotRef!]!
  newLocation: ExtCarrierRef!
  user: ExtUserRef!
}

enum mpmORCRevokeTriggers {
  FIFTEEN_MINUTES
  THIRTY_MINUTES
  FORTYFIVE_MINUTES
  SIXTY_MINUTES
  ORDER_CLOSE
  BREAK_TIME_START
  BREAK_TIME_END
}

enum mpmORCWarnTriggers {
  FIFTEEN_MINUTES
  THIRTY_MINUTES
  FORTYFIVE_MINUTES
  SIXTY_MINUTES
  ORDER_CLOSE
  BREAK_TIME_START
  BREAK_TIME_END
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  updateEventLogTs(input: [EventLogTsInput]!): [EventLogTs]
  splitEventLogTs(input: [EventLogTsInput]!): [EventLogTs]
  addQuantityLogTs(input: QuantityLogTsInput!): QuantityLogTs
  updateOrderStatusRetroactively(
    input: UpdateOrderStatusInput
  ): UpdatedOrderStatus

  #  update the status of a JobOrder. If setting the status to active, update any existing active orders
  # for the same equipment to complete and update the associated JobResponse.endDateTime.
  # When setting the status to ACTIVE, if there is no open JobResponse, create one and set the jobResponse.startDateTime
  # If setting the status to complete, update the associated JobResponse.endDateTime
  updateJobOrderStatus(input: UpdateJobOrderStatusInput): [JobOrder]

  #  replay raw sensor history from an InfluxDB bucket and measure for a list of equipment and time range
  # Deletes the run-time data in dgraph and influxDB for that equipment and replays the raw events into MQTT
  replayRawData(input: ReplayRawDataInput!): String

  #  Create a new instance of a given workflow specification and start the first task
  # in the specification after the "START_EVENT". Properties can be supplied.
  createWorkflowInstance(input: CreateWorkflowInstanceInput!): WorkflowInstance

  #  Update a workflow node instance. This can update the user, properties or status of the task
  updateWorkflowTask(input: UpdateWorkflowTaskInput!): WorkflowNodeInstance

  #  Complete a workflow node instance. If the specification contains a next task, it will be started
  # otherwise the workflow instance will be completed.
  completeWorkflowTask(input: CompleteWorkflowTaskInput!): WorkflowNodeInstance

  #  Backfill iterates through the an equipment properties from the given timestamp until now, and evaulates
  # events and rulesets and re-recreates responses for the time period given. Any existing data is delete.
  # This is a long running process. Subscribe to the topic in the mqtt broker for updates.
  addBackfill(input: BackfillRequest!): BackfillResponse

  #  Cancel a running Backfill
  addBackfillCancel(input: BackfillCancelRequest!): BackfillResponse
  uploadSchedule(input: [UploadScheduleInput]!): UploadScheduleStaging
  uploadStagedSchedule(
    input: UploadStagedScheduleInput!
  ): UploadStagedScheduleOutput
  addUser(input: [AddUserInput!]!, upsert: Boolean): AddUserPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  deleteUser(filter: UserFilter!): DeleteUserPayload
  addUserRole(input: [AddUserRoleInput!]!): AddUserRolePayload
  updateUserRole(input: UpdateUserRoleInput!): UpdateUserRolePayload
  deleteUserRole(filter: UserRoleFilter!): DeleteUserRolePayload
  addRole(input: [AddRoleInput!]!, upsert: Boolean): AddRolePayload
  updateRole(input: UpdateRoleInput!): UpdateRolePayload
  deleteRole(filter: RoleFilter!): DeleteRolePayload
  addAccessRight(input: [AddAccessRightInput!]!): AddAccessRightPayload
  updateAccessRight(input: UpdateAccessRightInput!): UpdateAccessRightPayload
  deleteAccessRight(filter: AccessRightFilter!): DeleteAccessRightPayload
  addACL(input: [AddACLInput!]!): AddACLPayload
  updateACL(input: UpdateACLInput!): UpdateACLPayload
  deleteACL(filter: ACLFilter!): DeleteACLPayload
  addLibreService(
    input: [AddLibreServiceInput!]!
    upsert: Boolean
  ): AddLibreServicePayload
  updateLibreService(input: UpdateLibreServiceInput!): UpdateLibreServicePayload
  deleteLibreService(filter: LibreServiceFilter!): DeleteLibreServicePayload
  addMenu(input: [AddMenuInput!]!): AddMenuPayload
  updateMenu(input: UpdateMenuInput!): UpdateMenuPayload
  deleteMenu(filter: MenuFilter!): DeleteMenuPayload
  addOperationsRequest(
    input: [AddOperationsRequestInput!]!
    upsert: Boolean
  ): AddOperationsRequestPayload
  updateOperationsRequest(
    input: UpdateOperationsRequestInput!
  ): UpdateOperationsRequestPayload
  deleteOperationsRequest(
    filter: OperationsRequestFilter!
  ): DeleteOperationsRequestPayload
  addRequestState(
    input: [AddRequestStateInput!]!
    upsert: Boolean
  ): AddRequestStatePayload
  updateRequestState(input: UpdateRequestStateInput!): UpdateRequestStatePayload
  deleteRequestState(filter: RequestStateFilter!): DeleteRequestStatePayload
  addOperationsDefinition(
    input: [AddOperationsDefinitionInput!]!
    upsert: Boolean
  ): AddOperationsDefinitionPayload
  updateOperationsDefinition(
    input: UpdateOperationsDefinitionInput!
  ): UpdateOperationsDefinitionPayload
  deleteOperationsDefinition(
    filter: OperationsDefinitionFilter!
  ): DeleteOperationsDefinitionPayload
  addBillOfMaterial(
    input: [AddBillOfMaterialInput!]!
    upsert: Boolean
  ): AddBillOfMaterialPayload
  updateBillOfMaterial(
    input: UpdateBillOfMaterialInput!
  ): UpdateBillOfMaterialPayload
  deleteBillOfMaterial(
    filter: BillOfMaterialFilter!
  ): DeleteBillOfMaterialPayload
  addOperationsSegment(
    input: [AddOperationsSegmentInput!]!
  ): AddOperationsSegmentPayload
  updateOperationsSegment(
    input: UpdateOperationsSegmentInput!
  ): UpdateOperationsSegmentPayload
  deleteOperationsSegment(
    filter: OperationsSegmentFilter!
  ): DeleteOperationsSegmentPayload
  addTransitionEventRuleset(
    input: [AddTransitionEventRulesetInput!]!
  ): AddTransitionEventRulesetPayload
  updateTransitionEventRuleset(
    input: UpdateTransitionEventRulesetInput!
  ): UpdateTransitionEventRulesetPayload
  deleteTransitionEventRuleset(
    filter: TransitionEventRulesetFilter!
  ): DeleteTransitionEventRulesetPayload
  addStateEventRuleset(
    input: [AddStateEventRulesetInput!]!
  ): AddStateEventRulesetPayload
  updateStateEventRuleset(
    input: UpdateStateEventRulesetInput!
  ): UpdateStateEventRulesetPayload
  deleteStateEventRuleset(
    filter: StateEventRulesetFilter!
  ): DeleteStateEventRulesetPayload
  addMaterialEventRuleset(
    input: [AddMaterialEventRulesetInput!]!
  ): AddMaterialEventRulesetPayload
  updateMaterialEventRuleset(
    input: UpdateMaterialEventRulesetInput!
  ): UpdateMaterialEventRulesetPayload
  deleteMaterialEventRuleset(
    filter: MaterialEventRulesetFilter!
  ): DeleteMaterialEventRulesetPayload
  addOrderStartRuleset(
    input: [AddOrderStartRulesetInput!]!
  ): AddOrderStartRulesetPayload
  updateOrderStartRuleset(
    input: UpdateOrderStartRulesetInput!
  ): UpdateOrderStartRulesetPayload
  deleteOrderStartRuleset(
    filter: OrderStartRulesetFilter!
  ): DeleteOrderStartRulesetPayload
  addSegmentInvoiceSetting(
    input: [AddSegmentInvoiceSettingInput!]!
  ): AddSegmentInvoiceSettingPayload
  updateSegmentInvoiceSetting(
    input: UpdateSegmentInvoiceSettingInput!
  ): UpdateSegmentInvoiceSettingPayload
  deleteSegmentInvoiceSetting(
    filter: SegmentInvoiceSettingFilter!
  ): DeleteSegmentInvoiceSettingPayload
  addSegmentDependency(
    input: [AddSegmentDependencyInput!]!
  ): AddSegmentDependencyPayload
  updateSegmentDependency(
    input: UpdateSegmentDependencyInput!
  ): UpdateSegmentDependencyPayload
  deleteSegmentDependency(
    filter: SegmentDependencyFilter!
  ): DeleteSegmentDependencyPayload
  addJobOrder(input: [AddJobOrderInput!]!, upsert: Boolean): AddJobOrderPayload
  updateJobOrder(input: UpdateJobOrderInput!): UpdateJobOrderPayload
  deleteJobOrder(filter: JobOrderFilter!): DeleteJobOrderPayload
  addJobOrderDependency(
    input: [AddJobOrderDependencyInput!]!
  ): AddJobOrderDependencyPayload
  updateJobOrderDependency(
    input: UpdateJobOrderDependencyInput!
  ): UpdateJobOrderDependencyPayload
  deleteJobOrderDependency(
    filter: JobOrderDependencyFilter!
  ): DeleteJobOrderDependencyPayload
  addJobOrderDispatchStateModel(
    input: [AddJobOrderDispatchStateModelInput!]!
  ): AddJobOrderDispatchStateModelPayload
  updateJobOrderDispatchStateModel(
    input: UpdateJobOrderDispatchStateModelInput!
  ): UpdateJobOrderDispatchStateModelPayload
  deleteJobOrderDispatchStateModel(
    filter: JobOrderDispatchStateModelFilter!
  ): DeleteJobOrderDispatchStateModelPayload
  addJobOrderNote(input: [AddJobOrderNoteInput!]!): AddJobOrderNotePayload
  updateJobOrderNote(input: UpdateJobOrderNoteInput!): UpdateJobOrderNotePayload
  deleteJobOrderNote(filter: JobOrderNoteFilter!): DeleteJobOrderNotePayload
  addJobResponse(input: [AddJobResponseInput!]!): AddJobResponsePayload
  updateJobResponse(input: UpdateJobResponseInput!): UpdateJobResponsePayload
  deleteJobResponse(filter: JobResponseFilter!): DeleteJobResponsePayload
  addPersonnelActual(
    input: [AddPersonnelActualInput!]!
  ): AddPersonnelActualPayload
  updatePersonnelActual(
    input: UpdatePersonnelActualInput!
  ): UpdatePersonnelActualPayload
  deletePersonnelActual(
    filter: PersonnelActualFilter!
  ): DeletePersonnelActualPayload
  addEquipmentActual(
    input: [AddEquipmentActualInput!]!
  ): AddEquipmentActualPayload
  updateEquipmentActual(
    input: UpdateEquipmentActualInput!
  ): UpdateEquipmentActualPayload
  deleteEquipmentActual(
    filter: EquipmentActualFilter!
  ): DeleteEquipmentActualPayload
  addMaterialActual(input: [AddMaterialActualInput!]!): AddMaterialActualPayload
  updateMaterialActual(
    input: UpdateMaterialActualInput!
  ): UpdateMaterialActualPayload
  deleteMaterialActual(
    filter: MaterialActualFilter!
  ): DeleteMaterialActualPayload
  addEventLog(input: [AddEventLogInput!]!): AddEventLogPayload
  updateEventLog(input: UpdateEventLogInput!): UpdateEventLogPayload
  deleteEventLog(filter: EventLogFilter!): DeleteEventLogPayload
  addQuantityLog(input: [AddQuantityLogInput!]!): AddQuantityLogPayload
  updateQuantityLog(input: UpdateQuantityLogInput!): UpdateQuantityLogPayload
  deleteQuantityLog(filter: QuantityLogFilter!): DeleteQuantityLogPayload
  addEquipmentSpecification(
    input: [AddEquipmentSpecificationInput!]!
  ): AddEquipmentSpecificationPayload
  updateEquipmentSpecification(
    input: UpdateEquipmentSpecificationInput!
  ): UpdateEquipmentSpecificationPayload
  deleteEquipmentSpecification(
    filter: EquipmentSpecificationFilter!
  ): DeleteEquipmentSpecificationPayload
  addMaterialSpecification(
    input: [AddMaterialSpecificationInput!]!
  ): AddMaterialSpecificationPayload
  updateMaterialSpecification(
    input: UpdateMaterialSpecificationInput!
  ): UpdateMaterialSpecificationPayload
  deleteMaterialSpecification(
    filter: MaterialSpecificationFilter!
  ): DeleteMaterialSpecificationPayload
  addPersonnelSpecification(
    input: [AddPersonnelSpecificationInput!]!
  ): AddPersonnelSpecificationPayload
  updatePersonnelSpecification(
    input: UpdatePersonnelSpecificationInput!
  ): UpdatePersonnelSpecificationPayload
  deletePersonnelSpecification(
    filter: PersonnelSpecificationFilter!
  ): DeletePersonnelSpecificationPayload
  addParameterSpecification(
    input: [AddParameterSpecificationInput!]!
  ): AddParameterSpecificationPayload
  updateParameterSpecification(
    input: UpdateParameterSpecificationInput!
  ): UpdateParameterSpecificationPayload
  deleteParameterSpecification(
    filter: ParameterSpecificationFilter!
  ): DeleteParameterSpecificationPayload
  addDashboardConfig(
    input: [AddDashboardConfigInput!]!
    upsert: Boolean
  ): AddDashboardConfigPayload
  updateDashboardConfig(
    input: UpdateDashboardConfigInput!
  ): UpdateDashboardConfigPayload
  deleteDashboardConfig(
    filter: DashboardConfigFilter!
  ): DeleteDashboardConfigPayload
  addDashboardPanelConfig(
    input: [AddDashboardPanelConfigInput!]!
  ): AddDashboardPanelConfigPayload
  updateDashboardPanelConfig(
    input: UpdateDashboardPanelConfigInput!
  ): UpdateDashboardPanelConfigPayload
  deleteDashboardPanelConfig(
    filter: DashboardPanelConfigFilter!
  ): DeleteDashboardPanelConfigPayload
  addDashboardWidgetConfigProperty(
    input: [AddDashboardWidgetConfigPropertyInput!]!
  ): AddDashboardWidgetConfigPropertyPayload
  updateDashboardWidgetConfigProperty(
    input: UpdateDashboardWidgetConfigPropertyInput!
  ): UpdateDashboardWidgetConfigPropertyPayload
  deleteDashboardWidgetConfigProperty(
    filter: DashboardWidgetConfigPropertyFilter!
  ): DeleteDashboardWidgetConfigPropertyPayload
  addEquipment(input: [AddEquipmentInput!]!): AddEquipmentPayload
  updateEquipment(input: UpdateEquipmentInput!): UpdateEquipmentPayload
  deleteEquipment(filter: EquipmentFilter!): DeleteEquipmentPayload
  addEquipmentRelation(
    input: [AddEquipmentRelationInput!]!
  ): AddEquipmentRelationPayload
  updateEquipmentRelation(
    input: UpdateEquipmentRelationInput!
  ): UpdateEquipmentRelationPayload
  deleteEquipmentRelation(
    filter: EquipmentRelationFilter!
  ): DeleteEquipmentRelationPayload
  addEquipmentNameAlias(
    input: [AddEquipmentNameAliasInput!]!
  ): AddEquipmentNameAliasPayload
  updateEquipmentNameAlias(
    input: UpdateEquipmentNameAliasInput!
  ): UpdateEquipmentNameAliasPayload
  deleteEquipmentNameAlias(
    filter: EquipmentNameAliasFilter!
  ): DeleteEquipmentNameAliasPayload
  addPropertyNameAlias(
    input: [AddPropertyNameAliasInput!]!
  ): AddPropertyNameAliasPayload
  updatePropertyNameAlias(
    input: UpdatePropertyNameAliasInput!
  ): UpdatePropertyNameAliasPayload
  deletePropertyNameAlias(
    filter: PropertyNameAliasFilter!
  ): DeletePropertyNameAliasPayload
  addPropertyValueAlias(
    input: [AddPropertyValueAliasInput!]!
  ): AddPropertyValueAliasPayload
  updatePropertyValueAlias(
    input: UpdatePropertyValueAliasInput!
  ): UpdatePropertyValueAliasPayload
  deletePropertyValueAlias(
    filter: PropertyValueAliasFilter!
  ): DeletePropertyValueAliasPayload
  addEquipmentReasonOverride(
    input: [AddEquipmentReasonOverrideInput!]!
  ): AddEquipmentReasonOverridePayload
  updateEquipmentReasonOverride(
    input: UpdateEquipmentReasonOverrideInput!
  ): UpdateEquipmentReasonOverridePayload
  deleteEquipmentReasonOverride(
    filter: EquipmentReasonOverrideFilter!
  ): DeleteEquipmentReasonOverridePayload
  addEquipmentClass(input: [AddEquipmentClassInput!]!): AddEquipmentClassPayload
  updateEquipmentClass(
    input: UpdateEquipmentClassInput!
  ): UpdateEquipmentClassPayload
  deleteEquipmentClass(
    filter: EquipmentClassFilter!
  ): DeleteEquipmentClassPayload
  addProperty(input: [AddPropertyInput!]!): AddPropertyPayload
  updateProperty(input: UpdatePropertyInput!): UpdatePropertyPayload
  deleteProperty(filter: PropertyFilter!): DeletePropertyPayload
  addEquipmentPropertyOverride(
    input: [AddEquipmentPropertyOverrideInput!]!
  ): AddEquipmentPropertyOverridePayload
  updateEquipmentPropertyOverride(
    input: UpdateEquipmentPropertyOverrideInput!
  ): UpdateEquipmentPropertyOverridePayload
  deleteEquipmentPropertyOverride(
    filter: EquipmentPropertyOverrideFilter!
  ): DeleteEquipmentPropertyOverridePayload
  addEventDefinition(
    input: [AddEventDefinitionInput!]!
  ): AddEventDefinitionPayload
  updateEventDefinition(
    input: UpdateEventDefinitionInput!
  ): UpdateEventDefinitionPayload
  deleteEventDefinition(
    filter: EventDefinitionFilter!
  ): DeleteEventDefinitionPayload
  addPayloadFieldDefinition(
    input: [AddPayloadFieldDefinitionInput!]!
  ): AddPayloadFieldDefinitionPayload
  updatePayloadFieldDefinition(
    input: UpdatePayloadFieldDefinitionInput!
  ): UpdatePayloadFieldDefinitionPayload
  deletePayloadFieldDefinition(
    filter: PayloadFieldDefinitionFilter!
  ): DeletePayloadFieldDefinitionPayload
  addReason(input: [AddReasonInput!]!): AddReasonPayload
  updateReason(input: UpdateReasonInput!): UpdateReasonPayload
  deleteReason(filter: ReasonFilter!): DeleteReasonPayload
  addReasonCategory(
    input: [AddReasonCategoryInput!]!
    upsert: Boolean
  ): AddReasonCategoryPayload
  updateReasonCategory(
    input: UpdateReasonCategoryInput!
  ): UpdateReasonCategoryPayload
  deleteReasonCategory(
    filter: ReasonCategoryFilter!
  ): DeleteReasonCategoryPayload
  addMaterialClass(
    input: [AddMaterialClassInput!]!
    upsert: Boolean
  ): AddMaterialClassPayload
  updateMaterialClass(
    input: UpdateMaterialClassInput!
  ): UpdateMaterialClassPayload
  deleteMaterialClass(filter: MaterialClassFilter!): DeleteMaterialClassPayload
  addMaterialDefinition(
    input: [AddMaterialDefinitionInput!]!
    upsert: Boolean
  ): AddMaterialDefinitionPayload
  updateMaterialDefinition(
    input: UpdateMaterialDefinitionInput!
  ): UpdateMaterialDefinitionPayload
  deleteMaterialDefinition(
    filter: MaterialDefinitionFilter!
  ): DeleteMaterialDefinitionPayload
  addMaterialAlternate(
    input: [AddMaterialAlternateInput!]!
  ): AddMaterialAlternatePayload
  updateMaterialAlternate(
    input: UpdateMaterialAlternateInput!
  ): UpdateMaterialAlternatePayload
  deleteMaterialAlternate(
    filter: MaterialAlternateFilter!
  ): DeleteMaterialAlternatePayload
  addCarrier(input: [AddCarrierInput!]!, upsert: Boolean): AddCarrierPayload
  updateCarrier(input: UpdateCarrierInput!): UpdateCarrierPayload
  deleteCarrier(filter: CarrierFilter!): DeleteCarrierPayload
  addMaterialLot(
    input: [AddMaterialLotInput!]!
    upsert: Boolean
  ): AddMaterialLotPayload
  updateMaterialLot(input: UpdateMaterialLotInput!): UpdateMaterialLotPayload
  deleteMaterialLot(filter: MaterialLotFilter!): DeleteMaterialLotPayload
  addMaterialSubLot(
    input: [AddMaterialSubLotInput!]!
    upsert: Boolean
  ): AddMaterialSubLotPayload
  updateMaterialSubLot(
    input: UpdateMaterialSubLotInput!
  ): UpdateMaterialSubLotPayload
  deleteMaterialSubLot(
    filter: MaterialSubLotFilter!
  ): DeleteMaterialSubLotPayload
  addMaterialUnit(
    input: [AddMaterialUnitInput!]!
    upsert: Boolean
  ): AddMaterialUnitPayload
  updateMaterialUnit(input: UpdateMaterialUnitInput!): UpdateMaterialUnitPayload
  deleteMaterialUnit(filter: MaterialUnitFilter!): DeleteMaterialUnitPayload
  addInventoryHoldingPolicy(
    input: [AddInventoryHoldingPolicyInput!]!
  ): AddInventoryHoldingPolicyPayload
  updateInventoryHoldingPolicy(
    input: UpdateInventoryHoldingPolicyInput!
  ): UpdateInventoryHoldingPolicyPayload
  deleteInventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter!
  ): DeleteInventoryHoldingPolicyPayload
  addUnitOfMeasure(
    input: [AddUnitOfMeasureInput!]!
    upsert: Boolean
  ): AddUnitOfMeasurePayload
  updateUnitOfMeasure(
    input: UpdateUnitOfMeasureInput!
  ): UpdateUnitOfMeasurePayload
  deleteUnitOfMeasure(filter: UnitOfMeasureFilter!): DeleteUnitOfMeasurePayload
  addUnitOfMeasureConversion(
    input: [AddUnitOfMeasureConversionInput!]!
  ): AddUnitOfMeasureConversionPayload
  updateUnitOfMeasureConversion(
    input: UpdateUnitOfMeasureConversionInput!
  ): UpdateUnitOfMeasureConversionPayload
  deleteUnitOfMeasureConversion(
    filter: UnitOfMeasureConversionFilter!
  ): DeleteUnitOfMeasureConversionPayload
  addMaterialStatus(
    input: [AddMaterialStatusInput!]!
    upsert: Boolean
  ): AddMaterialStatusPayload
  updateMaterialStatus(
    input: UpdateMaterialStatusInput!
  ): UpdateMaterialStatusPayload
  deleteMaterialStatus(
    filter: MaterialStatusFilter!
  ): DeleteMaterialStatusPayload
  addMaterialStateModel(
    input: [AddMaterialStateModelInput!]!
    upsert: Boolean
  ): AddMaterialStateModelPayload
  updateMaterialStateModel(
    input: UpdateMaterialStateModelInput!
  ): UpdateMaterialStateModelPayload
  deleteMaterialStateModel(
    filter: MaterialStateModelFilter!
  ): DeleteMaterialStateModelPayload
  addMaterialStateTransition(
    input: [AddMaterialStateTransitionInput!]!
  ): AddMaterialStateTransitionPayload
  updateMaterialStateTransition(
    input: UpdateMaterialStateTransitionInput!
  ): UpdateMaterialStateTransitionPayload
  deleteMaterialStateTransition(
    filter: MaterialStateTransitionFilter!
  ): DeleteMaterialStateTransitionPayload
  addPersonnelClass(
    input: [AddPersonnelClassInput!]!
    upsert: Boolean
  ): AddPersonnelClassPayload
  updatePersonnelClass(
    input: UpdatePersonnelClassInput!
  ): UpdatePersonnelClassPayload
  deletePersonnelClass(
    filter: PersonnelClassFilter!
  ): DeletePersonnelClassPayload
  addPerson(input: [AddPersonInput!]!, upsert: Boolean): AddPersonPayload
  updatePerson(input: UpdatePersonInput!): UpdatePersonPayload
  deletePerson(filter: PersonFilter!): DeletePersonPayload
  addTestSpecification(
    input: [AddTestSpecificationInput!]!
  ): AddTestSpecificationPayload
  updateTestSpecification(
    input: UpdateTestSpecificationInput!
  ): UpdateTestSpecificationPayload
  deleteTestSpecification(
    filter: TestSpecificationFilter!
  ): DeleteTestSpecificationPayload
  addTestResult(input: [AddTestResultInput!]!): AddTestResultPayload
  updateTestResult(input: UpdateTestResultInput!): UpdateTestResultPayload
  deleteTestResult(filter: TestResultFilter!): DeleteTestResultPayload
  addWorkCalendarDefinitionEntry(
    input: [AddWorkCalendarDefinitionEntryInput!]!
  ): AddWorkCalendarDefinitionEntryPayload
  updateWorkCalendarDefinitionEntry(
    input: UpdateWorkCalendarDefinitionEntryInput!
  ): UpdateWorkCalendarDefinitionEntryPayload
  deleteWorkCalendarDefinitionEntry(
    filter: WorkCalendarDefinitionEntryFilter!
  ): DeleteWorkCalendarDefinitionEntryPayload
  addWorkCalendarEntry(
    input: [AddWorkCalendarEntryInput!]!
  ): AddWorkCalendarEntryPayload
  updateWorkCalendarEntry(
    input: UpdateWorkCalendarEntryInput!
  ): UpdateWorkCalendarEntryPayload
  deleteWorkCalendarEntry(
    filter: WorkCalendarEntryFilter!
  ): DeleteWorkCalendarEntryPayload
  addWorkCalendar(
    input: [AddWorkCalendarInput!]!
    upsert: Boolean
  ): AddWorkCalendarPayload
  updateWorkCalendar(input: UpdateWorkCalendarInput!): UpdateWorkCalendarPayload
  deleteWorkCalendar(filter: WorkCalendarFilter!): DeleteWorkCalendarPayload
  addWorkflowSpecification(
    input: [AddWorkflowSpecificationInput!]!
  ): AddWorkflowSpecificationPayload
  updateWorkflowSpecification(
    input: UpdateWorkflowSpecificationInput!
  ): UpdateWorkflowSpecificationPayload
  deleteWorkflowSpecification(
    filter: WorkflowSpecificationFilter!
  ): DeleteWorkflowSpecificationPayload
  addWorkflowInstance(
    input: [AddWorkflowInstanceInput!]!
  ): AddWorkflowInstancePayload
  updateWorkflowInstance(
    input: UpdateWorkflowInstanceInput!
  ): UpdateWorkflowInstancePayload
  deleteWorkflowInstance(
    filter: WorkflowInstanceFilter!
  ): DeleteWorkflowInstancePayload
  addWorkflowInstanceProperty(
    input: [AddWorkflowInstancePropertyInput!]!
    upsert: Boolean
  ): AddWorkflowInstancePropertyPayload
  updateWorkflowInstanceProperty(
    input: UpdateWorkflowInstancePropertyInput!
  ): UpdateWorkflowInstancePropertyPayload
  deleteWorkflowInstanceProperty(
    filter: WorkflowInstancePropertyFilter!
  ): DeleteWorkflowInstancePropertyPayload
  addWorkflowNode(input: [AddWorkflowNodeInput!]!): AddWorkflowNodePayload
  updateWorkflowNode(input: UpdateWorkflowNodeInput!): UpdateWorkflowNodePayload
  deleteWorkflowNode(filter: WorkflowNodeFilter!): DeleteWorkflowNodePayload
  addWorkflowNodeInstance(
    input: [AddWorkflowNodeInstanceInput!]!
  ): AddWorkflowNodeInstancePayload
  updateWorkflowNodeInstance(
    input: UpdateWorkflowNodeInstanceInput!
  ): UpdateWorkflowNodeInstancePayload
  deleteWorkflowNodeInstance(
    filter: WorkflowNodeInstanceFilter!
  ): DeleteWorkflowNodeInstancePayload
  addWorkflowNodeEvent(
    input: [AddWorkflowNodeEventInput!]!
  ): AddWorkflowNodeEventPayload
  updateWorkflowNodeEvent(
    input: UpdateWorkflowNodeEventInput!
  ): UpdateWorkflowNodeEventPayload
  deleteWorkflowNodeEvent(
    filter: WorkflowNodeEventFilter!
  ): DeleteWorkflowNodeEventPayload
  addWorkflowNodeType(
    input: [AddWorkflowNodeTypeInput!]!
  ): AddWorkflowNodeTypePayload
  updateWorkflowNodeType(
    input: UpdateWorkflowNodeTypeInput!
  ): UpdateWorkflowNodeTypePayload
  deleteWorkflowNodeType(
    filter: WorkflowNodeTypeFilter!
  ): DeleteWorkflowNodeTypePayload
  addWorkflowConnection(
    input: [AddWorkflowConnectionInput!]!
  ): AddWorkflowConnectionPayload
  updateWorkflowConnection(
    input: UpdateWorkflowConnectionInput!
  ): UpdateWorkflowConnectionPayload
  deleteWorkflowConnection(
    filter: WorkflowConnectionFilter!
  ): DeleteWorkflowConnectionPayload
  addWorkflowConnectionType(
    input: [AddWorkflowConnectionTypeInput!]!
  ): AddWorkflowConnectionTypePayload
  updateWorkflowConnectionType(
    input: UpdateWorkflowConnectionTypeInput!
  ): UpdateWorkflowConnectionTypePayload
  deleteWorkflowConnectionType(
    filter: WorkflowConnectionTypeFilter!
  ): DeleteWorkflowConnectionTypePayload
  addWorkflowProperty(
    input: [AddWorkflowPropertyInput!]!
  ): AddWorkflowPropertyPayload
  updateWorkflowProperty(
    input: UpdateWorkflowPropertyInput!
  ): UpdateWorkflowPropertyPayload
  deleteWorkflowProperty(
    filter: WorkflowPropertyFilter!
  ): DeleteWorkflowPropertyPayload
  addWorkflowPropertyInstance(
    input: [AddWorkflowPropertyInstanceInput!]!
  ): AddWorkflowPropertyInstancePayload
  updateWorkflowPropertyInstance(
    input: UpdateWorkflowPropertyInstanceInput!
  ): UpdateWorkflowPropertyInstancePayload
  deleteWorkflowPropertyInstance(
    filter: WorkflowPropertyInstanceFilter!
  ): DeleteWorkflowPropertyInstancePayload
  addWorkflowPropertyValue(
    input: [AddWorkflowPropertyValueInput!]!
  ): AddWorkflowPropertyValuePayload
  updateWorkflowPropertyValue(
    input: UpdateWorkflowPropertyValueInput!
  ): UpdateWorkflowPropertyValuePayload
  deleteWorkflowPropertyValue(
    filter: WorkflowPropertyValueFilter!
  ): DeleteWorkflowPropertyValuePayload
  addForm(input: [AddFormInput!]!, upsert: Boolean): AddFormPayload
  updateForm(input: UpdateFormInput!): UpdateFormPayload
  deleteForm(filter: FormFilter!): DeleteFormPayload
  addPartner(input: [AddPartnerInput!]!): AddPartnerPayload
  updatePartner(input: UpdatePartnerInput!): UpdatePartnerPayload
  deletePartner(filter: PartnerFilter!): DeletePartnerPayload
  addShippingAccount(
    input: [AddShippingAccountInput!]!
  ): AddShippingAccountPayload
  updateShippingAccount(
    input: UpdateShippingAccountInput!
  ): UpdateShippingAccountPayload
  deleteShippingAccount(
    filter: ShippingAccountFilter!
  ): DeleteShippingAccountPayload
  addInventoryHandlingPolicy(
    input: [AddInventoryHandlingPolicyInput!]!
    upsert: Boolean
  ): AddInventoryHandlingPolicyPayload
  updateInventoryHandlingPolicy(
    input: UpdateInventoryHandlingPolicyInput!
  ): UpdateInventoryHandlingPolicyPayload
  deleteInventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter!
  ): DeleteInventoryHandlingPolicyPayload
  addInventoryHandlingRule(
    input: [AddInventoryHandlingRuleInput!]!
  ): AddInventoryHandlingRulePayload
  updateInventoryHandlingRule(
    input: UpdateInventoryHandlingRuleInput!
  ): UpdateInventoryHandlingRulePayload
  deleteInventoryHandlingRule(
    filter: InventoryHandlingRuleFilter!
  ): DeleteInventoryHandlingRulePayload
  addAddress(input: [AddAddressInput!]!): AddAddressPayload
  updateAddress(input: UpdateAddressInput!): UpdateAddressPayload
  deleteAddress(filter: AddressFilter!): DeleteAddressPayload
  addDelivery(input: [AddDeliveryInput!]!): AddDeliveryPayload
  updateDelivery(input: UpdateDeliveryInput!): UpdateDeliveryPayload
  deleteDelivery(filter: DeliveryFilter!): DeleteDeliveryPayload
  addOrder(input: [AddOrderInput!]!): AddOrderPayload
  updateOrder(input: UpdateOrderInput!): UpdateOrderPayload
  deleteOrder(filter: OrderFilter!): DeleteOrderPayload
  addOrderLine(input: [AddOrderLineInput!]!): AddOrderLinePayload
  updateOrderLine(input: UpdateOrderLineInput!): UpdateOrderLinePayload
  deleteOrderLine(filter: OrderLineFilter!): DeleteOrderLinePayload
  addShipment(input: [AddShipmentInput!]!): AddShipmentPayload
  updateShipment(input: UpdateShipmentInput!): UpdateShipmentPayload
  deleteShipment(filter: ShipmentFilter!): DeleteShipmentPayload
  addShipmentItem(input: [AddShipmentItemInput!]!): AddShipmentItemPayload
  updateShipmentItem(input: UpdateShipmentItemInput!): UpdateShipmentItemPayload
  deleteShipmentItem(filter: ShipmentItemFilter!): DeleteShipmentItemPayload
  addBox(input: [AddBoxInput!]!): AddBoxPayload
  updateBox(input: UpdateBoxInput!): UpdateBoxPayload
  deleteBox(filter: BoxFilter!): DeleteBoxPayload
  addGeneralLedgerAccount(
    input: [AddGeneralLedgerAccountInput!]!
    upsert: Boolean
  ): AddGeneralLedgerAccountPayload
  updateGeneralLedgerAccount(
    input: UpdateGeneralLedgerAccountInput!
  ): UpdateGeneralLedgerAccountPayload
  deleteGeneralLedgerAccount(
    filter: GeneralLedgerAccountFilter!
  ): DeleteGeneralLedgerAccountPayload
  addInterfaceMessageLog(
    input: [AddInterfaceMessageLogInput!]!
  ): AddInterfaceMessageLogPayload
  updateInterfaceMessageLog(
    input: UpdateInterfaceMessageLogInput!
  ): UpdateInterfaceMessageLogPayload
  deleteInterfaceMessageLog(
    filter: InterfaceMessageLogFilter!
  ): DeleteInterfaceMessageLogPayload
  confirmASN(input: [ConfirmASNInput!]!, siteID: String!): [Order]
  uploadProductionPlan(input: String!): [JobOrder]
  addInventoryTransactionReceive(
    input: [InventoryTransactionInput!]!
  ): [InventoryTransaction]
  moveCarrierToBin(input: [InventoryTransactionInput!]!): [InventoryTransaction]
  moveMaterialSubLots(input: MoveMaterialSubLotsInput!): [InventoryTransaction]
  moveMaterialQuantitiesBetweenCarriers(
    input: MoveMaterialQuantitiesBetweenCarriersInput!
  ): [InventoryTransaction]

  # method assumes that any backflushed materials are not tracked by carrier
  addInventoryActual(
    input: [AddInventoryActualInput!]!
  ): [AddInventoryActualPayload]
  receiveInboundShipments(input: [ReceiveInboundShipmentInput!]!): [Shipment]
  packInventoryTransaction(
    input: [InventoryTransactionInput!]!
  ): [InventoryTransaction]

  # method used to create an empty outbbound shipment to use with a delivery company
  createEmptyDeliveryShipment(
    shipment: ExtShipmentRef!
    shippingAccountData: ShippingAccountData!
  ): Shipment

  # method used to add shipment items to a shipment for a delivery company
  addShipmentItemsToDeliveryShipment(
    shipment: ExtShipmentRef!
    shipmentItems: [ExtShipmentItemRef!]!
    shippingAccountData: ShippingAccountData!
  ): Shipment

  # method used to create a shipment label to use with a delivery company
  createDeliveryShipmentLabel(
    shipment: ExtShipmentRef!
    shippingAccountData: ShippingAccountData!
  ): String
  createDeliveryShipmentItemLabel(
    shipment: ExtShipmentRef!
    item: ExtShipmentItemRef!
    shippingAccountData: ShippingAccountData!
  ): String
  createDeliveryOrderFromShipments(
    shipments: [ExtShipmentRef!]!
    shippingAccountData: ShippingAccountData!
  ): Delivery
  deleteDeliveryShipment(
    shipment: ExtShipmentRef!
    shippingAccountData: ShippingAccountData!
  ): Shipment
  deleteDeliveryShipmentItem(
    shipmentItem: ExtShipmentItemRef!
    shippingAccountData: ShippingAccountData!
  ): ShipmentItem
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

type OperationsDefinition {
  id: ID!
  isActive: Boolean
  name: String!
  material(filter: MaterialDefinitionFilter): MaterialDefinition
  version: String
  description: String
  operationsType: WorkType!
  hierarchyScope: String
  billOfMaterial(filter: BillOfMaterialFilter): BillOfMaterial
  segments(
    filter: OperationsSegmentFilter
    order: OperationsSegmentOrder
    first: Int
    offset: Int
  ): [OperationsSegment]
  segmentsAggregate(
    filter: OperationsSegmentFilter
  ): OperationsSegmentAggregateResult
}

type OperationsDefinitionAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  versionMin: String
  versionMax: String
  descriptionMin: String
  descriptionMax: String
  hierarchyScopeMin: String
  hierarchyScopeMax: String
}

input OperationsDefinitionFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  has: [OperationsDefinitionHasFilter]
  and: [OperationsDefinitionFilter]
  or: [OperationsDefinitionFilter]
  not: OperationsDefinitionFilter
}

enum OperationsDefinitionHasFilter {
  isActive
  name
  material
  version
  description
  operationsType
  hierarchyScope
  billOfMaterial
  segments
}

input OperationsDefinitionOrder {
  asc: OperationsDefinitionOrderable
  desc: OperationsDefinitionOrderable
  then: OperationsDefinitionOrder
}

enum OperationsDefinitionOrderable {
  name
  version
  description
  hierarchyScope
}

input OperationsDefinitionPatch {
  isActive: Boolean
  material: MaterialDefinitionRef
  version: String
  description: String
  operationsType: WorkType
  hierarchyScope: String
  billOfMaterial: BillOfMaterialRef
  segments: [OperationsSegmentRef]
}

input OperationsDefinitionRef {
  id: ID
  isActive: Boolean
  name: String
  material: MaterialDefinitionRef
  version: String
  description: String
  operationsType: WorkType
  hierarchyScope: String
  billOfMaterial: BillOfMaterialRef
  segments: [OperationsSegmentRef]
}

# A request for operations to be performed is an operations schedule.
# The schedule may apply to operations, maintenance, quality or inventory operations
type OperationsRequest {
  id: ID!
  isActive: Boolean
  code: String!
  operationsType: WorkType!
  plannedStartDateTime: DateTime
  plannedEndDateTime: DateTime
  priority: String
  operationsDefinition(
    filter: OperationsDefinitionFilter
  ): OperationsDefinition!
  requestState(filter: RequestStateFilter): RequestState!
  quantity: Float!
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure!
  jobOrders(
    filter: JobOrderFilter
    order: JobOrderOrder
    first: Int
    offset: Int
  ): [JobOrder]
  equipment(filter: EquipmentFilter): Equipment
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  jobOrdersAggregate(filter: JobOrderFilter): JobOrderAggregateResult
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  actualProducedQuantity: Float
  actualStartDateTime: DateTime
}

type OperationsRequestAggregateResult {
  count: Int
  codeMin: String
  codeMax: String
  plannedStartDateTimeMin: DateTime
  plannedStartDateTimeMax: DateTime
  plannedEndDateTimeMin: DateTime
  plannedEndDateTimeMax: DateTime
  priorityMin: String
  priorityMax: String
  quantityMin: Float
  quantityMax: Float
  quantitySum: Float
  quantityAvg: Float
}

input OperationsRequestFilter {
  id: [ID!]
  isActive: Boolean
  code: StringHashFilter
  has: [OperationsRequestHasFilter]
  and: [OperationsRequestFilter]
  or: [OperationsRequestFilter]
  not: OperationsRequestFilter
}

enum OperationsRequestHasFilter {
  isActive
  code
  operationsType
  plannedStartDateTime
  plannedEndDateTime
  priority
  operationsDefinition
  requestState
  quantity
  quantityUoM
  jobOrders
  equipment
  properties
}

input OperationsRequestOrder {
  asc: OperationsRequestOrderable
  desc: OperationsRequestOrderable
  then: OperationsRequestOrder
}

enum OperationsRequestOrderable {
  code
  plannedStartDateTime
  plannedEndDateTime
  priority
  quantity
}

input OperationsRequestPatch {
  isActive: Boolean
  operationsType: WorkType
  plannedStartDateTime: DateTime
  plannedEndDateTime: DateTime
  priority: String
  operationsDefinition: OperationsDefinitionRef
  requestState: RequestStateRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  jobOrders: [JobOrderRef]
  equipment: EquipmentRef
  properties: [PropertyRef]
}

input OperationsRequestRef {
  id: ID
  isActive: Boolean
  code: String
  operationsType: WorkType
  plannedStartDateTime: DateTime
  plannedEndDateTime: DateTime
  priority: String
  operationsDefinition: OperationsDefinitionRef
  requestState: RequestStateRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  jobOrders: [JobOrderRef]
  equipment: EquipmentRef
  properties: [PropertyRef]
}

type OperationsRequestStaging {
  code: String
  materialNo: String
  plannedStartDateTime: DateTime
  plannedEndDateTime: DateTime
  quantityUoM: String
  quantity: Float
  errList: [String]
  isValid: Boolean
  operationsDefinition: String
}

input OperationsRequestStagingInput {
  code: String!
  plannedStartDateTime: DateTime!
  plannedEndDateTime: DateTime!
  quantity: Float!
  quantityUoM: String
  operationsDefinition: String!
}

type OperationsSegment {
  id: ID!
  isActive: Boolean
  name: String!
  version: String
  type: SegmentType
  uiComponent: String
  description: String
  parent(filter: OperationsSegmentFilter): OperationsSegment
  children(
    filter: OperationsSegmentFilter
    order: OperationsSegmentOrder
    first: Int
    offset: Int
  ): [OperationsSegment]
  workType: WorkType
  workDefinitionType: String
  duration: Float
  glAccountWIP: String
  glAccountWIPInvoice: String
  glAccountFixedOverhead: String
  glAccountVariableOverhead: String
  glAccountDirectLabour: String
  invoiceSettings(
    filter: SegmentInvoiceSettingFilter
    order: SegmentInvoiceSettingOrder
    first: Int
    offset: Int
  ): [SegmentInvoiceSetting]
  costAmountFixedOverhead: Float
  costDriverFixedOverhead: CostDriver
  costAmountVariableOverhead: Float
  costAmountDirectLabourRate: Float
  durationUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  orderStartRuleset(filter: OrderStartRulesetFilter): OrderStartRuleset
  materialSpecifications(
    filter: MaterialSpecificationFilter
    order: MaterialSpecificationOrder
    first: Int
    offset: Int
  ): [MaterialSpecification]
  materialEventRuleset(filter: MaterialEventRulesetFilter): MaterialEventRuleset
  equipmentSpecifications(
    filter: EquipmentSpecificationFilter
    order: EquipmentSpecificationOrder
    first: Int
    offset: Int
  ): [EquipmentSpecification]
  stateEventRuleset(filter: StateEventRulesetFilter): StateEventRuleset
  personnelSpecifications(
    filter: PersonnelSpecificationFilter
    order: PersonnelSpecificationOrder
    first: Int
    offset: Int
  ): [PersonnelSpecification]
  parameterSpecifications(
    filter: ParameterSpecificationFilter
    order: ParameterSpecificationOrder
    first: Int
    offset: Int
  ): [ParameterSpecification]
  hierarchyScope: String
  inflows(
    filter: SegmentDependencyFilter
    order: SegmentDependencyOrder
    first: Int
    offset: Int
  ): [SegmentDependency]
  outflows(
    filter: SegmentDependencyFilter
    order: SegmentDependencyOrder
    first: Int
    offset: Int
  ): [SegmentDependency]
  operationsDefinition(filter: OperationsDefinitionFilter): OperationsDefinition
  jobOrders(
    filter: JobOrderFilter
    order: JobOrderOrder
    first: Int
    offset: Int
  ): [JobOrder]
  mpmPlanRate: Float
  mpmIdealSetupTime: Float
  mpmIdealChangeoverTime: Float
  mpmEnableSmartChangeover: Boolean
  mpmChangeoverFamily: String
  mpmThresholdRunRate: Float
  mpmThresholdRunDuration: Float
  mpmThresholdSlowRate: Float
  mpmThresholdSlowDuration: Float
  mpmThresholdMicrostopDuration: Float
  mpmEnableAutoIdent: Boolean
  mpmAutoIdentMatchCode(filter: PropertyFilter): Property
  positionX: Int
  positionY: Int
  childrenAggregate(
    filter: OperationsSegmentFilter
  ): OperationsSegmentAggregateResult
  invoiceSettingsAggregate(
    filter: SegmentInvoiceSettingFilter
  ): SegmentInvoiceSettingAggregateResult
  materialSpecificationsAggregate(
    filter: MaterialSpecificationFilter
  ): MaterialSpecificationAggregateResult
  equipmentSpecificationsAggregate(
    filter: EquipmentSpecificationFilter
  ): EquipmentSpecificationAggregateResult
  personnelSpecificationsAggregate(
    filter: PersonnelSpecificationFilter
  ): PersonnelSpecificationAggregateResult
  parameterSpecificationsAggregate(
    filter: ParameterSpecificationFilter
  ): ParameterSpecificationAggregateResult
  inflowsAggregate(
    filter: SegmentDependencyFilter
  ): SegmentDependencyAggregateResult
  outflowsAggregate(
    filter: SegmentDependencyFilter
  ): SegmentDependencyAggregateResult
  jobOrdersAggregate(filter: JobOrderFilter): JobOrderAggregateResult
}

type OperationsSegmentAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  versionMin: String
  versionMax: String
  uiComponentMin: String
  uiComponentMax: String
  descriptionMin: String
  descriptionMax: String
  workDefinitionTypeMin: String
  workDefinitionTypeMax: String
  durationMin: Float
  durationMax: Float
  durationSum: Float
  durationAvg: Float
  glAccountWIPMin: String
  glAccountWIPMax: String
  glAccountWIPInvoiceMin: String
  glAccountWIPInvoiceMax: String
  glAccountFixedOverheadMin: String
  glAccountFixedOverheadMax: String
  glAccountVariableOverheadMin: String
  glAccountVariableOverheadMax: String
  glAccountDirectLabourMin: String
  glAccountDirectLabourMax: String
  costAmountFixedOverheadMin: Float
  costAmountFixedOverheadMax: Float
  costAmountFixedOverheadSum: Float
  costAmountFixedOverheadAvg: Float
  costAmountVariableOverheadMin: Float
  costAmountVariableOverheadMax: Float
  costAmountVariableOverheadSum: Float
  costAmountVariableOverheadAvg: Float
  costAmountDirectLabourRateMin: Float
  costAmountDirectLabourRateMax: Float
  costAmountDirectLabourRateSum: Float
  costAmountDirectLabourRateAvg: Float
  hierarchyScopeMin: String
  hierarchyScopeMax: String
  mpmPlanRateMin: Float
  mpmPlanRateMax: Float
  mpmPlanRateSum: Float
  mpmPlanRateAvg: Float
  mpmIdealSetupTimeMin: Float
  mpmIdealSetupTimeMax: Float
  mpmIdealSetupTimeSum: Float
  mpmIdealSetupTimeAvg: Float
  mpmIdealChangeoverTimeMin: Float
  mpmIdealChangeoverTimeMax: Float
  mpmIdealChangeoverTimeSum: Float
  mpmIdealChangeoverTimeAvg: Float
  mpmChangeoverFamilyMin: String
  mpmChangeoverFamilyMax: String
  mpmThresholdRunRateMin: Float
  mpmThresholdRunRateMax: Float
  mpmThresholdRunRateSum: Float
  mpmThresholdRunRateAvg: Float
  mpmThresholdRunDurationMin: Float
  mpmThresholdRunDurationMax: Float
  mpmThresholdRunDurationSum: Float
  mpmThresholdRunDurationAvg: Float
  mpmThresholdSlowRateMin: Float
  mpmThresholdSlowRateMax: Float
  mpmThresholdSlowRateSum: Float
  mpmThresholdSlowRateAvg: Float
  mpmThresholdSlowDurationMin: Float
  mpmThresholdSlowDurationMax: Float
  mpmThresholdSlowDurationSum: Float
  mpmThresholdSlowDurationAvg: Float
  mpmThresholdMicrostopDurationMin: Float
  mpmThresholdMicrostopDurationMax: Float
  mpmThresholdMicrostopDurationSum: Float
  mpmThresholdMicrostopDurationAvg: Float
  positionXMin: Int
  positionXMax: Int
  positionXSum: Int
  positionXAvg: Float
  positionYMin: Int
  positionYMax: Int
  positionYSum: Int
  positionYAvg: Float
}

input OperationsSegmentFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  description: StringHashFilter
  workType: WorkType_hash
  workDefinitionType: StringHashFilter
  has: [OperationsSegmentHasFilter]
  and: [OperationsSegmentFilter]
  or: [OperationsSegmentFilter]
  not: OperationsSegmentFilter
}

enum OperationsSegmentHasFilter {
  isActive
  name
  version
  type
  uiComponent
  description
  parent
  children
  workType
  workDefinitionType
  duration
  glAccountWIP
  glAccountWIPInvoice
  glAccountFixedOverhead
  glAccountVariableOverhead
  glAccountDirectLabour
  invoiceSettings
  costAmountFixedOverhead
  costDriverFixedOverhead
  costAmountVariableOverhead
  costAmountDirectLabourRate
  durationUoM
  orderStartRuleset
  materialSpecifications
  materialEventRuleset
  equipmentSpecifications
  stateEventRuleset
  personnelSpecifications
  parameterSpecifications
  hierarchyScope
  inflows
  outflows
  operationsDefinition
  jobOrders
  mpmPlanRate
  mpmIdealSetupTime
  mpmIdealChangeoverTime
  mpmEnableSmartChangeover
  mpmChangeoverFamily
  mpmThresholdRunRate
  mpmThresholdRunDuration
  mpmThresholdSlowRate
  mpmThresholdSlowDuration
  mpmThresholdMicrostopDuration
  mpmEnableAutoIdent
  mpmAutoIdentMatchCode
  positionX
  positionY
}

input OperationsSegmentOrder {
  asc: OperationsSegmentOrderable
  desc: OperationsSegmentOrderable
  then: OperationsSegmentOrder
}

enum OperationsSegmentOrderable {
  name
  version
  uiComponent
  description
  workDefinitionType
  duration
  glAccountWIP
  glAccountWIPInvoice
  glAccountFixedOverhead
  glAccountVariableOverhead
  glAccountDirectLabour
  costAmountFixedOverhead
  costAmountVariableOverhead
  costAmountDirectLabourRate
  hierarchyScope
  mpmPlanRate
  mpmIdealSetupTime
  mpmIdealChangeoverTime
  mpmChangeoverFamily
  mpmThresholdRunRate
  mpmThresholdRunDuration
  mpmThresholdSlowRate
  mpmThresholdSlowDuration
  mpmThresholdMicrostopDuration
  positionX
  positionY
}

input OperationsSegmentPatch {
  isActive: Boolean
  name: String
  version: String
  type: SegmentType
  uiComponent: String
  description: String
  parent: OperationsSegmentRef
  children: [OperationsSegmentRef]
  workType: WorkType
  workDefinitionType: String
  duration: Float
  glAccountWIP: String
  glAccountWIPInvoice: String
  glAccountFixedOverhead: String
  glAccountVariableOverhead: String
  glAccountDirectLabour: String
  invoiceSettings: [SegmentInvoiceSettingRef]
  costAmountFixedOverhead: Float
  costDriverFixedOverhead: CostDriver
  costAmountVariableOverhead: Float
  costAmountDirectLabourRate: Float
  durationUoM: UnitOfMeasureRef
  orderStartRuleset: OrderStartRulesetRef
  materialSpecifications: [MaterialSpecificationRef]
  materialEventRuleset: MaterialEventRulesetRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  stateEventRuleset: StateEventRulesetRef
  personnelSpecifications: [PersonnelSpecificationRef]
  parameterSpecifications: [ParameterSpecificationRef]
  hierarchyScope: String
  inflows: [SegmentDependencyRef]
  outflows: [SegmentDependencyRef]
  operationsDefinition: OperationsDefinitionRef
  jobOrders: [JobOrderRef]
  mpmPlanRate: Float
  mpmIdealSetupTime: Float
  mpmIdealChangeoverTime: Float
  mpmEnableSmartChangeover: Boolean
  mpmChangeoverFamily: String
  mpmThresholdRunRate: Float
  mpmThresholdRunDuration: Float
  mpmThresholdSlowRate: Float
  mpmThresholdSlowDuration: Float
  mpmThresholdMicrostopDuration: Float
  mpmEnableAutoIdent: Boolean
  mpmAutoIdentMatchCode: PropertyRef
  positionX: Int
  positionY: Int
}

input OperationsSegmentRef {
  id: ID
  isActive: Boolean
  name: String
  version: String
  type: SegmentType
  uiComponent: String
  description: String
  parent: OperationsSegmentRef
  children: [OperationsSegmentRef]
  workType: WorkType
  workDefinitionType: String
  duration: Float
  glAccountWIP: String
  glAccountWIPInvoice: String
  glAccountFixedOverhead: String
  glAccountVariableOverhead: String
  glAccountDirectLabour: String
  invoiceSettings: [SegmentInvoiceSettingRef]
  costAmountFixedOverhead: Float
  costDriverFixedOverhead: CostDriver
  costAmountVariableOverhead: Float
  costAmountDirectLabourRate: Float
  durationUoM: UnitOfMeasureRef
  orderStartRuleset: OrderStartRulesetRef
  materialSpecifications: [MaterialSpecificationRef]
  materialEventRuleset: MaterialEventRulesetRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  stateEventRuleset: StateEventRulesetRef
  personnelSpecifications: [PersonnelSpecificationRef]
  parameterSpecifications: [ParameterSpecificationRef]
  hierarchyScope: String
  inflows: [SegmentDependencyRef]
  outflows: [SegmentDependencyRef]
  operationsDefinition: OperationsDefinitionRef
  jobOrders: [JobOrderRef]
  mpmPlanRate: Float
  mpmIdealSetupTime: Float
  mpmIdealChangeoverTime: Float
  mpmEnableSmartChangeover: Boolean
  mpmChangeoverFamily: String
  mpmThresholdRunRate: Float
  mpmThresholdRunDuration: Float
  mpmThresholdSlowRate: Float
  mpmThresholdSlowDuration: Float
  mpmThresholdMicrostopDuration: Float
  mpmEnableAutoIdent: Boolean
  mpmAutoIdentMatchCode: PropertyRef
  positionX: Int
  positionY: Int
}

# An outbound Sales Order to be fulfilled
type Order {
  id: ID!
  isActive: Boolean
  orderType: OrderType!
  customerOrderNumber: String
  customerReference: String
  deliveryTerms: IncoTerms
  status: OrderStatus!
  shipFromPartner(filter: PartnerFilter): Partner
  shipToPartner(filter: PartnerFilter): Partner
  invoiceFromPartner(filter: PartnerFilter): Partner
  invoiceToPartner(filter: PartnerFilter): Partner
  warehouse(filter: EquipmentFilter): Equipment
  lines(
    filter: OrderLineFilter
    order: OrderLineOrder
    first: Int
    offset: Int
  ): [OrderLine]
  shipments(
    filter: ShipmentFilter
    order: ShipmentOrder
    first: Int
    offset: Int
  ): [Shipment]
  notes: String
  createdDateTime: DateTime
  linesAggregate(filter: OrderLineFilter): OrderLineAggregateResult
  shipmentsAggregate(filter: ShipmentFilter): ShipmentAggregateResult
  linesWithAlternates: [OrderLine]
  materialList: [MaterialDefinition]
}

type OrderAggregateResult {
  count: Int
  customerOrderNumberMin: String
  customerOrderNumberMax: String
  customerReferenceMin: String
  customerReferenceMax: String
  notesMin: String
  notesMax: String
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
}

input OrderFilter {
  id: [ID!]
  isActive: Boolean
  orderType: OrderType_hash
  customerOrderNumber: StringFullTextFilter_StringHashFilter
  has: [OrderHasFilter]
  and: [OrderFilter]
  or: [OrderFilter]
  not: OrderFilter
}

enum OrderHasFilter {
  isActive
  orderType
  customerOrderNumber
  customerReference
  deliveryTerms
  status
  shipFromPartner
  shipToPartner
  invoiceFromPartner
  invoiceToPartner
  warehouse
  lines
  shipments
  notes
  createdDateTime
}

type OrderLine {
  id: ID!
  isActive: Boolean
  order(filter: OrderFilter): Order
  orderLineNumber: Int!
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
  quantity: Int!
  defectiveSerialNumbers: String
  isReturn: Boolean
  workflowInstance(filter: WorkflowInstanceFilter): WorkflowInstance
  stockOnHandQty: Float
  packedQty: Float
}

type OrderLineAggregateResult {
  count: Int
  orderLineNumberMin: Int
  orderLineNumberMax: Int
  orderLineNumberSum: Int
  orderLineNumberAvg: Float
  quantityMin: Int
  quantityMax: Int
  quantitySum: Int
  quantityAvg: Float
  defectiveSerialNumbersMin: String
  defectiveSerialNumbersMax: String
}

input OrderLineFilter {
  id: [ID!]
  isActive: Boolean
  has: [OrderLineHasFilter]
  and: [OrderLineFilter]
  or: [OrderLineFilter]
  not: OrderLineFilter
}

enum OrderLineHasFilter {
  isActive
  order
  orderLineNumber
  material
  quantity
  defectiveSerialNumbers
  isReturn
  workflowInstance
}

input OrderLineOrder {
  asc: OrderLineOrderable
  desc: OrderLineOrderable
  then: OrderLineOrder
}

enum OrderLineOrderable {
  orderLineNumber
  quantity
  defectiveSerialNumbers
}

input OrderLinePatch {
  isActive: Boolean
  order: OrderRef
  orderLineNumber: Int
  material: MaterialDefinitionRef
  quantity: Int
  defectiveSerialNumbers: String
  isReturn: Boolean
  workflowInstance: WorkflowInstanceRef
}

input OrderLineRef {
  id: ID
  isActive: Boolean
  order: OrderRef
  orderLineNumber: Int
  material: MaterialDefinitionRef
  quantity: Int
  defectiveSerialNumbers: String
  isReturn: Boolean
  workflowInstance: WorkflowInstanceRef
}

input OrderOrder {
  asc: OrderOrderable
  desc: OrderOrderable
  then: OrderOrder
}

enum OrderOrderable {
  customerOrderNumber
  customerReference
  notes
  createdDateTime
}

input OrderPatch {
  isActive: Boolean
  orderType: OrderType
  customerOrderNumber: String
  customerReference: String
  deliveryTerms: IncoTerms
  status: OrderStatus
  shipFromPartner: PartnerRef
  shipToPartner: PartnerRef
  invoiceFromPartner: PartnerRef
  invoiceToPartner: PartnerRef
  warehouse: EquipmentRef
  lines: [OrderLineRef]
  shipments: [ShipmentRef]
  notes: String
  createdDateTime: DateTime
}

input OrderRef {
  id: ID
  isActive: Boolean
  orderType: OrderType
  customerOrderNumber: String
  customerReference: String
  deliveryTerms: IncoTerms
  status: OrderStatus
  shipFromPartner: PartnerRef
  shipToPartner: PartnerRef
  invoiceFromPartner: PartnerRef
  invoiceToPartner: PartnerRef
  warehouse: EquipmentRef
  lines: [OrderLineRef]
  shipments: [ShipmentRef]
  notes: String
  createdDateTime: DateTime
}

type OrderStartRuleset {
  id: ID!
  name: String!
  segment(filter: OperationsSegmentFilter): OperationsSegment
  eventDefs(
    filter: EventDefinitionFilter
    order: EventDefinitionOrder
    first: Int
    offset: Int
  ): [EventDefinition]
  eventDefsAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
}

type OrderStartRulesetAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input OrderStartRulesetFilter {
  id: [ID!]
  has: [OrderStartRulesetHasFilter]
  and: [OrderStartRulesetFilter]
  or: [OrderStartRulesetFilter]
  not: OrderStartRulesetFilter
}

enum OrderStartRulesetHasFilter {
  name
  segment
  eventDefs
}

input OrderStartRulesetOrder {
  asc: OrderStartRulesetOrderable
  desc: OrderStartRulesetOrderable
  then: OrderStartRulesetOrder
}

enum OrderStartRulesetOrderable {
  name
}

input OrderStartRulesetPatch {
  name: String
  segment: OperationsSegmentRef
  eventDefs: [EventDefinitionRef]
}

input OrderStartRulesetRef {
  id: ID
  name: String
  segment: OperationsSegmentRef
  eventDefs: [EventDefinitionRef]
}

enum OrderStatus {
  CREATED
  RECEIVED
  PACKED
  SHIPPED
  DELIVERED
  COMPLETE
}

enum OrderType {
  SALES_ORDER
  RETURN_ORDER
  REPLACE_ORDER
  REPAIR_ORDER
  PURCHASE_ORDER
}

input OrderType_hash {
  eq: OrderType
  in: [OrderType]
}

type PackedItem {
  material: MaterialDefinition
  Qty: Float
  SerialNumber: String
  FromPlace: PackedItemFrom
}

type PackedItemFrom {
  storageLocation: Equipment
  materialSubLot: MaterialSubLot
  carrier: Carrier
}

input PackedItemsFilter {
  isTerminal: Boolean
  isAccessory: Boolean
}

type ParameterSpecification {
  id: ID!
  isActive: Boolean
  jobOrder(filter: JobOrderFilter): JobOrder
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment
  material(filter: MaterialDefinitionFilter): MaterialDefinition
  property(filter: PropertyFilter): Property!
  valueDefault: String
  valueSetPoint: String
  valueUpperSpecLimit: Float
  valueLowerSpecLimit: Float
  valueUpperControlLimit: Float
  valueLowerControlLimit: Float
}

type ParameterSpecificationAggregateResult {
  count: Int
  valueDefaultMin: String
  valueDefaultMax: String
  valueSetPointMin: String
  valueSetPointMax: String
  valueUpperSpecLimitMin: Float
  valueUpperSpecLimitMax: Float
  valueUpperSpecLimitSum: Float
  valueUpperSpecLimitAvg: Float
  valueLowerSpecLimitMin: Float
  valueLowerSpecLimitMax: Float
  valueLowerSpecLimitSum: Float
  valueLowerSpecLimitAvg: Float
  valueUpperControlLimitMin: Float
  valueUpperControlLimitMax: Float
  valueUpperControlLimitSum: Float
  valueUpperControlLimitAvg: Float
  valueLowerControlLimitMin: Float
  valueLowerControlLimitMax: Float
  valueLowerControlLimitSum: Float
  valueLowerControlLimitAvg: Float
}

input ParameterSpecificationFilter {
  id: [ID!]
  isActive: Boolean
  has: [ParameterSpecificationHasFilter]
  and: [ParameterSpecificationFilter]
  or: [ParameterSpecificationFilter]
  not: ParameterSpecificationFilter
}

enum ParameterSpecificationHasFilter {
  isActive
  jobOrder
  operationsSegment
  material
  property
  valueDefault
  valueSetPoint
  valueUpperSpecLimit
  valueLowerSpecLimit
  valueUpperControlLimit
  valueLowerControlLimit
}

input ParameterSpecificationOrder {
  asc: ParameterSpecificationOrderable
  desc: ParameterSpecificationOrderable
  then: ParameterSpecificationOrder
}

enum ParameterSpecificationOrderable {
  valueDefault
  valueSetPoint
  valueUpperSpecLimit
  valueLowerSpecLimit
  valueUpperControlLimit
  valueLowerControlLimit
}

input ParameterSpecificationPatch {
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  material: MaterialDefinitionRef
  property: PropertyRef
  valueDefault: String
  valueSetPoint: String
  valueUpperSpecLimit: Float
  valueLowerSpecLimit: Float
  valueUpperControlLimit: Float
  valueLowerControlLimit: Float
}

input ParameterSpecificationRef {
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  material: MaterialDefinitionRef
  property: PropertyRef
  valueDefault: String
  valueSetPoint: String
  valueUpperSpecLimit: Float
  valueLowerSpecLimit: Float
  valueUpperControlLimit: Float
  valueLowerControlLimit: Float
}

type Partner {
  id: ID!
  isActive: Boolean
  companyCode: String!
  name: String
  vatNumber: String
  registrationNumber: String
  contactName: String
  contactEmail: String
  contactPhone: String
  shippingAddress(filter: AddressFilter): Address
  billingAddress(filter: AddressFilter): Address
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  carriers(
    filter: CarrierFilter
    order: CarrierOrder
    first: Int
    offset: Int
  ): [Carrier]
  fromOrders(
    filter: OrderFilter
    order: OrderOrder
    first: Int
    offset: Int
  ): [Order]
  toOrders(
    filter: OrderFilter
    order: OrderOrder
    first: Int
    offset: Int
  ): [Order]
  shippingAccounts(
    filter: ShippingAccountFilter
    order: ShippingAccountOrder
    first: Int
    offset: Int
  ): [ShippingAccount]
  carriersAggregate(filter: CarrierFilter): CarrierAggregateResult
  fromOrdersAggregate(filter: OrderFilter): OrderAggregateResult
  toOrdersAggregate(filter: OrderFilter): OrderAggregateResult
  shippingAccountsAggregate(
    filter: ShippingAccountFilter
  ): ShippingAccountAggregateResult
}

type PartnerAggregateResult {
  count: Int
  companyCodeMin: String
  companyCodeMax: String
  nameMin: String
  nameMax: String
  vatNumberMin: String
  vatNumberMax: String
  registrationNumberMin: String
  registrationNumberMax: String
  contactNameMin: String
  contactNameMax: String
  contactEmailMin: String
  contactEmailMax: String
  contactPhoneMin: String
  contactPhoneMax: String
}

input PartnerFilter {
  id: [ID!]
  isActive: Boolean
  companyCode: StringHashFilter
  name: StringHashFilter
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  has: [PartnerHasFilter]
  and: [PartnerFilter]
  or: [PartnerFilter]
  not: PartnerFilter
}

enum PartnerHasFilter {
  isActive
  companyCode
  name
  vatNumber
  registrationNumber
  contactName
  contactEmail
  contactPhone
  shippingAddress
  billingAddress
  isMerchant
  isRepairer
  isSupplier
  isTransport
  isCustomer
  isInventoryOwner
  carriers
  fromOrders
  toOrders
  shippingAccounts
}

input PartnerOrder {
  asc: PartnerOrderable
  desc: PartnerOrderable
  then: PartnerOrder
}

enum PartnerOrderable {
  companyCode
  name
  vatNumber
  registrationNumber
  contactName
  contactEmail
  contactPhone
}

input PartnerPatch {
  isActive: Boolean
  companyCode: String
  name: String
  vatNumber: String
  registrationNumber: String
  contactName: String
  contactEmail: String
  contactPhone: String
  shippingAddress: AddressRef
  billingAddress: AddressRef
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  carriers: [CarrierRef]
  fromOrders: [OrderRef]
  toOrders: [OrderRef]
  shippingAccounts: [ShippingAccountRef]
}

input PartnerRef {
  id: ID
  isActive: Boolean
  companyCode: String
  name: String
  vatNumber: String
  registrationNumber: String
  contactName: String
  contactEmail: String
  contactPhone: String
  shippingAddress: AddressRef
  billingAddress: AddressRef
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  carriers: [CarrierRef]
  fromOrders: [OrderRef]
  toOrders: [OrderRef]
  shippingAccounts: [ShippingAccountRef]
}

type PayloadFieldDefinition {
  id: ID!
  isActive: Boolean
  name: String!
  expression: String!
  fieldType: PayloadFieldType
}

type PayloadFieldDefinitionAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  expressionMin: String
  expressionMax: String
}

input PayloadFieldDefinitionFilter {
  id: [ID!]
  isActive: Boolean
  has: [PayloadFieldDefinitionHasFilter]
  and: [PayloadFieldDefinitionFilter]
  or: [PayloadFieldDefinitionFilter]
  not: PayloadFieldDefinitionFilter
}

enum PayloadFieldDefinitionHasFilter {
  isActive
  name
  expression
  fieldType
}

input PayloadFieldDefinitionOrder {
  asc: PayloadFieldDefinitionOrderable
  desc: PayloadFieldDefinitionOrderable
  then: PayloadFieldDefinitionOrder
}

enum PayloadFieldDefinitionOrderable {
  name
  expression
}

input PayloadFieldDefinitionPatch {
  isActive: Boolean
  name: String
  expression: String
  fieldType: PayloadFieldType
}

input PayloadFieldDefinitionRef {
  id: ID
  isActive: Boolean
  name: String
  expression: String
  fieldType: PayloadFieldType
}

enum PayloadFieldType {
  Tag
  Field
  Other
}

type Person {
  id: ID!
  isActive: Boolean
  name: String!
  description: String
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  memberOf(
    filter: PersonnelClassFilter
    order: PersonnelClassOrder
    first: Int
    offset: Int
  ): [PersonnelClass]
  personnelActual(
    filter: PersonnelActualFilter
    order: PersonnelActualOrder
    first: Int
    offset: Int
  ): [PersonnelActual]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  memberOfAggregate(filter: PersonnelClassFilter): PersonnelClassAggregateResult
  personnelActualAggregate(
    filter: PersonnelActualFilter
  ): PersonnelActualAggregateResult
}

type PersonAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
}

input PersonFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  has: [PersonHasFilter]
  and: [PersonFilter]
  or: [PersonFilter]
  not: PersonFilter
}

enum PersonHasFilter {
  isActive
  name
  description
  properties
  memberOf
  personnelActual
}

type PersonnelActual {
  id: ID!
  isActive: Boolean
  jobResponse(filter: JobResponseFilter): JobResponse!
  person(filter: PersonFilter): Person
  quantity: Float
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type PersonnelActualAggregateResult {
  count: Int
  quantityMin: Float
  quantityMax: Float
  quantitySum: Float
  quantityAvg: Float
}

input PersonnelActualFilter {
  id: [ID!]
  isActive: Boolean
  has: [PersonnelActualHasFilter]
  and: [PersonnelActualFilter]
  or: [PersonnelActualFilter]
  not: PersonnelActualFilter
}

enum PersonnelActualHasFilter {
  isActive
  jobResponse
  person
  quantity
  quantityUoM
}

input PersonnelActualOrder {
  asc: PersonnelActualOrderable
  desc: PersonnelActualOrderable
  then: PersonnelActualOrder
}

enum PersonnelActualOrderable {
  quantity
}

input PersonnelActualPatch {
  isActive: Boolean
  jobResponse: JobResponseRef
  person: PersonRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

input PersonnelActualRef {
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  person: PersonRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

# Personnel Class represents a grouping of personnel with similar characteristics
type PersonnelClass {
  id: ID!
  isActive: Boolean
  name: String!
  description: String
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  persons(
    filter: PersonFilter
    order: PersonOrder
    first: Int
    offset: Int
  ): [Person]
  isTestedBy(
    filter: TestSpecificationFilter
    order: TestSpecificationOrder
    first: Int
    offset: Int
  ): [TestSpecification]
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  personsAggregate(filter: PersonFilter): PersonAggregateResult
  isTestedByAggregate(
    filter: TestSpecificationFilter
  ): TestSpecificationAggregateResult
}

type PersonnelClassAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
}

input PersonnelClassFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  has: [PersonnelClassHasFilter]
  and: [PersonnelClassFilter]
  or: [PersonnelClassFilter]
  not: PersonnelClassFilter
}

enum PersonnelClassHasFilter {
  isActive
  name
  description
  properties
  persons
  isTestedBy
}

input PersonnelClassOrder {
  asc: PersonnelClassOrderable
  desc: PersonnelClassOrderable
  then: PersonnelClassOrder
}

enum PersonnelClassOrderable {
  name
  description
}

input PersonnelClassPatch {
  isActive: Boolean
  description: String
  properties: [PropertyRef]
  persons: [PersonRef]
  isTestedBy: [TestSpecificationRef]
}

input PersonnelClassRef {
  id: ID
  isActive: Boolean
  name: String
  description: String
  properties: [PropertyRef]
  persons: [PersonRef]
  isTestedBy: [TestSpecificationRef]
}

type PersonnelSpecification {
  id: ID!
  isActive: Boolean
  jobOrder(filter: JobOrderFilter): JobOrder
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment
  person(filter: PersonFilter): Person
  personnelClass(filter: PersonnelClassFilter): PersonnelClass
  description: String
  personnelUse: String
  quantity: Float
  uom(filter: UnitOfMeasureFilter): UnitOfMeasure
}

type PersonnelSpecificationAggregateResult {
  count: Int
  descriptionMin: String
  descriptionMax: String
  personnelUseMin: String
  personnelUseMax: String
  quantityMin: Float
  quantityMax: Float
  quantitySum: Float
  quantityAvg: Float
}

input PersonnelSpecificationFilter {
  id: [ID!]
  isActive: Boolean
  has: [PersonnelSpecificationHasFilter]
  and: [PersonnelSpecificationFilter]
  or: [PersonnelSpecificationFilter]
  not: PersonnelSpecificationFilter
}

enum PersonnelSpecificationHasFilter {
  isActive
  jobOrder
  operationsSegment
  person
  personnelClass
  description
  personnelUse
  quantity
  uom
}

input PersonnelSpecificationOrder {
  asc: PersonnelSpecificationOrderable
  desc: PersonnelSpecificationOrderable
  then: PersonnelSpecificationOrder
}

enum PersonnelSpecificationOrderable {
  description
  personnelUse
  quantity
}

input PersonnelSpecificationPatch {
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  person: PersonRef
  personnelClass: PersonnelClassRef
  description: String
  personnelUse: String
  quantity: Float
  uom: UnitOfMeasureRef
}

input PersonnelSpecificationRef {
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  person: PersonRef
  personnelClass: PersonnelClassRef
  description: String
  personnelUse: String
  quantity: Float
  uom: UnitOfMeasureRef
}

input PersonOrder {
  asc: PersonOrderable
  desc: PersonOrderable
  then: PersonOrder
}

enum PersonOrderable {
  name
  description
}

input PersonPatch {
  isActive: Boolean
  description: String
  properties: [PropertyRef]
  memberOf: [PersonnelClassRef]
  personnelActual: [PersonnelActualRef]
}

input PersonRef {
  id: ID
  isActive: Boolean
  name: String
  description: String
  properties: [PropertyRef]
  memberOf: [PersonnelClassRef]
  personnelActual: [PersonnelActualRef]
}

input PlanningSummaryFilter {
  equipmentName: String!
  materialCode: String
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  near: NearFilter
  within: WithinFilter
  contains: ContainsFilter
  intersects: IntersectsFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

type Property {
  id: ID!
  isActive: Boolean
  type: PropertyType
  name: String!
  description: String!
  dataType: DataType
  definedBy(filter: PropertyFilter): Property
  address: String
  expression: String
  value: String
  unitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure
  storeHistory: Boolean
  isTestedBy(
    filter: TestSpecificationFilter
    order: TestSpecificationOrder
    first: Int
    offset: Int
  ): [TestSpecification]
  equipment(filter: EquipmentFilter): Equipment
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass
  materialClass(filter: MaterialClassFilter): MaterialClass
  operationsRequest(filter: OperationsRequestFilter): OperationsRequest
  jobOrder(filter: JobOrderFilter): JobOrder
  propertyOverrides(
    filter: EquipmentPropertyOverrideFilter
    order: EquipmentPropertyOverrideOrder
    first: Int
    offset: Int
  ): [EquipmentPropertyOverride]
  propertyNameAliases(
    filter: PropertyNameAliasFilter
    order: PropertyNameAliasOrder
    first: Int
    offset: Int
  ): [PropertyNameAlias]
  eventTriggers(
    filter: EventDefinitionFilter
    order: EventDefinitionOrder
    first: Int
    offset: Int
  ): [EventDefinition]
  eventPayloads(
    filter: EventDefinitionFilter
    order: EventDefinitionOrder
    first: Int
    offset: Int
  ): [EventDefinition]
  parameterSpecifications(
    filter: ParameterSpecificationFilter
    order: ParameterSpecificationOrder
    first: Int
    offset: Int
  ): [ParameterSpecification]
  isTestedByAggregate(
    filter: TestSpecificationFilter
  ): TestSpecificationAggregateResult
  propertyOverridesAggregate(
    filter: EquipmentPropertyOverrideFilter
  ): EquipmentPropertyOverrideAggregateResult
  propertyNameAliasesAggregate(
    filter: PropertyNameAliasFilter
  ): PropertyNameAliasAggregateResult
  eventTriggersAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
  eventPayloadsAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
  parameterSpecificationsAggregate(
    filter: ParameterSpecificationFilter
  ): ParameterSpecificationAggregateResult
}

type PropertyAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
  addressMin: String
  addressMax: String
  expressionMin: String
  expressionMax: String
  valueMin: String
  valueMax: String
}

input PropertyFilter {
  id: [ID!]
  isActive: Boolean
  type: PropertyType_hash
  name: StringHashFilter
  description: StringHashFilter
  has: [PropertyHasFilter]
  and: [PropertyFilter]
  or: [PropertyFilter]
  not: PropertyFilter
}

enum PropertyHasFilter {
  isActive
  type
  name
  description
  dataType
  definedBy
  address
  expression
  value
  unitOfMeasure
  storeHistory
  isTestedBy
  equipment
  equipmentClass
  materialClass
  operationsRequest
  jobOrder
  propertyOverrides
  propertyNameAliases
  eventTriggers
  eventPayloads
  parameterSpecifications
}

input PropertyListFilter {
  id: [ID!]
}

type PropertyNameAlias {
  id: ID!
  property(filter: PropertyFilter): Property!
  equipment(filter: EquipmentFilter): Equipment!
  alias: String!
  system: String!
}

type PropertyNameAliasAggregateResult {
  count: Int
  aliasMin: String
  aliasMax: String
  systemMin: String
  systemMax: String
}

input PropertyNameAliasFilter {
  id: [ID!]
  alias: StringFullTextFilter_StringHashFilter
  system: StringFullTextFilter_StringHashFilter
  has: [PropertyNameAliasHasFilter]
  and: [PropertyNameAliasFilter]
  or: [PropertyNameAliasFilter]
  not: PropertyNameAliasFilter
}

enum PropertyNameAliasHasFilter {
  property
  equipment
  alias
  system
}

input PropertyNameAliasOrder {
  asc: PropertyNameAliasOrderable
  desc: PropertyNameAliasOrderable
  then: PropertyNameAliasOrder
}

enum PropertyNameAliasOrderable {
  alias
  system
}

input PropertyNameAliasPatch {
  property: PropertyRef
  equipment: EquipmentRef
  alias: String
  system: String
}

input PropertyNameAliasRef {
  id: ID
  property: PropertyRef
  equipment: EquipmentRef
  alias: String
  system: String
}

input PropertyOrder {
  asc: PropertyOrderable
  desc: PropertyOrderable
  then: PropertyOrder
}

enum PropertyOrderable {
  name
  description
  address
  expression
  value
}

input PropertyPatch {
  isActive: Boolean
  type: PropertyType
  name: String
  description: String
  dataType: DataType
  definedBy: PropertyRef
  address: String
  expression: String
  value: String
  unitOfMeasure: UnitOfMeasureRef
  storeHistory: Boolean
  isTestedBy: [TestSpecificationRef]
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  materialClass: MaterialClassRef
  operationsRequest: OperationsRequestRef
  jobOrder: JobOrderRef
  propertyOverrides: [EquipmentPropertyOverrideRef]
  propertyNameAliases: [PropertyNameAliasRef]
  eventTriggers: [EventDefinitionRef]
  eventPayloads: [EventDefinitionRef]
  parameterSpecifications: [ParameterSpecificationRef]
}

input PropertyRef {
  id: ID
  isActive: Boolean
  type: PropertyType
  name: String
  description: String
  dataType: DataType
  definedBy: PropertyRef
  address: String
  expression: String
  value: String
  unitOfMeasure: UnitOfMeasureRef
  storeHistory: Boolean
  isTestedBy: [TestSpecificationRef]
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  materialClass: MaterialClassRef
  operationsRequest: OperationsRequestRef
  jobOrder: JobOrderRef
  propertyOverrides: [EquipmentPropertyOverrideRef]
  propertyNameAliases: [PropertyNameAliasRef]
  eventTriggers: [EventDefinitionRef]
  eventPayloads: [EventDefinitionRef]
  parameterSpecifications: [ParameterSpecificationRef]
}

enum PropertyType {
  BOUND
  CALCULATED
  REFERENCED
}

input PropertyType_hash {
  eq: PropertyType
  in: [PropertyType]
}

#  Columnar dataset for time-series property values
type PropertyValue {
  property: Property
  timestamp: DateTime
  value: String
}

type PropertyValueAlias {
  id: ID!
  property(filter: PropertyFilter): Property!
  value: String!
  alias: String!
  system: String!
}

type PropertyValueAliasAggregateResult {
  count: Int
  valueMin: String
  valueMax: String
  aliasMin: String
  aliasMax: String
  systemMin: String
  systemMax: String
}

input PropertyValueAliasFilter {
  id: [ID!]
  value: StringFullTextFilter
  alias: StringFullTextFilter
  system: StringFullTextFilter
  has: [PropertyValueAliasHasFilter]
  and: [PropertyValueAliasFilter]
  or: [PropertyValueAliasFilter]
  not: PropertyValueAliasFilter
}

enum PropertyValueAliasHasFilter {
  property
  value
  alias
  system
}

input PropertyValueAliasOrder {
  asc: PropertyValueAliasOrderable
  desc: PropertyValueAliasOrderable
  then: PropertyValueAliasOrder
}

enum PropertyValueAliasOrderable {
  value
  alias
  system
}

input PropertyValueAliasPatch {
  property: PropertyRef
  value: String
  alias: String
  system: String
}

input PropertyValueAliasRef {
  id: ID
  property: PropertyRef
  value: String
  alias: String
  system: String
}

#  filter the properties and time range to be returned
input PropertyValuesFilter {
  # returns all values between this timestamp and the timestamp specified by to.
  # If not specified, defaules to -24h from the current time
  from: DateTime

  # returns all events between this timestamp and the timestamp specified by from.
  # If not specified, this value defaults to the current time
  to: DateTime

  #  provide a list of property ids to return. Works as AND with propertyName filter.
  # if not specified, return all properties for the equipment.
  propertyId: [ID]

  #  filter by the property name. Works as AND with propertyId filter.
  # if not specified, return all properties for the equipment.
  propertyName: StringHashFilter
}

type QuantityLog {
  id: ID!
  isActive: Boolean
  jobResponse(filter: JobResponseFilter): JobResponse!
  equipment(filter: EquipmentFilter): Equipment
  type: MaterialUse!
  timestamp: DateTime
  quantity: Float!
  reasonCode: String
  reasonText: String
  comments: String
}

type QuantityLogAggregateResult {
  count: Int
  timestampMin: DateTime
  timestampMax: DateTime
  quantityMin: Float
  quantityMax: Float
  quantitySum: Float
  quantityAvg: Float
  reasonCodeMin: String
  reasonCodeMax: String
  reasonTextMin: String
  reasonTextMax: String
  commentsMin: String
  commentsMax: String
}

input QuantityLogFilter {
  id: [ID!]
  isActive: Boolean
  type: MaterialUse_hash
  timestamp: DateTimeFilter
  reasonCode: StringHashFilter
  reasonText: StringHashFilter
  comments: StringHashFilter
  has: [QuantityLogHasFilter]
  and: [QuantityLogFilter]
  or: [QuantityLogFilter]
  not: QuantityLogFilter
}

enum QuantityLogHasFilter {
  isActive
  jobResponse
  equipment
  type
  timestamp
  quantity
  reasonCode
  reasonText
  comments
}

input QuantityLogOrder {
  asc: QuantityLogOrderable
  desc: QuantityLogOrderable
  then: QuantityLogOrder
}

enum QuantityLogOrderable {
  timestamp
  quantity
  reasonCode
  reasonText
  comments
}

input QuantityLogPatch {
  isActive: Boolean
  jobResponse: JobResponseRef
  equipment: EquipmentRef
  type: MaterialUse
  timestamp: DateTime
  quantity: Float
  reasonCode: String
  reasonText: String
  comments: String
}

input QuantityLogRef {
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  equipment: EquipmentRef
  type: MaterialUse
  timestamp: DateTime
  quantity: Float
  reasonCode: String
  reasonText: String
  comments: String
}

type QuantityLogTs {
  equipment: Equipment
  timeStamp: DateTime
  material: MaterialDefinition
  materialUse: MaterialUse
  quantity: Float
  reasonText: String
  reasonCode: String
  comment: String
  plannedRunRate: Float
}

input QuantityLogTsInput {
  equipment: ExtEquipmentRef!
  timeStamp: DateTime!
  material: ExtMaterialDefinitionRef
  materialUse: MaterialUse!
  quantity: Float!
  reasonText: String
  reasonCode: String
  comment: String
}

# a summary of the quantity log
type QuantitySummary {
  # the type of quantity associated with the result
  type: String
  reasonCode: String
  reasonText: String

  # the sum of this type of quantity
  quantitySum: Float
}

# the filter for a quantitySummary query
input QuantitySummaryFilter {
  # limits the number of results that return
  topN: Int

  # groups the quantity logs on their reasons as well as their type if used.
  # valid options are 'reasonText' and 'reasonCode'
  groupBy: String

  # deprecated
  sortBy: String

  # returns only the type specified by filterType
  filterType: String
}

type Query {
  getAllEventsInTimeRange(filter: AllEventsInTimeRangeFilter!): [EventsByField]
  getUser(id: ID, username: String): User
  queryUser(
    filter: UserFilter
    order: UserOrder
    first: Int
    offset: Int
  ): [User]
  aggregateUser(filter: UserFilter): UserAggregateResult
  getUserRole(id: ID!): UserRole
  queryUserRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
  aggregateUserRole(filter: UserRoleFilter): UserRoleAggregateResult
  getRole(name: String!): Role
  queryRole(
    filter: RoleFilter
    order: RoleOrder
    first: Int
    offset: Int
  ): [Role]
  aggregateRole(filter: RoleFilter): RoleAggregateResult
  getAccessRight(id: ID!): AccessRight
  queryAccessRight(
    filter: AccessRightFilter
    first: Int
    offset: Int
  ): [AccessRight]
  aggregateAccessRight(filter: AccessRightFilter): AccessRightAggregateResult
  getACL(id: ID!): ACL
  queryACL(filter: ACLFilter, first: Int, offset: Int): [ACL]
  aggregateACL(filter: ACLFilter): ACLAggregateResult
  getLibreService(id: ID, name: String): LibreService
  queryLibreService(
    filter: LibreServiceFilter
    order: LibreServiceOrder
    first: Int
    offset: Int
  ): [LibreService]
  aggregateLibreService(filter: LibreServiceFilter): LibreServiceAggregateResult
  getMenu(id: ID!): Menu
  queryMenu(
    filter: MenuFilter
    order: MenuOrder
    first: Int
    offset: Int
  ): [Menu]
  aggregateMenu(filter: MenuFilter): MenuAggregateResult
  getOperationsRequest(id: ID, code: String): OperationsRequest
  queryOperationsRequest(
    filter: OperationsRequestFilter
    order: OperationsRequestOrder
    first: Int
    offset: Int
  ): [OperationsRequest]
  aggregateOperationsRequest(
    filter: OperationsRequestFilter
  ): OperationsRequestAggregateResult
  getRequestState(id: ID, name: String): RequestState
  queryRequestState(
    filter: RequestStateFilter
    order: RequestStateOrder
    first: Int
    offset: Int
  ): [RequestState]
  aggregateRequestState(filter: RequestStateFilter): RequestStateAggregateResult
  getOperationsDefinition(id: ID, name: String): OperationsDefinition
  queryOperationsDefinition(
    filter: OperationsDefinitionFilter
    order: OperationsDefinitionOrder
    first: Int
    offset: Int
  ): [OperationsDefinition]
  aggregateOperationsDefinition(
    filter: OperationsDefinitionFilter
  ): OperationsDefinitionAggregateResult
  getBillOfMaterial(id: ID, name: String): BillOfMaterial
  queryBillOfMaterial(
    filter: BillOfMaterialFilter
    order: BillOfMaterialOrder
    first: Int
    offset: Int
  ): [BillOfMaterial]
  aggregateBillOfMaterial(
    filter: BillOfMaterialFilter
  ): BillOfMaterialAggregateResult
  getOperationsSegment(id: ID!): OperationsSegment
  queryOperationsSegment(
    filter: OperationsSegmentFilter
    order: OperationsSegmentOrder
    first: Int
    offset: Int
  ): [OperationsSegment]
  aggregateOperationsSegment(
    filter: OperationsSegmentFilter
  ): OperationsSegmentAggregateResult
  getTransitionEventRuleset(id: ID!): TransitionEventRuleset
  queryTransitionEventRuleset(
    filter: TransitionEventRulesetFilter
    order: TransitionEventRulesetOrder
    first: Int
    offset: Int
  ): [TransitionEventRuleset]
  aggregateTransitionEventRuleset(
    filter: TransitionEventRulesetFilter
  ): TransitionEventRulesetAggregateResult
  getStateEventRuleset(id: ID!): StateEventRuleset
  queryStateEventRuleset(
    filter: StateEventRulesetFilter
    order: StateEventRulesetOrder
    first: Int
    offset: Int
  ): [StateEventRuleset]
  aggregateStateEventRuleset(
    filter: StateEventRulesetFilter
  ): StateEventRulesetAggregateResult
  getMaterialEventRuleset(id: ID!): MaterialEventRuleset
  queryMaterialEventRuleset(
    filter: MaterialEventRulesetFilter
    order: MaterialEventRulesetOrder
    first: Int
    offset: Int
  ): [MaterialEventRuleset]
  aggregateMaterialEventRuleset(
    filter: MaterialEventRulesetFilter
  ): MaterialEventRulesetAggregateResult
  getOrderStartRuleset(id: ID!): OrderStartRuleset
  queryOrderStartRuleset(
    filter: OrderStartRulesetFilter
    order: OrderStartRulesetOrder
    first: Int
    offset: Int
  ): [OrderStartRuleset]
  aggregateOrderStartRuleset(
    filter: OrderStartRulesetFilter
  ): OrderStartRulesetAggregateResult
  getSegmentInvoiceSetting(id: ID!): SegmentInvoiceSetting
  querySegmentInvoiceSetting(
    filter: SegmentInvoiceSettingFilter
    order: SegmentInvoiceSettingOrder
    first: Int
    offset: Int
  ): [SegmentInvoiceSetting]
  aggregateSegmentInvoiceSetting(
    filter: SegmentInvoiceSettingFilter
  ): SegmentInvoiceSettingAggregateResult
  getSegmentDependency(id: ID!): SegmentDependency
  querySegmentDependency(
    filter: SegmentDependencyFilter
    order: SegmentDependencyOrder
    first: Int
    offset: Int
  ): [SegmentDependency]
  aggregateSegmentDependency(
    filter: SegmentDependencyFilter
  ): SegmentDependencyAggregateResult
  getJobOrder(id: ID, name: String): JobOrder
  queryJobOrder(
    filter: JobOrderFilter
    order: JobOrderOrder
    first: Int
    offset: Int
  ): [JobOrder]
  aggregateJobOrder(filter: JobOrderFilter): JobOrderAggregateResult
  getJobOrderDependency(id: ID!): JobOrderDependency
  queryJobOrderDependency(
    filter: JobOrderDependencyFilter
    order: JobOrderDependencyOrder
    first: Int
    offset: Int
  ): [JobOrderDependency]
  aggregateJobOrderDependency(
    filter: JobOrderDependencyFilter
  ): JobOrderDependencyAggregateResult
  queryJobOrderDispatchStateModel(
    filter: JobOrderDispatchStateModelFilter
    first: Int
    offset: Int
  ): [JobOrderDispatchStateModel]
  aggregateJobOrderDispatchStateModel(
    filter: JobOrderDispatchStateModelFilter
  ): JobOrderDispatchStateModelAggregateResult
  getJobOrderNote(id: ID!): JobOrderNote
  queryJobOrderNote(
    filter: JobOrderNoteFilter
    order: JobOrderNoteOrder
    first: Int
    offset: Int
  ): [JobOrderNote]
  aggregateJobOrderNote(filter: JobOrderNoteFilter): JobOrderNoteAggregateResult
  getJobResponse(id: ID!): JobResponse
  queryJobResponse(
    filter: JobResponseFilter
    order: JobResponseOrder
    first: Int
    offset: Int
  ): [JobResponse]
  aggregateJobResponse(filter: JobResponseFilter): JobResponseAggregateResult
  getPersonnelActual(id: ID!): PersonnelActual
  queryPersonnelActual(
    filter: PersonnelActualFilter
    order: PersonnelActualOrder
    first: Int
    offset: Int
  ): [PersonnelActual]
  aggregatePersonnelActual(
    filter: PersonnelActualFilter
  ): PersonnelActualAggregateResult
  getEquipmentActual(id: ID!): EquipmentActual
  queryEquipmentActual(
    filter: EquipmentActualFilter
    order: EquipmentActualOrder
    first: Int
    offset: Int
  ): [EquipmentActual]
  aggregateEquipmentActual(
    filter: EquipmentActualFilter
  ): EquipmentActualAggregateResult
  getMaterialActual(id: ID!): MaterialActual
  queryMaterialActual(
    filter: MaterialActualFilter
    order: MaterialActualOrder
    first: Int
    offset: Int
  ): [MaterialActual]
  aggregateMaterialActual(
    filter: MaterialActualFilter
  ): MaterialActualAggregateResult
  getEventLog(id: ID!): EventLog
  queryEventLog(
    filter: EventLogFilter
    order: EventLogOrder
    first: Int
    offset: Int
  ): [EventLog]
  aggregateEventLog(filter: EventLogFilter): EventLogAggregateResult
  getQuantityLog(id: ID!): QuantityLog
  queryQuantityLog(
    filter: QuantityLogFilter
    order: QuantityLogOrder
    first: Int
    offset: Int
  ): [QuantityLog]
  aggregateQuantityLog(filter: QuantityLogFilter): QuantityLogAggregateResult
  getEquipmentSpecification(id: ID!): EquipmentSpecification
  queryEquipmentSpecification(
    filter: EquipmentSpecificationFilter
    order: EquipmentSpecificationOrder
    first: Int
    offset: Int
  ): [EquipmentSpecification]
  aggregateEquipmentSpecification(
    filter: EquipmentSpecificationFilter
  ): EquipmentSpecificationAggregateResult
  getMaterialSpecification(id: ID!): MaterialSpecification
  queryMaterialSpecification(
    filter: MaterialSpecificationFilter
    order: MaterialSpecificationOrder
    first: Int
    offset: Int
  ): [MaterialSpecification]
  aggregateMaterialSpecification(
    filter: MaterialSpecificationFilter
  ): MaterialSpecificationAggregateResult
  getPersonnelSpecification(id: ID!): PersonnelSpecification
  queryPersonnelSpecification(
    filter: PersonnelSpecificationFilter
    order: PersonnelSpecificationOrder
    first: Int
    offset: Int
  ): [PersonnelSpecification]
  aggregatePersonnelSpecification(
    filter: PersonnelSpecificationFilter
  ): PersonnelSpecificationAggregateResult
  getParameterSpecification(id: ID!): ParameterSpecification
  queryParameterSpecification(
    filter: ParameterSpecificationFilter
    order: ParameterSpecificationOrder
    first: Int
    offset: Int
  ): [ParameterSpecification]
  aggregateParameterSpecification(
    filter: ParameterSpecificationFilter
  ): ParameterSpecificationAggregateResult
  getDashboardConfig(id: ID, name: String): DashboardConfig
  queryDashboardConfig(
    filter: DashboardConfigFilter
    order: DashboardConfigOrder
    first: Int
    offset: Int
  ): [DashboardConfig]
  aggregateDashboardConfig(
    filter: DashboardConfigFilter
  ): DashboardConfigAggregateResult
  getDashboardPanelConfig(id: ID!): DashboardPanelConfig
  queryDashboardPanelConfig(
    filter: DashboardPanelConfigFilter
    order: DashboardPanelConfigOrder
    first: Int
    offset: Int
  ): [DashboardPanelConfig]
  aggregateDashboardPanelConfig(
    filter: DashboardPanelConfigFilter
  ): DashboardPanelConfigAggregateResult
  getDashboardWidgetConfigProperty(id: ID!): DashboardWidgetConfigProperty
  queryDashboardWidgetConfigProperty(
    filter: DashboardWidgetConfigPropertyFilter
    order: DashboardWidgetConfigPropertyOrder
    first: Int
    offset: Int
  ): [DashboardWidgetConfigProperty]
  aggregateDashboardWidgetConfigProperty(
    filter: DashboardWidgetConfigPropertyFilter
  ): DashboardWidgetConfigPropertyAggregateResult
  getEquipment(id: ID!): Equipment
  queryEquipment(
    filter: EquipmentFilter
    order: EquipmentOrder
    first: Int
    offset: Int
  ): [Equipment]
  aggregateEquipment(filter: EquipmentFilter): EquipmentAggregateResult
  getEquipmentRelation(id: ID!): EquipmentRelation
  queryEquipmentRelation(
    filter: EquipmentRelationFilter
    first: Int
    offset: Int
  ): [EquipmentRelation]
  aggregateEquipmentRelation(
    filter: EquipmentRelationFilter
  ): EquipmentRelationAggregateResult
  getEquipmentNameAlias(id: ID!): EquipmentNameAlias
  queryEquipmentNameAlias(
    filter: EquipmentNameAliasFilter
    order: EquipmentNameAliasOrder
    first: Int
    offset: Int
  ): [EquipmentNameAlias]
  aggregateEquipmentNameAlias(
    filter: EquipmentNameAliasFilter
  ): EquipmentNameAliasAggregateResult
  getPropertyNameAlias(id: ID!): PropertyNameAlias
  queryPropertyNameAlias(
    filter: PropertyNameAliasFilter
    order: PropertyNameAliasOrder
    first: Int
    offset: Int
  ): [PropertyNameAlias]
  aggregatePropertyNameAlias(
    filter: PropertyNameAliasFilter
  ): PropertyNameAliasAggregateResult
  getPropertyValueAlias(id: ID!): PropertyValueAlias
  queryPropertyValueAlias(
    filter: PropertyValueAliasFilter
    order: PropertyValueAliasOrder
    first: Int
    offset: Int
  ): [PropertyValueAlias]
  aggregatePropertyValueAlias(
    filter: PropertyValueAliasFilter
  ): PropertyValueAliasAggregateResult
  getEquipmentReasonOverride(id: ID!): EquipmentReasonOverride
  queryEquipmentReasonOverride(
    filter: EquipmentReasonOverrideFilter
    order: EquipmentReasonOverrideOrder
    first: Int
    offset: Int
  ): [EquipmentReasonOverride]
  aggregateEquipmentReasonOverride(
    filter: EquipmentReasonOverrideFilter
  ): EquipmentReasonOverrideAggregateResult
  getEquipmentClass(id: ID!): EquipmentClass
  queryEquipmentClass(
    filter: EquipmentClassFilter
    order: EquipmentClassOrder
    first: Int
    offset: Int
  ): [EquipmentClass]
  aggregateEquipmentClass(
    filter: EquipmentClassFilter
  ): EquipmentClassAggregateResult
  getProperty(id: ID!): Property
  queryProperty(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  aggregateProperty(filter: PropertyFilter): PropertyAggregateResult
  getEquipmentPropertyOverride(id: ID!): EquipmentPropertyOverride
  queryEquipmentPropertyOverride(
    filter: EquipmentPropertyOverrideFilter
    order: EquipmentPropertyOverrideOrder
    first: Int
    offset: Int
  ): [EquipmentPropertyOverride]
  aggregateEquipmentPropertyOverride(
    filter: EquipmentPropertyOverrideFilter
  ): EquipmentPropertyOverrideAggregateResult
  getEventDefinition(id: ID!): EventDefinition
  queryEventDefinition(
    filter: EventDefinitionFilter
    order: EventDefinitionOrder
    first: Int
    offset: Int
  ): [EventDefinition]
  aggregateEventDefinition(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
  getPayloadFieldDefinition(id: ID!): PayloadFieldDefinition
  queryPayloadFieldDefinition(
    filter: PayloadFieldDefinitionFilter
    order: PayloadFieldDefinitionOrder
    first: Int
    offset: Int
  ): [PayloadFieldDefinition]
  aggregatePayloadFieldDefinition(
    filter: PayloadFieldDefinitionFilter
  ): PayloadFieldDefinitionAggregateResult
  getReason(id: ID!): Reason
  queryReason(
    filter: ReasonFilter
    order: ReasonOrder
    first: Int
    offset: Int
  ): [Reason]
  aggregateReason(filter: ReasonFilter): ReasonAggregateResult
  getReasonCategory(id: ID, code: String): ReasonCategory
  queryReasonCategory(
    filter: ReasonCategoryFilter
    order: ReasonCategoryOrder
    first: Int
    offset: Int
  ): [ReasonCategory]
  aggregateReasonCategory(
    filter: ReasonCategoryFilter
  ): ReasonCategoryAggregateResult
  getMaterialClass(id: ID, code: String): MaterialClass
  queryMaterialClass(
    filter: MaterialClassFilter
    order: MaterialClassOrder
    first: Int
    offset: Int
  ): [MaterialClass]
  aggregateMaterialClass(
    filter: MaterialClassFilter
  ): MaterialClassAggregateResult
  getMaterialDefinition(id: ID, code: String): MaterialDefinition
  queryMaterialDefinition(
    filter: MaterialDefinitionFilter
    order: MaterialDefinitionOrder
    first: Int
    offset: Int
  ): [MaterialDefinition]
  aggregateMaterialDefinition(
    filter: MaterialDefinitionFilter
  ): MaterialDefinitionAggregateResult
  getMaterialAlternate(id: ID!): MaterialAlternate
  queryMaterialAlternate(
    filter: MaterialAlternateFilter
    order: MaterialAlternateOrder
    first: Int
    offset: Int
  ): [MaterialAlternate]
  aggregateMaterialAlternate(
    filter: MaterialAlternateFilter
  ): MaterialAlternateAggregateResult
  getCarrier(id: ID, code: String): Carrier
  queryCarrier(
    filter: CarrierFilter
    order: CarrierOrder
    first: Int
    offset: Int
  ): [Carrier]
  aggregateCarrier(filter: CarrierFilter): CarrierAggregateResult
  getMaterialLot(id: ID, code: String): MaterialLot
  queryMaterialLot(
    filter: MaterialLotFilter
    order: MaterialLotOrder
    first: Int
    offset: Int
  ): [MaterialLot]
  aggregateMaterialLot(filter: MaterialLotFilter): MaterialLotAggregateResult
  getMaterialSubLot(id: ID, code: String): MaterialSubLot
  queryMaterialSubLot(
    filter: MaterialSubLotFilter
    order: MaterialSubLotOrder
    first: Int
    offset: Int
  ): [MaterialSubLot]
  aggregateMaterialSubLot(
    filter: MaterialSubLotFilter
  ): MaterialSubLotAggregateResult
  getMaterialUnit(id: ID, serialNumber: String): MaterialUnit
  queryMaterialUnit(
    filter: MaterialUnitFilter
    order: MaterialUnitOrder
    first: Int
    offset: Int
  ): [MaterialUnit]
  aggregateMaterialUnit(filter: MaterialUnitFilter): MaterialUnitAggregateResult
  getInventoryHoldingPolicy(id: ID!): InventoryHoldingPolicy
  queryInventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    order: InventoryHoldingPolicyOrder
    first: Int
    offset: Int
  ): [InventoryHoldingPolicy]
  aggregateInventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
  ): InventoryHoldingPolicyAggregateResult
  getUnitOfMeasure(id: ID, code: String): UnitOfMeasure
  queryUnitOfMeasure(
    filter: UnitOfMeasureFilter
    order: UnitOfMeasureOrder
    first: Int
    offset: Int
  ): [UnitOfMeasure]
  aggregateUnitOfMeasure(
    filter: UnitOfMeasureFilter
  ): UnitOfMeasureAggregateResult
  getUnitOfMeasureConversion(id: ID!): UnitOfMeasureConversion
  queryUnitOfMeasureConversion(
    filter: UnitOfMeasureConversionFilter
    order: UnitOfMeasureConversionOrder
    first: Int
    offset: Int
  ): [UnitOfMeasureConversion]
  aggregateUnitOfMeasureConversion(
    filter: UnitOfMeasureConversionFilter
  ): UnitOfMeasureConversionAggregateResult
  getMaterialStatus(id: ID, code: String): MaterialStatus
  queryMaterialStatus(
    filter: MaterialStatusFilter
    order: MaterialStatusOrder
    first: Int
    offset: Int
  ): [MaterialStatus]
  aggregateMaterialStatus(
    filter: MaterialStatusFilter
  ): MaterialStatusAggregateResult
  getMaterialStateModel(id: ID, name: String): MaterialStateModel
  queryMaterialStateModel(
    filter: MaterialStateModelFilter
    order: MaterialStateModelOrder
    first: Int
    offset: Int
  ): [MaterialStateModel]
  aggregateMaterialStateModel(
    filter: MaterialStateModelFilter
  ): MaterialStateModelAggregateResult
  getMaterialStateTransition(id: ID!): MaterialStateTransition
  queryMaterialStateTransition(
    filter: MaterialStateTransitionFilter
    first: Int
    offset: Int
  ): [MaterialStateTransition]
  aggregateMaterialStateTransition(
    filter: MaterialStateTransitionFilter
  ): MaterialStateTransitionAggregateResult
  getPersonnelClass(id: ID, name: String): PersonnelClass
  queryPersonnelClass(
    filter: PersonnelClassFilter
    order: PersonnelClassOrder
    first: Int
    offset: Int
  ): [PersonnelClass]
  aggregatePersonnelClass(
    filter: PersonnelClassFilter
  ): PersonnelClassAggregateResult
  getPerson(id: ID, name: String): Person
  queryPerson(
    filter: PersonFilter
    order: PersonOrder
    first: Int
    offset: Int
  ): [Person]
  aggregatePerson(filter: PersonFilter): PersonAggregateResult
  getTestSpecification(id: ID!): TestSpecification
  queryTestSpecification(
    filter: TestSpecificationFilter
    order: TestSpecificationOrder
    first: Int
    offset: Int
  ): [TestSpecification]
  aggregateTestSpecification(
    filter: TestSpecificationFilter
  ): TestSpecificationAggregateResult
  getTestResult(id: ID!): TestResult
  queryTestResult(
    filter: TestResultFilter
    order: TestResultOrder
    first: Int
    offset: Int
  ): [TestResult]
  aggregateTestResult(filter: TestResultFilter): TestResultAggregateResult
  getWorkCalendarDefinitionEntry(id: ID!): WorkCalendarDefinitionEntry
  queryWorkCalendarDefinitionEntry(
    filter: WorkCalendarDefinitionEntryFilter
    order: WorkCalendarDefinitionEntryOrder
    first: Int
    offset: Int
  ): [WorkCalendarDefinitionEntry]
  aggregateWorkCalendarDefinitionEntry(
    filter: WorkCalendarDefinitionEntryFilter
  ): WorkCalendarDefinitionEntryAggregateResult
  getWorkCalendarEntry(id: ID!): WorkCalendarEntry
  queryWorkCalendarEntry(
    filter: WorkCalendarEntryFilter
    order: WorkCalendarEntryOrder
    first: Int
    offset: Int
  ): [WorkCalendarEntry]
  aggregateWorkCalendarEntry(
    filter: WorkCalendarEntryFilter
  ): WorkCalendarEntryAggregateResult
  getWorkCalendar(id: ID, name: String): WorkCalendar
  queryWorkCalendar(
    filter: WorkCalendarFilter
    order: WorkCalendarOrder
    first: Int
    offset: Int
  ): [WorkCalendar]
  aggregateWorkCalendar(filter: WorkCalendarFilter): WorkCalendarAggregateResult
  getWorkflowSpecification(id: ID!): WorkflowSpecification
  queryWorkflowSpecification(
    filter: WorkflowSpecificationFilter
    order: WorkflowSpecificationOrder
    first: Int
    offset: Int
  ): [WorkflowSpecification]
  aggregateWorkflowSpecification(
    filter: WorkflowSpecificationFilter
  ): WorkflowSpecificationAggregateResult
  getWorkflowInstance(id: ID!): WorkflowInstance
  queryWorkflowInstance(
    filter: WorkflowInstanceFilter
    order: WorkflowInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowInstance]
  aggregateWorkflowInstance(
    filter: WorkflowInstanceFilter
  ): WorkflowInstanceAggregateResult
  getWorkflowInstanceProperty(id: ID, key: String): WorkflowInstanceProperty
  queryWorkflowInstanceProperty(
    filter: WorkflowInstancePropertyFilter
    order: WorkflowInstancePropertyOrder
    first: Int
    offset: Int
  ): [WorkflowInstanceProperty]
  aggregateWorkflowInstanceProperty(
    filter: WorkflowInstancePropertyFilter
  ): WorkflowInstancePropertyAggregateResult
  getWorkflowNode(id: ID!): WorkflowNode
  queryWorkflowNode(
    filter: WorkflowNodeFilter
    order: WorkflowNodeOrder
    first: Int
    offset: Int
  ): [WorkflowNode]
  aggregateWorkflowNode(filter: WorkflowNodeFilter): WorkflowNodeAggregateResult
  getWorkflowNodeInstance(id: ID!): WorkflowNodeInstance
  queryWorkflowNodeInstance(
    filter: WorkflowNodeInstanceFilter
    order: WorkflowNodeInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowNodeInstance]
  aggregateWorkflowNodeInstance(
    filter: WorkflowNodeInstanceFilter
  ): WorkflowNodeInstanceAggregateResult
  getWorkflowNodeEvent(id: ID!): WorkflowNodeEvent
  queryWorkflowNodeEvent(
    filter: WorkflowNodeEventFilter
    order: WorkflowNodeEventOrder
    first: Int
    offset: Int
  ): [WorkflowNodeEvent]
  aggregateWorkflowNodeEvent(
    filter: WorkflowNodeEventFilter
  ): WorkflowNodeEventAggregateResult
  getWorkflowNodeType(id: ID!): WorkflowNodeType
  queryWorkflowNodeType(
    filter: WorkflowNodeTypeFilter
    order: WorkflowNodeTypeOrder
    first: Int
    offset: Int
  ): [WorkflowNodeType]
  aggregateWorkflowNodeType(
    filter: WorkflowNodeTypeFilter
  ): WorkflowNodeTypeAggregateResult
  getWorkflowConnection(id: ID!): WorkflowConnection
  queryWorkflowConnection(
    filter: WorkflowConnectionFilter
    order: WorkflowConnectionOrder
    first: Int
    offset: Int
  ): [WorkflowConnection]
  aggregateWorkflowConnection(
    filter: WorkflowConnectionFilter
  ): WorkflowConnectionAggregateResult
  getWorkflowConnectionType(id: ID!): WorkflowConnectionType
  queryWorkflowConnectionType(
    filter: WorkflowConnectionTypeFilter
    order: WorkflowConnectionTypeOrder
    first: Int
    offset: Int
  ): [WorkflowConnectionType]
  aggregateWorkflowConnectionType(
    filter: WorkflowConnectionTypeFilter
  ): WorkflowConnectionTypeAggregateResult
  getWorkflowProperty(id: ID!): WorkflowProperty
  queryWorkflowProperty(
    filter: WorkflowPropertyFilter
    order: WorkflowPropertyOrder
    first: Int
    offset: Int
  ): [WorkflowProperty]
  aggregateWorkflowProperty(
    filter: WorkflowPropertyFilter
  ): WorkflowPropertyAggregateResult
  getWorkflowPropertyInstance(id: ID!): WorkflowPropertyInstance
  queryWorkflowPropertyInstance(
    filter: WorkflowPropertyInstanceFilter
    order: WorkflowPropertyInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowPropertyInstance]
  aggregateWorkflowPropertyInstance(
    filter: WorkflowPropertyInstanceFilter
  ): WorkflowPropertyInstanceAggregateResult
  getWorkflowPropertyValue(id: ID!): WorkflowPropertyValue
  queryWorkflowPropertyValue(
    filter: WorkflowPropertyValueFilter
    order: WorkflowPropertyValueOrder
    first: Int
    offset: Int
  ): [WorkflowPropertyValue]
  aggregateWorkflowPropertyValue(
    filter: WorkflowPropertyValueFilter
  ): WorkflowPropertyValueAggregateResult
  getForm(id: ID, name: String): Form
  queryForm(
    filter: FormFilter
    order: FormOrder
    first: Int
    offset: Int
  ): [Form]
  aggregateForm(filter: FormFilter): FormAggregateResult
  getPartner(id: ID!): Partner
  queryPartner(
    filter: PartnerFilter
    order: PartnerOrder
    first: Int
    offset: Int
  ): [Partner]
  aggregatePartner(filter: PartnerFilter): PartnerAggregateResult
  getShippingAccount(id: ID!): ShippingAccount
  queryShippingAccount(
    filter: ShippingAccountFilter
    order: ShippingAccountOrder
    first: Int
    offset: Int
  ): [ShippingAccount]
  aggregateShippingAccount(
    filter: ShippingAccountFilter
  ): ShippingAccountAggregateResult
  getInventoryHandlingPolicy(id: ID, name: String): InventoryHandlingPolicy
  queryInventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
    order: InventoryHandlingPolicyOrder
    first: Int
    offset: Int
  ): [InventoryHandlingPolicy]
  aggregateInventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
  ): InventoryHandlingPolicyAggregateResult
  getInventoryHandlingRule(id: ID!): InventoryHandlingRule
  queryInventoryHandlingRule(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  aggregateInventoryHandlingRule(
    filter: InventoryHandlingRuleFilter
  ): InventoryHandlingRuleAggregateResult
  getAddress(id: ID!): Address
  queryAddress(
    filter: AddressFilter
    order: AddressOrder
    first: Int
    offset: Int
  ): [Address]
  aggregateAddress(filter: AddressFilter): AddressAggregateResult
  getDelivery(id: ID!): Delivery
  queryDelivery(
    filter: DeliveryFilter
    order: DeliveryOrder
    first: Int
    offset: Int
  ): [Delivery]
  aggregateDelivery(filter: DeliveryFilter): DeliveryAggregateResult
  getOrder(id: ID!): Order
  queryOrder(
    filter: OrderFilter
    order: OrderOrder
    first: Int
    offset: Int
  ): [Order]
  aggregateOrder(filter: OrderFilter): OrderAggregateResult
  getOrderLine(id: ID!): OrderLine
  queryOrderLine(
    filter: OrderLineFilter
    order: OrderLineOrder
    first: Int
    offset: Int
  ): [OrderLine]
  aggregateOrderLine(filter: OrderLineFilter): OrderLineAggregateResult
  getShipment(id: ID!): Shipment
  queryShipment(
    filter: ShipmentFilter
    order: ShipmentOrder
    first: Int
    offset: Int
  ): [Shipment]
  aggregateShipment(filter: ShipmentFilter): ShipmentAggregateResult
  getShipmentItem(id: ID!): ShipmentItem
  queryShipmentItem(
    filter: ShipmentItemFilter
    order: ShipmentItemOrder
    first: Int
    offset: Int
  ): [ShipmentItem]
  aggregateShipmentItem(filter: ShipmentItemFilter): ShipmentItemAggregateResult
  getBox(id: ID!): Box
  queryBox(filter: BoxFilter, order: BoxOrder, first: Int, offset: Int): [Box]
  aggregateBox(filter: BoxFilter): BoxAggregateResult
  getGeneralLedgerAccount(id: ID, code: String): GeneralLedgerAccount
  queryGeneralLedgerAccount(
    filter: GeneralLedgerAccountFilter
    order: GeneralLedgerAccountOrder
    first: Int
    offset: Int
  ): [GeneralLedgerAccount]
  aggregateGeneralLedgerAccount(
    filter: GeneralLedgerAccountFilter
  ): GeneralLedgerAccountAggregateResult
  getInterfaceMessageLog(id: ID!): InterfaceMessageLog
  queryInterfaceMessageLog(
    filter: InterfaceMessageLogFilter
    order: InterfaceMessageLogOrder
    first: Int
    offset: Int
  ): [InterfaceMessageLog]
  aggregateInterfaceMessageLog(
    filter: InterfaceMessageLogFilter
  ): InterfaceMessageLogAggregateResult
  getInventoryTransactionsRaw(
    filter: InventoryTransactionsRawFilter
  ): [InventoryTransaction]
  getStockOnHand(filter: StockOnHandFilter): [InventoryTransaction]
  validateASN(input: ValidateASNInput!): [ASNStaging]
  queryMaterialEquipment(filter: MaterialEquipmentFilter): [MaterialEquipment]
  queryPlanningSummaryByStateByEquipment(
    filter: PlanningSummaryFilter!
  ): [[MaterialEquipmentState]]
  getPackingSlipPDF: String
  getPackingReturnInstructionsPDF(
    input: GetPackingReturnInstructionsPDFInput!
  ): String
  getDeliveryOrder(
    delivery: ExtDeliveryRef!
    shippingAccountData: ShippingAccountData!
  ): TransportCompanyDeliveryOrder
}

type RawKpi {
  actualProductionTimeSeconds: Int
  quantities: [QuantityLogTs]
}

type Reason {
  id: ID!
  isActive: Boolean
  class: ReasonClass!
  category(filter: ReasonCategoryFilter): ReasonCategory
  label: String!
  text: String!
  erpCode: String!
  standardValue: Float
  valueUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  parent(filter: ReasonFilter): Reason
  children(
    filter: ReasonFilter
    order: ReasonOrder
    first: Int
    offset: Int
  ): [Reason]
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass
  equipment(filter: EquipmentFilter): Equipment
  equipmentOverrides(
    filter: EquipmentReasonOverrideFilter
    order: EquipmentReasonOverrideOrder
    first: Int
    offset: Int
  ): [EquipmentReasonOverride]
  childrenAggregate(filter: ReasonFilter): ReasonAggregateResult
  equipmentOverridesAggregate(
    filter: EquipmentReasonOverrideFilter
  ): EquipmentReasonOverrideAggregateResult
}

type ReasonAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
  textMin: String
  textMax: String
  erpCodeMin: String
  erpCodeMax: String
  standardValueMin: Float
  standardValueMax: Float
  standardValueSum: Float
  standardValueAvg: Float
}

type ReasonCategory {
  id: ID!
  isActive: Boolean
  reason(
    filter: ReasonFilter
    order: ReasonOrder
    first: Int
    offset: Int
  ): [Reason]
  code: String!
  timeCategory: TimeCategory!
  reasonAggregate(filter: ReasonFilter): ReasonAggregateResult
}

type ReasonCategoryAggregateResult {
  count: Int
  codeMin: String
  codeMax: String
}

input ReasonCategoryFilter {
  id: [ID!]
  isActive: Boolean
  code: StringHashFilter
  has: [ReasonCategoryHasFilter]
  and: [ReasonCategoryFilter]
  or: [ReasonCategoryFilter]
  not: ReasonCategoryFilter
}

enum ReasonCategoryHasFilter {
  isActive
  reason
  code
  timeCategory
}

input ReasonCategoryOrder {
  asc: ReasonCategoryOrderable
  desc: ReasonCategoryOrderable
  then: ReasonCategoryOrder
}

enum ReasonCategoryOrderable {
  code
}

input ReasonCategoryPatch {
  isActive: Boolean
  reason: [ReasonRef]
  timeCategory: TimeCategory
}

input ReasonCategoryRef {
  id: ID
  isActive: Boolean
  reason: [ReasonRef]
  code: String
  timeCategory: TimeCategory
}

enum ReasonClass {
  Time
  Scrap
}

input ReasonClass_hash {
  eq: ReasonClass
  in: [ReasonClass]
}

input ReasonFilter {
  id: [ID!]
  isActive: Boolean
  class: ReasonClass_hash
  label: StringHashFilter
  text: StringHashFilter
  erpCode: StringHashFilter
  has: [ReasonHasFilter]
  and: [ReasonFilter]
  or: [ReasonFilter]
  not: ReasonFilter
}

enum ReasonHasFilter {
  isActive
  class
  category
  label
  text
  erpCode
  standardValue
  valueUoM
  parent
  children
  equipmentClass
  equipment
  equipmentOverrides
}

input ReasonOrder {
  asc: ReasonOrderable
  desc: ReasonOrderable
  then: ReasonOrder
}

enum ReasonOrderable {
  label
  text
  erpCode
  standardValue
}

input ReasonPatch {
  isActive: Boolean
  class: ReasonClass
  category: ReasonCategoryRef
  label: String
  text: String
  erpCode: String
  standardValue: Float
  valueUoM: UnitOfMeasureRef
  parent: ReasonRef
  children: [ReasonRef]
  equipmentClass: EquipmentClassRef
  equipment: EquipmentRef
  equipmentOverrides: [EquipmentReasonOverrideRef]
}

input ReasonRef {
  id: ID
  isActive: Boolean
  class: ReasonClass
  category: ReasonCategoryRef
  label: String
  text: String
  erpCode: String
  standardValue: Float
  valueUoM: UnitOfMeasureRef
  parent: ReasonRef
  children: [ReasonRef]
  equipmentClass: EquipmentClassRef
  equipment: EquipmentRef
  equipmentOverrides: [EquipmentReasonOverrideRef]
}

input ReceiveInboundShipmentInput {
  orderNumber: String
  materialCode: String
  inboundQuantity: Int
  warehouse: String
  sohQty: Int
  min: Int
  max: Int
  status: String
  plannedQuantity: Int!
}

input ReplayRawDataInput {
  equipment: [String!]!
  fromDateTIme: String!
}

type RequestState {
  id: ID!
  isActive: Boolean
  name: String!
  description: String
}

type RequestStateAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
}

input RequestStateFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  has: [RequestStateHasFilter]
  and: [RequestStateFilter]
  or: [RequestStateFilter]
  not: RequestStateFilter
}

enum RequestStateHasFilter {
  isActive
  name
  description
}

input RequestStateOrder {
  asc: RequestStateOrderable
  desc: RequestStateOrderable
  then: RequestStateOrder
}

enum RequestStateOrderable {
  name
  description
}

input RequestStatePatch {
  isActive: Boolean
  description: String
}

input RequestStateRef {
  id: ID
  isActive: Boolean
  name: String
  description: String
}

type Role {
  name: String!
  hasMembers(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
  hasGrantedRights(
    filter: AccessRightFilter
    first: Int
    offset: Int
  ): [AccessRight]
  isActive: Boolean
  workflowNodes(
    filter: WorkflowNodeFilter
    order: WorkflowNodeOrder
    first: Int
    offset: Int
  ): [WorkflowNode]
  hasMembersAggregate(filter: UserRoleFilter): UserRoleAggregateResult
  hasGrantedRightsAggregate(
    filter: AccessRightFilter
  ): AccessRightAggregateResult
  workflowNodesAggregate(
    filter: WorkflowNodeFilter
  ): WorkflowNodeAggregateResult
}

type RoleAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input RoleFilter {
  name: StringHashFilter
  has: [RoleHasFilter]
  and: [RoleFilter]
  or: [RoleFilter]
  not: RoleFilter
}

enum RoleHasFilter {
  name
  hasMembers
  hasGrantedRights
  isActive
  workflowNodes
}

input RoleOrder {
  asc: RoleOrderable
  desc: RoleOrderable
  then: RoleOrder
}

enum RoleOrderable {
  name
}

input RolePatch {
  hasMembers: [UserRoleRef]
  hasGrantedRights: [AccessRightRef]
  isActive: Boolean
  workflowNodes: [WorkflowNodeRef]
}

input RoleRef {
  name: String
  hasMembers: [UserRoleRef]
  hasGrantedRights: [AccessRightRef]
  isActive: Boolean
  workflowNodes: [WorkflowNodeRef]
}

enum RulesetTriggerOption {
  ORDER_START
  ORDER_END
}

# represents a rate at a timestamp
type RunRate {
  time: DateTime
  rate: Float
}

# the filter required to return the requiredRunRate type
input RunRateFilter {
  # the run rate required over the total course of the job response to meet the quantity target
  TargetRunRate: Float

  # the scheduled finish of the job response
  ScheduledFinish: DateTime
}

# a summary of the run rate log
type RunRateSummary {
  # the run rate at the time of query
  currentRunRate: Float

  # the average run rate over the course of the job response queried from
  avgRunRate: Float

  # the run rate required to reach the job orders target before the scheduled end time.
  # requires both targetRunRate and scheduledFinish to be passed through the filter
  requiredRunRate: Float

  # the raw run rate log over the course of the job response interpolated to every minute
  interpolatedRunRate: [RunRate]
}

type SegmentDependency {
  id: ID!
  isActive: Boolean
  description: String
  from(filter: OperationsSegmentFilter): OperationsSegment!
  to(filter: OperationsSegmentFilter): OperationsSegment!
  dependencyType: DependencyType
  dependencyFactor: Float
  factorUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  condition: String
  transitionEventRuleset(
    filter: TransitionEventRulesetFilter
  ): TransitionEventRuleset
  jobOrderDependencies(
    filter: JobOrderDependencyFilter
    order: JobOrderDependencyOrder
    first: Int
    offset: Int
  ): [JobOrderDependency]
  jobOrderDependenciesAggregate(
    filter: JobOrderDependencyFilter
  ): JobOrderDependencyAggregateResult
}

type SegmentDependencyAggregateResult {
  count: Int
  descriptionMin: String
  descriptionMax: String
  dependencyFactorMin: Float
  dependencyFactorMax: Float
  dependencyFactorSum: Float
  dependencyFactorAvg: Float
  conditionMin: String
  conditionMax: String
}

input SegmentDependencyFilter {
  id: [ID!]
  isActive: Boolean
  has: [SegmentDependencyHasFilter]
  and: [SegmentDependencyFilter]
  or: [SegmentDependencyFilter]
  not: SegmentDependencyFilter
}

enum SegmentDependencyHasFilter {
  isActive
  description
  from
  to
  dependencyType
  dependencyFactor
  factorUoM
  condition
  transitionEventRuleset
  jobOrderDependencies
}

input SegmentDependencyOrder {
  asc: SegmentDependencyOrderable
  desc: SegmentDependencyOrderable
  then: SegmentDependencyOrder
}

enum SegmentDependencyOrderable {
  description
  dependencyFactor
  condition
}

input SegmentDependencyPatch {
  isActive: Boolean
  description: String
  from: OperationsSegmentRef
  to: OperationsSegmentRef
  dependencyType: DependencyType
  dependencyFactor: Float
  factorUoM: UnitOfMeasureRef
  condition: String
  transitionEventRuleset: TransitionEventRulesetRef
  jobOrderDependencies: [JobOrderDependencyRef]
}

input SegmentDependencyRef {
  id: ID
  isActive: Boolean
  description: String
  from: OperationsSegmentRef
  to: OperationsSegmentRef
  dependencyType: DependencyType
  dependencyFactor: Float
  factorUoM: UnitOfMeasureRef
  condition: String
  transitionEventRuleset: TransitionEventRulesetRef
  jobOrderDependencies: [JobOrderDependencyRef]
}

type SegmentInvoiceSetting {
  id: ID!
  partner(filter: PartnerFilter): Partner
  costPerHour: Float
  costPerUnit: Float
}

type SegmentInvoiceSettingAggregateResult {
  count: Int
  costPerHourMin: Float
  costPerHourMax: Float
  costPerHourSum: Float
  costPerHourAvg: Float
  costPerUnitMin: Float
  costPerUnitMax: Float
  costPerUnitSum: Float
  costPerUnitAvg: Float
}

input SegmentInvoiceSettingFilter {
  id: [ID!]
  has: [SegmentInvoiceSettingHasFilter]
  and: [SegmentInvoiceSettingFilter]
  or: [SegmentInvoiceSettingFilter]
  not: SegmentInvoiceSettingFilter
}

enum SegmentInvoiceSettingHasFilter {
  partner
  costPerHour
  costPerUnit
}

input SegmentInvoiceSettingOrder {
  asc: SegmentInvoiceSettingOrderable
  desc: SegmentInvoiceSettingOrderable
  then: SegmentInvoiceSettingOrder
}

enum SegmentInvoiceSettingOrderable {
  costPerHour
  costPerUnit
}

input SegmentInvoiceSettingPatch {
  partner: PartnerRef
  costPerHour: Float
  costPerUnit: Float
}

input SegmentInvoiceSettingRef {
  id: ID
  partner: PartnerRef
  costPerHour: Float
  costPerUnit: Float
}

enum SegmentType {
  USER_TASK
  SYSTEM_TASK
  EMBED_SUBPROCESS
}

# A shipment represents a consignment of goods being sent or received into a warehouse
type Shipment {
  id: ID!
  isActive: Boolean
  type: ShipmentType!
  transportCompany: TransportCompany
  transportCompanyShipmentId: String
  transportCompanyProductCode: String
  reference: String
  items(
    filter: ShipmentItemFilter
    order: ShipmentItemOrder
    first: Int
    offset: Int
  ): [ShipmentItem]
  customerReference: String
  emailTrackingEnabled: Boolean
  from(filter: AddressFilter): Address
  to(filter: AddressFilter): Address
  order(filter: OrderFilter): Order!
  warehouse(filter: EquipmentFilter): Equipment!
  consignmentNumber: String
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  dateTimeReceivedUTC: DateTime
  dateTimeDeliveredUTC: DateTime
  dateTimePackedUTC: DateTime
  dateTimeCreatedUTC: DateTime
  delivered(filter: DeliveryFilter): Delivery
  status: ShipmentStatus
  itemsAggregate(filter: ShipmentItemFilter): ShipmentItemAggregateResult
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  packedItems(filter: PackedItemsFilter): [PackedItem]
}

type ShipmentAggregateResult {
  count: Int
  transportCompanyShipmentIdMin: String
  transportCompanyShipmentIdMax: String
  transportCompanyProductCodeMin: String
  transportCompanyProductCodeMax: String
  referenceMin: String
  referenceMax: String
  customerReferenceMin: String
  customerReferenceMax: String
  consignmentNumberMin: String
  consignmentNumberMax: String
  dateTimeReceivedUTCMin: DateTime
  dateTimeReceivedUTCMax: DateTime
  dateTimeDeliveredUTCMin: DateTime
  dateTimeDeliveredUTCMax: DateTime
  dateTimePackedUTCMin: DateTime
  dateTimePackedUTCMax: DateTime
  dateTimeCreatedUTCMin: DateTime
  dateTimeCreatedUTCMax: DateTime
}

input ShipmentFilter {
  id: [ID!]
  isActive: Boolean
  type: ShipmentType_hash
  reference: StringHashFilter_StringRegExpFilter
  consignmentNumber: StringFullTextFilter_StringHashFilter
  dateTimeReceivedUTC: DateTimeFilter
  dateTimeDeliveredUTC: DateTimeFilter
  dateTimePackedUTC: DateTimeFilter
  dateTimeCreatedUTC: DateTimeFilter
  status: ShipmentStatus_hash
  has: [ShipmentHasFilter]
  and: [ShipmentFilter]
  or: [ShipmentFilter]
  not: ShipmentFilter
}

enum ShipmentHasFilter {
  isActive
  type
  transportCompany
  transportCompanyShipmentId
  transportCompanyProductCode
  reference
  items
  customerReference
  emailTrackingEnabled
  from
  to
  order
  warehouse
  consignmentNumber
  properties
  dateTimeReceivedUTC
  dateTimeDeliveredUTC
  dateTimePackedUTC
  dateTimeCreatedUTC
  delivered
  status
}

# A shipment item represents an individual package or line item within the shipment
type ShipmentItem {
  id: ID!
  isActive: Boolean
  transportCompanyItemReference: String
  transportCompanyItemId: String
  trackingDetailsArticleId: String
  trackingDetailsBarcodeId: String
  trackingDetailsConsignmentId: String
  shipment(filter: ShipmentFilter): Shipment
  status: ShipmentItemStatus!
  material(filter: MaterialDefinitionFilter): MaterialDefinition
  plannedQuantity: Int
  isParcel: Boolean
  bin(filter: EquipmentFilter): Equipment
  box(filter: BoxFilter): Box
  weightKg: Float
  packedQty: Int
  packedItems(filter: PackedItemsFilter): [PackedItem]
}

type ShipmentItemAggregateResult {
  count: Int
  transportCompanyItemReferenceMin: String
  transportCompanyItemReferenceMax: String
  transportCompanyItemIdMin: String
  transportCompanyItemIdMax: String
  trackingDetailsArticleIdMin: String
  trackingDetailsArticleIdMax: String
  trackingDetailsBarcodeIdMin: String
  trackingDetailsBarcodeIdMax: String
  trackingDetailsConsignmentIdMin: String
  trackingDetailsConsignmentIdMax: String
  plannedQuantityMin: Int
  plannedQuantityMax: Int
  plannedQuantitySum: Int
  plannedQuantityAvg: Float
  weightKgMin: Float
  weightKgMax: Float
  weightKgSum: Float
  weightKgAvg: Float
}

input ShipmentItemFilter {
  id: [ID!]
  isActive: Boolean
  status: ShipmentItemStatus_hash
  isParcel: Boolean
  has: [ShipmentItemHasFilter]
  and: [ShipmentItemFilter]
  or: [ShipmentItemFilter]
  not: ShipmentItemFilter
}

enum ShipmentItemHasFilter {
  isActive
  transportCompanyItemReference
  transportCompanyItemId
  trackingDetailsArticleId
  trackingDetailsBarcodeId
  trackingDetailsConsignmentId
  shipment
  status
  material
  plannedQuantity
  isParcel
  bin
  box
  weightKg
}

input ShipmentItemOrder {
  asc: ShipmentItemOrderable
  desc: ShipmentItemOrderable
  then: ShipmentItemOrder
}

enum ShipmentItemOrderable {
  transportCompanyItemReference
  transportCompanyItemId
  trackingDetailsArticleId
  trackingDetailsBarcodeId
  trackingDetailsConsignmentId
  plannedQuantity
  weightKg
}

input ShipmentItemPatch {
  isActive: Boolean
  transportCompanyItemReference: String
  transportCompanyItemId: String
  trackingDetailsArticleId: String
  trackingDetailsBarcodeId: String
  trackingDetailsConsignmentId: String
  shipment: ShipmentRef
  status: ShipmentItemStatus
  material: MaterialDefinitionRef
  plannedQuantity: Int
  isParcel: Boolean
  bin: EquipmentRef
  box: BoxRef
  weightKg: Float
}

input ShipmentItemRef {
  id: ID
  isActive: Boolean
  transportCompanyItemReference: String
  transportCompanyItemId: String
  trackingDetailsArticleId: String
  trackingDetailsBarcodeId: String
  trackingDetailsConsignmentId: String
  shipment: ShipmentRef
  status: ShipmentItemStatus
  material: MaterialDefinitionRef
  plannedQuantity: Int
  isParcel: Boolean
  bin: EquipmentRef
  box: BoxRef
  weightKg: Float
}

enum ShipmentItemStatus {
  CREATED
  PACKED
  SHIPPED
  DELIVERED
  DELETED
}

input ShipmentItemStatus_hash {
  eq: ShipmentItemStatus
  in: [ShipmentItemStatus]
}

input ShipmentOrder {
  asc: ShipmentOrderable
  desc: ShipmentOrderable
  then: ShipmentOrder
}

enum ShipmentOrderable {
  transportCompanyShipmentId
  transportCompanyProductCode
  reference
  customerReference
  consignmentNumber
  dateTimeReceivedUTC
  dateTimeDeliveredUTC
  dateTimePackedUTC
  dateTimeCreatedUTC
}

input ShipmentPatch {
  isActive: Boolean
  type: ShipmentType
  transportCompany: TransportCompany
  transportCompanyShipmentId: String
  transportCompanyProductCode: String
  reference: String
  items: [ShipmentItemRef]
  customerReference: String
  emailTrackingEnabled: Boolean
  from: AddressRef
  to: AddressRef
  order: OrderRef
  warehouse: EquipmentRef
  consignmentNumber: String
  properties: [PropertyRef]
  dateTimeReceivedUTC: DateTime
  dateTimeDeliveredUTC: DateTime
  dateTimePackedUTC: DateTime
  dateTimeCreatedUTC: DateTime
  delivered: DeliveryRef
  status: ShipmentStatus
}

input ShipmentRef {
  id: ID
  isActive: Boolean
  type: ShipmentType
  transportCompany: TransportCompany
  transportCompanyShipmentId: String
  transportCompanyProductCode: String
  reference: String
  items: [ShipmentItemRef]
  customerReference: String
  emailTrackingEnabled: Boolean
  from: AddressRef
  to: AddressRef
  order: OrderRef
  warehouse: EquipmentRef
  consignmentNumber: String
  properties: [PropertyRef]
  dateTimeReceivedUTC: DateTime
  dateTimeDeliveredUTC: DateTime
  dateTimePackedUTC: DateTime
  dateTimeCreatedUTC: DateTime
  delivered: DeliveryRef
  status: ShipmentStatus
}

enum ShipmentStatus {
  CREATED
  PACKED
  SHIPPED
  DELIVERED
  COMPLETE
  RECEIVED
  UNPACKED
}

input ShipmentStatus_hash {
  eq: ShipmentStatus
  in: [ShipmentStatus]
}

enum ShipmentType {
  INBOUND
  OUTBOUND
  RETURN
}

input ShipmentType_hash {
  eq: ShipmentType
  in: [ShipmentType]
}

type ShippingAccount {
  id: ID!
  isActive: Boolean
  partner(filter: PartnerFilter): Partner
  transportCompany: TransportCompany
  warehouse(filter: EquipmentFilter): Equipment
  accountNumber: String
  username: String
  secret: String
}

type ShippingAccountAggregateResult {
  count: Int
  accountNumberMin: String
  accountNumberMax: String
  usernameMin: String
  usernameMax: String
  secretMin: String
  secretMax: String
}

input ShippingAccountData {
  Partner: ExtPartnerRef!
  TransportCompany: TransportCompany!
  Warehouse: ExtEquipmentRef!
}

input ShippingAccountFilter {
  id: [ID!]
  isActive: Boolean
  transportCompany: TransportCompany_hash
  has: [ShippingAccountHasFilter]
  and: [ShippingAccountFilter]
  or: [ShippingAccountFilter]
  not: ShippingAccountFilter
}

enum ShippingAccountHasFilter {
  isActive
  partner
  transportCompany
  warehouse
  accountNumber
  username
  secret
}

input ShippingAccountOrder {
  asc: ShippingAccountOrderable
  desc: ShippingAccountOrderable
  then: ShippingAccountOrder
}

enum ShippingAccountOrderable {
  accountNumber
  username
  secret
}

input ShippingAccountPatch {
  isActive: Boolean
  partner: PartnerRef
  transportCompany: TransportCompany
  warehouse: EquipmentRef
  accountNumber: String
  username: String
  secret: String
}

input ShippingAccountRef {
  id: ID
  isActive: Boolean
  partner: PartnerRef
  transportCompany: TransportCompany
  warehouse: EquipmentRef
  accountNumber: String
  username: String
  secret: String
}

type StateEventRuleset {
  id: ID!
  name: String!
  triggerWhen: [RulesetTriggerOption]
  segment(filter: OperationsSegmentFilter): OperationsSegment
  targetState: String!
  eventDefs(
    filter: EventDefinitionFilter
    order: EventDefinitionOrder
    first: Int
    offset: Int
  ): [EventDefinition]
  eventDefsAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
}

type StateEventRulesetAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  targetStateMin: String
  targetStateMax: String
}

input StateEventRulesetFilter {
  id: [ID!]
  has: [StateEventRulesetHasFilter]
  and: [StateEventRulesetFilter]
  or: [StateEventRulesetFilter]
  not: StateEventRulesetFilter
}

enum StateEventRulesetHasFilter {
  name
  triggerWhen
  segment
  targetState
  eventDefs
}

input StateEventRulesetOrder {
  asc: StateEventRulesetOrderable
  desc: StateEventRulesetOrderable
  then: StateEventRulesetOrder
}

enum StateEventRulesetOrderable {
  name
  targetState
}

input StateEventRulesetPatch {
  name: String
  triggerWhen: [RulesetTriggerOption]
  segment: OperationsSegmentRef
  targetState: String
  eventDefs: [EventDefinitionRef]
}

input StateEventRulesetRef {
  id: ID
  name: String
  triggerWhen: [RulesetTriggerOption]
  segment: OperationsSegmentRef
  targetState: String
  eventDefs: [EventDefinitionRef]
}

input StateFilter {
  canPack: Boolean
  canReceive: Boolean
  isPlanned: Boolean
}

input StockOnHandFilter {
  materialSubLot: [ExtMaterialSubLotRef]
  carrier: [ExtCarrierRef]
  material: [ExtMaterialDefinitionRef]
  storageLocation: [ExtEquipmentRef]
  status: [ExtMaterialStatusRef]
  shipment: [ExtShipmentRef]
  shipmentItem: [ExtShipmentItemRef]
  jobResponse: [ExtJobResponseRef]
  from: DateTime
  to: DateTime
  groupBy: StockOnHandGroupBy
  minimumStock: Int
  maximumStock: Int
}

input StockOnHandGroupBy {
  carrier: Boolean
  storageLocation: Boolean
  status: Boolean
  shipment: Boolean
  subLot: Boolean
  jobResponse: Boolean
}

enum StockType {
  NEW_STOCK
  REPAIRED
  RETURNED
}

input StockType_hash {
  eq: StockType
  in: [StockType]
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
  between: StringRange
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringFullTextFilter_StringHashFilter {
  alloftext: String
  anyoftext: String
  eq: String
  in: [String]
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringHashFilter_StringRegExpFilter {
  eq: String
  in: [String]
  regexp: String
}

input StringRange {
  min: String!
  max: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type TestResult {
  id: ID!
  isActive: Boolean
  description: String
  result: String
  uom(filter: UnitOfMeasureFilter): UnitOfMeasure
  testDateTime: DateTime
}

type TestResultAggregateResult {
  count: Int
  descriptionMin: String
  descriptionMax: String
  resultMin: String
  resultMax: String
  testDateTimeMin: DateTime
  testDateTimeMax: DateTime
}

input TestResultFilter {
  id: [ID!]
  isActive: Boolean
  has: [TestResultHasFilter]
  and: [TestResultFilter]
  or: [TestResultFilter]
  not: TestResultFilter
}

enum TestResultHasFilter {
  isActive
  description
  result
  uom
  testDateTime
}

input TestResultOrder {
  asc: TestResultOrderable
  desc: TestResultOrderable
  then: TestResultOrder
}

enum TestResultOrderable {
  description
  result
  testDateTime
}

input TestResultPatch {
  isActive: Boolean
  description: String
  result: String
  uom: UnitOfMeasureRef
  testDateTime: DateTime
}

input TestResultRef {
  id: ID
  isActive: Boolean
  description: String
  result: String
  uom: UnitOfMeasureRef
  testDateTime: DateTime
}

type TestSpecification {
  id: ID!
  isActive: Boolean
  description: String
  version: String
}

type TestSpecificationAggregateResult {
  count: Int
  descriptionMin: String
  descriptionMax: String
  versionMin: String
  versionMax: String
}

input TestSpecificationFilter {
  id: [ID!]
  isActive: Boolean
  has: [TestSpecificationHasFilter]
  and: [TestSpecificationFilter]
  or: [TestSpecificationFilter]
  not: TestSpecificationFilter
}

enum TestSpecificationHasFilter {
  isActive
  description
  version
}

input TestSpecificationOrder {
  asc: TestSpecificationOrderable
  desc: TestSpecificationOrderable
  then: TestSpecificationOrder
}

enum TestSpecificationOrderable {
  description
  version
}

input TestSpecificationPatch {
  isActive: Boolean
  description: String
  version: String
}

input TestSpecificationRef {
  id: ID
  isActive: Boolean
  description: String
  version: String
}

# Time Category abbreviations are defined in ISO 22400 and are used
# to calculate the ISO standard KPI
enum TimeCategory {
  # APT is the actual production time is the time during a work unit is producing. It includes only the value-adding functions.
  APT

  # AUST is the actual setup time is the time actually consumed for the preparation of an order at a work unit.
  AUST

  # ADET is the actual unit delay times are actual times associated with malfunction-caused interrupts, minor stoppages,
  # and other unplanned time intervals that occur while tasks are being completed that lead to unwanted extension
  # of the order processing time
  ADET

  # ADOT is the actual unit down time is the time when the work unit is not running with orders, although it is available.
  ADOT

  # PSDT is the time in which the work unit is planned to be out of operation
  PSDT

  # PDOT is time, included in the planned operation time, in which the work unit is planned for no operations within the operation time period
  PDOT

  # TTR is the time interval during which an item is in a down state due to a failure (IEC 60050-191)
  TTR
}

input TimeRangeFilter {
  from: DateTime
  to: DateTime
}

type TransitionEventRuleset {
  id: ID!
  name: String!
  segmentDependency(filter: SegmentDependencyFilter): SegmentDependency
  eventDefs(
    filter: EventDefinitionFilter
    order: EventDefinitionOrder
    first: Int
    offset: Int
  ): [EventDefinition]
  eventDefsAggregate(
    filter: EventDefinitionFilter
  ): EventDefinitionAggregateResult
}

type TransitionEventRulesetAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input TransitionEventRulesetFilter {
  id: [ID!]
  has: [TransitionEventRulesetHasFilter]
  and: [TransitionEventRulesetFilter]
  or: [TransitionEventRulesetFilter]
  not: TransitionEventRulesetFilter
}

enum TransitionEventRulesetHasFilter {
  name
  segmentDependency
  eventDefs
}

input TransitionEventRulesetOrder {
  asc: TransitionEventRulesetOrderable
  desc: TransitionEventRulesetOrderable
  then: TransitionEventRulesetOrder
}

enum TransitionEventRulesetOrderable {
  name
}

input TransitionEventRulesetPatch {
  name: String
  segmentDependency: SegmentDependencyRef
  eventDefs: [EventDefinitionRef]
}

input TransitionEventRulesetRef {
  id: ID
  name: String
  segmentDependency: SegmentDependencyRef
  eventDefs: [EventDefinitionRef]
}

enum TransportCompany {
  AUSPOST
  MANUAL
}

input TransportCompany_hash {
  eq: TransportCompany
  in: [TransportCompany]
}

type TransportCompanyDeliveryOrder {
  DeliveryID: String!
  TransportCompanyDeliveryID: String!
  TotalCost: Float
  TotalCostExGst: Float
  TotalGst: Float
  Status: String
  NumberOfShipments: Int
  Shipments: [Shipment]
}

type UnitOfMeasure {
  id: ID!
  isActive: Boolean
  code: String!
  dataType: DataType
}

type UnitOfMeasureAggregateResult {
  count: Int
  codeMin: String
  codeMax: String
}

type UnitOfMeasureConversion {
  id: ID!
  isActive: Boolean
  fromUoM(filter: UnitOfMeasureFilter): UnitOfMeasure!
  toUoM(filter: UnitOfMeasureFilter): UnitOfMeasure!
  numerator: Float!
  denominator: Float!
  material(filter: MaterialDefinitionFilter): MaterialDefinition!
}

type UnitOfMeasureConversionAggregateResult {
  count: Int
  numeratorMin: Float
  numeratorMax: Float
  numeratorSum: Float
  numeratorAvg: Float
  denominatorMin: Float
  denominatorMax: Float
  denominatorSum: Float
  denominatorAvg: Float
}

input UnitOfMeasureConversionFilter {
  id: [ID!]
  isActive: Boolean
  has: [UnitOfMeasureConversionHasFilter]
  and: [UnitOfMeasureConversionFilter]
  or: [UnitOfMeasureConversionFilter]
  not: UnitOfMeasureConversionFilter
}

enum UnitOfMeasureConversionHasFilter {
  isActive
  fromUoM
  toUoM
  numerator
  denominator
  material
}

input UnitOfMeasureConversionOrder {
  asc: UnitOfMeasureConversionOrderable
  desc: UnitOfMeasureConversionOrderable
  then: UnitOfMeasureConversionOrder
}

enum UnitOfMeasureConversionOrderable {
  numerator
  denominator
}

input UnitOfMeasureConversionPatch {
  isActive: Boolean
  fromUoM: UnitOfMeasureRef
  toUoM: UnitOfMeasureRef
  numerator: Float
  denominator: Float
  material: MaterialDefinitionRef
}

input UnitOfMeasureConversionRef {
  id: ID
  isActive: Boolean
  fromUoM: UnitOfMeasureRef
  toUoM: UnitOfMeasureRef
  numerator: Float
  denominator: Float
  material: MaterialDefinitionRef
}

input UnitOfMeasureFilter {
  id: [ID!]
  isActive: Boolean
  code: StringHashFilter
  has: [UnitOfMeasureHasFilter]
  and: [UnitOfMeasureFilter]
  or: [UnitOfMeasureFilter]
  not: UnitOfMeasureFilter
}

enum UnitOfMeasureHasFilter {
  isActive
  code
  dataType
}

input UnitOfMeasureOrder {
  asc: UnitOfMeasureOrderable
  desc: UnitOfMeasureOrderable
  then: UnitOfMeasureOrder
}

enum UnitOfMeasureOrderable {
  code
}

input UnitOfMeasurePatch {
  isActive: Boolean
  dataType: DataType
}

input UnitOfMeasureRef {
  id: ID
  isActive: Boolean
  code: String
  dataType: DataType
}

input UpdateAccessRightInput {
  filter: AccessRightFilter!
  set: AccessRightPatch
  remove: AccessRightPatch
}

type UpdateAccessRightPayload {
  accessRight(filter: AccessRightFilter, first: Int, offset: Int): [AccessRight]
  numUids: Int
}

input UpdateACLInput {
  filter: ACLFilter!
  set: ACLPatch
  remove: ACLPatch
}

type UpdateACLPayload {
  aCL(filter: ACLFilter, first: Int, offset: Int): [ACL]
  numUids: Int
}

input UpdateAddressInput {
  filter: AddressFilter!
  set: AddressPatch
  remove: AddressPatch
}

type UpdateAddressPayload {
  address(
    filter: AddressFilter
    order: AddressOrder
    first: Int
    offset: Int
  ): [Address]
  numUids: Int
}

input UpdateBillOfMaterialInput {
  filter: BillOfMaterialFilter!
  set: BillOfMaterialPatch
  remove: BillOfMaterialPatch
}

type UpdateBillOfMaterialPayload {
  billOfMaterial(
    filter: BillOfMaterialFilter
    order: BillOfMaterialOrder
    first: Int
    offset: Int
  ): [BillOfMaterial]
  numUids: Int
}

input UpdateBoxInput {
  filter: BoxFilter!
  set: BoxPatch
  remove: BoxPatch
}

type UpdateBoxPayload {
  box(filter: BoxFilter, order: BoxOrder, first: Int, offset: Int): [Box]
  numUids: Int
}

input UpdateCarrierInput {
  filter: CarrierFilter!
  set: CarrierPatch
  remove: CarrierPatch
}

type UpdateCarrierPayload {
  carrier(
    filter: CarrierFilter
    order: CarrierOrder
    first: Int
    offset: Int
  ): [Carrier]
  numUids: Int
}

input UpdateDashboardConfigInput {
  filter: DashboardConfigFilter!
  set: DashboardConfigPatch
  remove: DashboardConfigPatch
}

type UpdateDashboardConfigPayload {
  dashboardConfig(
    filter: DashboardConfigFilter
    order: DashboardConfigOrder
    first: Int
    offset: Int
  ): [DashboardConfig]
  numUids: Int
}

input UpdateDashboardPanelConfigInput {
  filter: DashboardPanelConfigFilter!
  set: DashboardPanelConfigPatch
  remove: DashboardPanelConfigPatch
}

type UpdateDashboardPanelConfigPayload {
  dashboardPanelConfig(
    filter: DashboardPanelConfigFilter
    order: DashboardPanelConfigOrder
    first: Int
    offset: Int
  ): [DashboardPanelConfig]
  numUids: Int
}

input UpdateDashboardWidgetConfigPropertyInput {
  filter: DashboardWidgetConfigPropertyFilter!
  set: DashboardWidgetConfigPropertyPatch
  remove: DashboardWidgetConfigPropertyPatch
}

type UpdateDashboardWidgetConfigPropertyPayload {
  dashboardWidgetConfigProperty(
    filter: DashboardWidgetConfigPropertyFilter
    order: DashboardWidgetConfigPropertyOrder
    first: Int
    offset: Int
  ): [DashboardWidgetConfigProperty]
  numUids: Int
}

input UpdateDeliveryInput {
  filter: DeliveryFilter!
  set: DeliveryPatch
  remove: DeliveryPatch
}

type UpdateDeliveryPayload {
  delivery(
    filter: DeliveryFilter
    order: DeliveryOrder
    first: Int
    offset: Int
  ): [Delivery]
  numUids: Int
}

type UpdatedOrderStatus {
  equipment: Equipment
  eventStartTime: DateTime
  updateType: String
}

input UpdateEquipmentActualInput {
  filter: EquipmentActualFilter!
  set: EquipmentActualPatch
  remove: EquipmentActualPatch
}

type UpdateEquipmentActualPayload {
  equipmentActual(
    filter: EquipmentActualFilter
    order: EquipmentActualOrder
    first: Int
    offset: Int
  ): [EquipmentActual]
  numUids: Int
}

input UpdateEquipmentClassInput {
  filter: EquipmentClassFilter!
  set: EquipmentClassPatch
  remove: EquipmentClassPatch
}

type UpdateEquipmentClassPayload {
  equipmentClass(
    filter: EquipmentClassFilter
    order: EquipmentClassOrder
    first: Int
    offset: Int
  ): [EquipmentClass]
  numUids: Int
}

input UpdateEquipmentInput {
  filter: EquipmentFilter!
  set: EquipmentPatch
  remove: EquipmentPatch
}

input UpdateEquipmentNameAliasInput {
  filter: EquipmentNameAliasFilter!
  set: EquipmentNameAliasPatch
  remove: EquipmentNameAliasPatch
}

type UpdateEquipmentNameAliasPayload {
  equipmentNameAlias(
    filter: EquipmentNameAliasFilter
    order: EquipmentNameAliasOrder
    first: Int
    offset: Int
  ): [EquipmentNameAlias]
  numUids: Int
}

type UpdateEquipmentPayload {
  equipment(
    filter: EquipmentFilter
    order: EquipmentOrder
    first: Int
    offset: Int
  ): [Equipment]
  numUids: Int
}

input UpdateEquipmentPropertyOverrideInput {
  filter: EquipmentPropertyOverrideFilter!
  set: EquipmentPropertyOverridePatch
  remove: EquipmentPropertyOverridePatch
}

type UpdateEquipmentPropertyOverridePayload {
  equipmentPropertyOverride(
    filter: EquipmentPropertyOverrideFilter
    order: EquipmentPropertyOverrideOrder
    first: Int
    offset: Int
  ): [EquipmentPropertyOverride]
  numUids: Int
}

input UpdateEquipmentReasonOverrideInput {
  filter: EquipmentReasonOverrideFilter!
  set: EquipmentReasonOverridePatch
  remove: EquipmentReasonOverridePatch
}

type UpdateEquipmentReasonOverridePayload {
  equipmentReasonOverride(
    filter: EquipmentReasonOverrideFilter
    order: EquipmentReasonOverrideOrder
    first: Int
    offset: Int
  ): [EquipmentReasonOverride]
  numUids: Int
}

input UpdateEquipmentRelationInput {
  filter: EquipmentRelationFilter!
  set: EquipmentRelationPatch
  remove: EquipmentRelationPatch
}

type UpdateEquipmentRelationPayload {
  equipmentRelation(
    filter: EquipmentRelationFilter
    first: Int
    offset: Int
  ): [EquipmentRelation]
  numUids: Int
}

input UpdateEquipmentSpecificationInput {
  filter: EquipmentSpecificationFilter!
  set: EquipmentSpecificationPatch
  remove: EquipmentSpecificationPatch
}

type UpdateEquipmentSpecificationPayload {
  equipmentSpecification(
    filter: EquipmentSpecificationFilter
    order: EquipmentSpecificationOrder
    first: Int
    offset: Int
  ): [EquipmentSpecification]
  numUids: Int
}

input UpdateEventDefinitionInput {
  filter: EventDefinitionFilter!
  set: EventDefinitionPatch
  remove: EventDefinitionPatch
}

type UpdateEventDefinitionPayload {
  eventDefinition(
    filter: EventDefinitionFilter
    order: EventDefinitionOrder
    first: Int
    offset: Int
  ): [EventDefinition]
  numUids: Int
}

input UpdateEventLogInput {
  filter: EventLogFilter!
  set: EventLogPatch
  remove: EventLogPatch
}

type UpdateEventLogPayload {
  eventLog(
    filter: EventLogFilter
    order: EventLogOrder
    first: Int
    offset: Int
  ): [EventLog]
  numUids: Int
}

input UpdateFormInput {
  filter: FormFilter!
  set: FormPatch
  remove: FormPatch
}

type UpdateFormPayload {
  form(filter: FormFilter, order: FormOrder, first: Int, offset: Int): [Form]
  numUids: Int
}

input UpdateGeneralLedgerAccountInput {
  filter: GeneralLedgerAccountFilter!
  set: GeneralLedgerAccountPatch
  remove: GeneralLedgerAccountPatch
}

type UpdateGeneralLedgerAccountPayload {
  generalLedgerAccount(
    filter: GeneralLedgerAccountFilter
    order: GeneralLedgerAccountOrder
    first: Int
    offset: Int
  ): [GeneralLedgerAccount]
  numUids: Int
}

input UpdateInterfaceMessageLogInput {
  filter: InterfaceMessageLogFilter!
  set: InterfaceMessageLogPatch
  remove: InterfaceMessageLogPatch
}

type UpdateInterfaceMessageLogPayload {
  interfaceMessageLog(
    filter: InterfaceMessageLogFilter
    order: InterfaceMessageLogOrder
    first: Int
    offset: Int
  ): [InterfaceMessageLog]
  numUids: Int
}

input UpdateInventoryHandlingPolicyInput {
  filter: InventoryHandlingPolicyFilter!
  set: InventoryHandlingPolicyPatch
  remove: InventoryHandlingPolicyPatch
}

type UpdateInventoryHandlingPolicyPayload {
  inventoryHandlingPolicy(
    filter: InventoryHandlingPolicyFilter
    order: InventoryHandlingPolicyOrder
    first: Int
    offset: Int
  ): [InventoryHandlingPolicy]
  numUids: Int
}

input UpdateInventoryHandlingRuleInput {
  filter: InventoryHandlingRuleFilter!
  set: InventoryHandlingRulePatch
  remove: InventoryHandlingRulePatch
}

type UpdateInventoryHandlingRulePayload {
  inventoryHandlingRule(
    filter: InventoryHandlingRuleFilter
    first: Int
    offset: Int
  ): [InventoryHandlingRule]
  numUids: Int
}

input UpdateInventoryHoldingPolicyInput {
  filter: InventoryHoldingPolicyFilter!
  set: InventoryHoldingPolicyPatch
  remove: InventoryHoldingPolicyPatch
}

type UpdateInventoryHoldingPolicyPayload {
  inventoryHoldingPolicy(
    filter: InventoryHoldingPolicyFilter
    order: InventoryHoldingPolicyOrder
    first: Int
    offset: Int
  ): [InventoryHoldingPolicy]
  numUids: Int
}

input UpdateJobOrderDependencyInput {
  filter: JobOrderDependencyFilter!
  set: JobOrderDependencyPatch
  remove: JobOrderDependencyPatch
}

type UpdateJobOrderDependencyPayload {
  jobOrderDependency(
    filter: JobOrderDependencyFilter
    order: JobOrderDependencyOrder
    first: Int
    offset: Int
  ): [JobOrderDependency]
  numUids: Int
}

input UpdateJobOrderDispatchStateModelInput {
  filter: JobOrderDispatchStateModelFilter!
  set: JobOrderDispatchStateModelPatch
  remove: JobOrderDispatchStateModelPatch
}

type UpdateJobOrderDispatchStateModelPayload {
  jobOrderDispatchStateModel(
    filter: JobOrderDispatchStateModelFilter
    first: Int
    offset: Int
  ): [JobOrderDispatchStateModel]
  numUids: Int
}

input UpdateJobOrderInput {
  filter: JobOrderFilter!
  set: JobOrderPatch
  remove: JobOrderPatch
}

input UpdateJobOrderNoteInput {
  filter: JobOrderNoteFilter!
  set: JobOrderNotePatch
  remove: JobOrderNotePatch
}

type UpdateJobOrderNotePayload {
  jobOrderNote(
    filter: JobOrderNoteFilter
    order: JobOrderNoteOrder
    first: Int
    offset: Int
  ): [JobOrderNote]
  numUids: Int
}

type UpdateJobOrderPayload {
  jobOrder(
    filter: JobOrderFilter
    order: JobOrderOrder
    first: Int
    offset: Int
  ): [JobOrder]
  numUids: Int
}

input UpdateJobOrderStatusInput {
  filter: JobOrderFilter!
  set: JobOrderStatusPatch
}

input UpdateJobResponseInput {
  filter: JobResponseFilter!
  set: JobResponsePatch
  remove: JobResponsePatch
}

type UpdateJobResponsePayload {
  jobResponse(
    filter: JobResponseFilter
    order: JobResponseOrder
    first: Int
    offset: Int
  ): [JobResponse]
  numUids: Int
}

input UpdateLibreServiceInput {
  filter: LibreServiceFilter!
  set: LibreServicePatch
  remove: LibreServicePatch
}

type UpdateLibreServicePayload {
  libreService(
    filter: LibreServiceFilter
    order: LibreServiceOrder
    first: Int
    offset: Int
  ): [LibreService]
  numUids: Int
}

input UpdateMaterialActualInput {
  filter: MaterialActualFilter!
  set: MaterialActualPatch
  remove: MaterialActualPatch
}

type UpdateMaterialActualPayload {
  materialActual(
    filter: MaterialActualFilter
    order: MaterialActualOrder
    first: Int
    offset: Int
  ): [MaterialActual]
  numUids: Int
}

input UpdateMaterialAlternateInput {
  filter: MaterialAlternateFilter!
  set: MaterialAlternatePatch
  remove: MaterialAlternatePatch
}

type UpdateMaterialAlternatePayload {
  materialAlternate(
    filter: MaterialAlternateFilter
    order: MaterialAlternateOrder
    first: Int
    offset: Int
  ): [MaterialAlternate]
  numUids: Int
}

input UpdateMaterialClassInput {
  filter: MaterialClassFilter!
  set: MaterialClassPatch
  remove: MaterialClassPatch
}

type UpdateMaterialClassPayload {
  materialClass(
    filter: MaterialClassFilter
    order: MaterialClassOrder
    first: Int
    offset: Int
  ): [MaterialClass]
  numUids: Int
}

input UpdateMaterialDefinitionInput {
  filter: MaterialDefinitionFilter!
  set: MaterialDefinitionPatch
  remove: MaterialDefinitionPatch
}

type UpdateMaterialDefinitionPayload {
  materialDefinition(
    filter: MaterialDefinitionFilter
    order: MaterialDefinitionOrder
    first: Int
    offset: Int
  ): [MaterialDefinition]
  numUids: Int
}

input UpdateMaterialEventRulesetInput {
  filter: MaterialEventRulesetFilter!
  set: MaterialEventRulesetPatch
  remove: MaterialEventRulesetPatch
}

type UpdateMaterialEventRulesetPayload {
  materialEventRuleset(
    filter: MaterialEventRulesetFilter
    order: MaterialEventRulesetOrder
    first: Int
    offset: Int
  ): [MaterialEventRuleset]
  numUids: Int
}

input UpdateMaterialLotInput {
  filter: MaterialLotFilter!
  set: MaterialLotPatch
  remove: MaterialLotPatch
}

type UpdateMaterialLotPayload {
  materialLot(
    filter: MaterialLotFilter
    order: MaterialLotOrder
    first: Int
    offset: Int
  ): [MaterialLot]
  numUids: Int
}

input UpdateMaterialSpecificationInput {
  filter: MaterialSpecificationFilter!
  set: MaterialSpecificationPatch
  remove: MaterialSpecificationPatch
}

type UpdateMaterialSpecificationPayload {
  materialSpecification(
    filter: MaterialSpecificationFilter
    order: MaterialSpecificationOrder
    first: Int
    offset: Int
  ): [MaterialSpecification]
  numUids: Int
}

input UpdateMaterialStateModelInput {
  filter: MaterialStateModelFilter!
  set: MaterialStateModelPatch
  remove: MaterialStateModelPatch
}

type UpdateMaterialStateModelPayload {
  materialStateModel(
    filter: MaterialStateModelFilter
    order: MaterialStateModelOrder
    first: Int
    offset: Int
  ): [MaterialStateModel]
  numUids: Int
}

input UpdateMaterialStateTransitionInput {
  filter: MaterialStateTransitionFilter!
  set: MaterialStateTransitionPatch
  remove: MaterialStateTransitionPatch
}

type UpdateMaterialStateTransitionPayload {
  materialStateTransition(
    filter: MaterialStateTransitionFilter
    first: Int
    offset: Int
  ): [MaterialStateTransition]
  numUids: Int
}

input UpdateMaterialStatusInput {
  filter: MaterialStatusFilter!
  set: MaterialStatusPatch
  remove: MaterialStatusPatch
}

type UpdateMaterialStatusPayload {
  materialStatus(
    filter: MaterialStatusFilter
    order: MaterialStatusOrder
    first: Int
    offset: Int
  ): [MaterialStatus]
  numUids: Int
}

input UpdateMaterialSubLotInput {
  filter: MaterialSubLotFilter!
  set: MaterialSubLotPatch
  remove: MaterialSubLotPatch
}

type UpdateMaterialSubLotPayload {
  materialSubLot(
    filter: MaterialSubLotFilter
    order: MaterialSubLotOrder
    first: Int
    offset: Int
  ): [MaterialSubLot]
  numUids: Int
}

input UpdateMaterialUnitInput {
  filter: MaterialUnitFilter!
  set: MaterialUnitPatch
  remove: MaterialUnitPatch
}

type UpdateMaterialUnitPayload {
  materialUnit(
    filter: MaterialUnitFilter
    order: MaterialUnitOrder
    first: Int
    offset: Int
  ): [MaterialUnit]
  numUids: Int
}

input UpdateMenuInput {
  filter: MenuFilter!
  set: MenuPatch
  remove: MenuPatch
}

type UpdateMenuPayload {
  menu(filter: MenuFilter, order: MenuOrder, first: Int, offset: Int): [Menu]
  numUids: Int
}

input UpdateOperationsDefinitionInput {
  filter: OperationsDefinitionFilter!
  set: OperationsDefinitionPatch
  remove: OperationsDefinitionPatch
}

type UpdateOperationsDefinitionPayload {
  operationsDefinition(
    filter: OperationsDefinitionFilter
    order: OperationsDefinitionOrder
    first: Int
    offset: Int
  ): [OperationsDefinition]
  numUids: Int
}

input UpdateOperationsRequestInput {
  filter: OperationsRequestFilter!
  set: OperationsRequestPatch
  remove: OperationsRequestPatch
}

type UpdateOperationsRequestPayload {
  operationsRequest(
    filter: OperationsRequestFilter
    order: OperationsRequestOrder
    first: Int
    offset: Int
  ): [OperationsRequest]
  numUids: Int
}

input UpdateOperationsSegmentInput {
  filter: OperationsSegmentFilter!
  set: OperationsSegmentPatch
  remove: OperationsSegmentPatch
}

type UpdateOperationsSegmentPayload {
  operationsSegment(
    filter: OperationsSegmentFilter
    order: OperationsSegmentOrder
    first: Int
    offset: Int
  ): [OperationsSegment]
  numUids: Int
}

input UpdateOrderInput {
  filter: OrderFilter!
  set: OrderPatch
  remove: OrderPatch
}

input UpdateOrderLineInput {
  filter: OrderLineFilter!
  set: OrderLinePatch
  remove: OrderLinePatch
}

type UpdateOrderLinePayload {
  orderLine(
    filter: OrderLineFilter
    order: OrderLineOrder
    first: Int
    offset: Int
  ): [OrderLine]
  numUids: Int
}

type UpdateOrderPayload {
  order(
    filter: OrderFilter
    order: OrderOrder
    first: Int
    offset: Int
  ): [Order]
  numUids: Int
}

input UpdateOrderStartRulesetInput {
  filter: OrderStartRulesetFilter!
  set: OrderStartRulesetPatch
  remove: OrderStartRulesetPatch
}

type UpdateOrderStartRulesetPayload {
  orderStartRuleset(
    filter: OrderStartRulesetFilter
    order: OrderStartRulesetOrder
    first: Int
    offset: Int
  ): [OrderStartRuleset]
  numUids: Int
}

input UpdateOrderStatusInput {
  equipment: ExtEquipmentRef!
  eventStartTime: DateTime!
  updateType: String!
}

input UpdateParameterSpecificationInput {
  filter: ParameterSpecificationFilter!
  set: ParameterSpecificationPatch
  remove: ParameterSpecificationPatch
}

type UpdateParameterSpecificationPayload {
  parameterSpecification(
    filter: ParameterSpecificationFilter
    order: ParameterSpecificationOrder
    first: Int
    offset: Int
  ): [ParameterSpecification]
  numUids: Int
}

input UpdatePartnerInput {
  filter: PartnerFilter!
  set: PartnerPatch
  remove: PartnerPatch
}

type UpdatePartnerPayload {
  partner(
    filter: PartnerFilter
    order: PartnerOrder
    first: Int
    offset: Int
  ): [Partner]
  numUids: Int
}

input UpdatePayloadFieldDefinitionInput {
  filter: PayloadFieldDefinitionFilter!
  set: PayloadFieldDefinitionPatch
  remove: PayloadFieldDefinitionPatch
}

type UpdatePayloadFieldDefinitionPayload {
  payloadFieldDefinition(
    filter: PayloadFieldDefinitionFilter
    order: PayloadFieldDefinitionOrder
    first: Int
    offset: Int
  ): [PayloadFieldDefinition]
  numUids: Int
}

input UpdatePersonInput {
  filter: PersonFilter!
  set: PersonPatch
  remove: PersonPatch
}

input UpdatePersonnelActualInput {
  filter: PersonnelActualFilter!
  set: PersonnelActualPatch
  remove: PersonnelActualPatch
}

type UpdatePersonnelActualPayload {
  personnelActual(
    filter: PersonnelActualFilter
    order: PersonnelActualOrder
    first: Int
    offset: Int
  ): [PersonnelActual]
  numUids: Int
}

input UpdatePersonnelClassInput {
  filter: PersonnelClassFilter!
  set: PersonnelClassPatch
  remove: PersonnelClassPatch
}

type UpdatePersonnelClassPayload {
  personnelClass(
    filter: PersonnelClassFilter
    order: PersonnelClassOrder
    first: Int
    offset: Int
  ): [PersonnelClass]
  numUids: Int
}

input UpdatePersonnelSpecificationInput {
  filter: PersonnelSpecificationFilter!
  set: PersonnelSpecificationPatch
  remove: PersonnelSpecificationPatch
}

type UpdatePersonnelSpecificationPayload {
  personnelSpecification(
    filter: PersonnelSpecificationFilter
    order: PersonnelSpecificationOrder
    first: Int
    offset: Int
  ): [PersonnelSpecification]
  numUids: Int
}

type UpdatePersonPayload {
  person(
    filter: PersonFilter
    order: PersonOrder
    first: Int
    offset: Int
  ): [Person]
  numUids: Int
}

input UpdatePropertyInput {
  filter: PropertyFilter!
  set: PropertyPatch
  remove: PropertyPatch
}

input UpdatePropertyNameAliasInput {
  filter: PropertyNameAliasFilter!
  set: PropertyNameAliasPatch
  remove: PropertyNameAliasPatch
}

type UpdatePropertyNameAliasPayload {
  propertyNameAlias(
    filter: PropertyNameAliasFilter
    order: PropertyNameAliasOrder
    first: Int
    offset: Int
  ): [PropertyNameAlias]
  numUids: Int
}

type UpdatePropertyPayload {
  property(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  numUids: Int
}

input UpdatePropertyValueAliasInput {
  filter: PropertyValueAliasFilter!
  set: PropertyValueAliasPatch
  remove: PropertyValueAliasPatch
}

type UpdatePropertyValueAliasPayload {
  propertyValueAlias(
    filter: PropertyValueAliasFilter
    order: PropertyValueAliasOrder
    first: Int
    offset: Int
  ): [PropertyValueAlias]
  numUids: Int
}

input UpdateQuantityLogInput {
  filter: QuantityLogFilter!
  set: QuantityLogPatch
  remove: QuantityLogPatch
}

type UpdateQuantityLogPayload {
  quantityLog(
    filter: QuantityLogFilter
    order: QuantityLogOrder
    first: Int
    offset: Int
  ): [QuantityLog]
  numUids: Int
}

input UpdateReasonCategoryInput {
  filter: ReasonCategoryFilter!
  set: ReasonCategoryPatch
  remove: ReasonCategoryPatch
}

type UpdateReasonCategoryPayload {
  reasonCategory(
    filter: ReasonCategoryFilter
    order: ReasonCategoryOrder
    first: Int
    offset: Int
  ): [ReasonCategory]
  numUids: Int
}

input UpdateReasonInput {
  filter: ReasonFilter!
  set: ReasonPatch
  remove: ReasonPatch
}

type UpdateReasonPayload {
  reason(
    filter: ReasonFilter
    order: ReasonOrder
    first: Int
    offset: Int
  ): [Reason]
  numUids: Int
}

input UpdateRequestStateInput {
  filter: RequestStateFilter!
  set: RequestStatePatch
  remove: RequestStatePatch
}

type UpdateRequestStatePayload {
  requestState(
    filter: RequestStateFilter
    order: RequestStateOrder
    first: Int
    offset: Int
  ): [RequestState]
  numUids: Int
}

input UpdateRoleInput {
  filter: RoleFilter!
  set: RolePatch
  remove: RolePatch
}

type UpdateRolePayload {
  role(filter: RoleFilter, order: RoleOrder, first: Int, offset: Int): [Role]
  numUids: Int
}

input UpdateSegmentDependencyInput {
  filter: SegmentDependencyFilter!
  set: SegmentDependencyPatch
  remove: SegmentDependencyPatch
}

type UpdateSegmentDependencyPayload {
  segmentDependency(
    filter: SegmentDependencyFilter
    order: SegmentDependencyOrder
    first: Int
    offset: Int
  ): [SegmentDependency]
  numUids: Int
}

input UpdateSegmentInvoiceSettingInput {
  filter: SegmentInvoiceSettingFilter!
  set: SegmentInvoiceSettingPatch
  remove: SegmentInvoiceSettingPatch
}

type UpdateSegmentInvoiceSettingPayload {
  segmentInvoiceSetting(
    filter: SegmentInvoiceSettingFilter
    order: SegmentInvoiceSettingOrder
    first: Int
    offset: Int
  ): [SegmentInvoiceSetting]
  numUids: Int
}

input UpdateShipmentInput {
  filter: ShipmentFilter!
  set: ShipmentPatch
  remove: ShipmentPatch
}

input UpdateShipmentItemInput {
  filter: ShipmentItemFilter!
  set: ShipmentItemPatch
  remove: ShipmentItemPatch
}

type UpdateShipmentItemPayload {
  shipmentItem(
    filter: ShipmentItemFilter
    order: ShipmentItemOrder
    first: Int
    offset: Int
  ): [ShipmentItem]
  numUids: Int
}

type UpdateShipmentPayload {
  shipment(
    filter: ShipmentFilter
    order: ShipmentOrder
    first: Int
    offset: Int
  ): [Shipment]
  numUids: Int
}

input UpdateShippingAccountInput {
  filter: ShippingAccountFilter!
  set: ShippingAccountPatch
  remove: ShippingAccountPatch
}

type UpdateShippingAccountPayload {
  shippingAccount(
    filter: ShippingAccountFilter
    order: ShippingAccountOrder
    first: Int
    offset: Int
  ): [ShippingAccount]
  numUids: Int
}

input UpdateStateEventRulesetInput {
  filter: StateEventRulesetFilter!
  set: StateEventRulesetPatch
  remove: StateEventRulesetPatch
}

type UpdateStateEventRulesetPayload {
  stateEventRuleset(
    filter: StateEventRulesetFilter
    order: StateEventRulesetOrder
    first: Int
    offset: Int
  ): [StateEventRuleset]
  numUids: Int
}

input UpdateTestResultInput {
  filter: TestResultFilter!
  set: TestResultPatch
  remove: TestResultPatch
}

type UpdateTestResultPayload {
  testResult(
    filter: TestResultFilter
    order: TestResultOrder
    first: Int
    offset: Int
  ): [TestResult]
  numUids: Int
}

input UpdateTestSpecificationInput {
  filter: TestSpecificationFilter!
  set: TestSpecificationPatch
  remove: TestSpecificationPatch
}

type UpdateTestSpecificationPayload {
  testSpecification(
    filter: TestSpecificationFilter
    order: TestSpecificationOrder
    first: Int
    offset: Int
  ): [TestSpecification]
  numUids: Int
}

input UpdateTransitionEventRulesetInput {
  filter: TransitionEventRulesetFilter!
  set: TransitionEventRulesetPatch
  remove: TransitionEventRulesetPatch
}

type UpdateTransitionEventRulesetPayload {
  transitionEventRuleset(
    filter: TransitionEventRulesetFilter
    order: TransitionEventRulesetOrder
    first: Int
    offset: Int
  ): [TransitionEventRuleset]
  numUids: Int
}

input UpdateUnitOfMeasureConversionInput {
  filter: UnitOfMeasureConversionFilter!
  set: UnitOfMeasureConversionPatch
  remove: UnitOfMeasureConversionPatch
}

type UpdateUnitOfMeasureConversionPayload {
  unitOfMeasureConversion(
    filter: UnitOfMeasureConversionFilter
    order: UnitOfMeasureConversionOrder
    first: Int
    offset: Int
  ): [UnitOfMeasureConversion]
  numUids: Int
}

input UpdateUnitOfMeasureInput {
  filter: UnitOfMeasureFilter!
  set: UnitOfMeasurePatch
  remove: UnitOfMeasurePatch
}

type UpdateUnitOfMeasurePayload {
  unitOfMeasure(
    filter: UnitOfMeasureFilter
    order: UnitOfMeasureOrder
    first: Int
    offset: Int
  ): [UnitOfMeasure]
  numUids: Int
}

input UpdateUserInput {
  filter: UserFilter!
  set: UserPatch
  remove: UserPatch
}

type UpdateUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input UpdateUserRoleInput {
  filter: UserRoleFilter!
  set: UserRolePatch
  remove: UserRolePatch
}

type UpdateUserRolePayload {
  userRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
  numUids: Int
}

input UpdateWorkCalendarDefinitionEntryInput {
  filter: WorkCalendarDefinitionEntryFilter!
  set: WorkCalendarDefinitionEntryPatch
  remove: WorkCalendarDefinitionEntryPatch
}

type UpdateWorkCalendarDefinitionEntryPayload {
  workCalendarDefinitionEntry(
    filter: WorkCalendarDefinitionEntryFilter
    order: WorkCalendarDefinitionEntryOrder
    first: Int
    offset: Int
  ): [WorkCalendarDefinitionEntry]
  numUids: Int
}

input UpdateWorkCalendarEntryInput {
  filter: WorkCalendarEntryFilter!
  set: WorkCalendarEntryPatch
  remove: WorkCalendarEntryPatch
}

type UpdateWorkCalendarEntryPayload {
  workCalendarEntry(
    filter: WorkCalendarEntryFilter
    order: WorkCalendarEntryOrder
    first: Int
    offset: Int
  ): [WorkCalendarEntry]
  numUids: Int
}

input UpdateWorkCalendarInput {
  filter: WorkCalendarFilter!
  set: WorkCalendarPatch
  remove: WorkCalendarPatch
}

type UpdateWorkCalendarPayload {
  workCalendar(
    filter: WorkCalendarFilter
    order: WorkCalendarOrder
    first: Int
    offset: Int
  ): [WorkCalendar]
  numUids: Int
}

input UpdateWorkflowConnectionInput {
  filter: WorkflowConnectionFilter!
  set: WorkflowConnectionPatch
  remove: WorkflowConnectionPatch
}

type UpdateWorkflowConnectionPayload {
  workflowConnection(
    filter: WorkflowConnectionFilter
    order: WorkflowConnectionOrder
    first: Int
    offset: Int
  ): [WorkflowConnection]
  numUids: Int
}

input UpdateWorkflowConnectionTypeInput {
  filter: WorkflowConnectionTypeFilter!
  set: WorkflowConnectionTypePatch
  remove: WorkflowConnectionTypePatch
}

type UpdateWorkflowConnectionTypePayload {
  workflowConnectionType(
    filter: WorkflowConnectionTypeFilter
    order: WorkflowConnectionTypeOrder
    first: Int
    offset: Int
  ): [WorkflowConnectionType]
  numUids: Int
}

input UpdateWorkflowInstanceInput {
  filter: WorkflowInstanceFilter!
  set: WorkflowInstancePatch
  remove: WorkflowInstancePatch
}

type UpdateWorkflowInstancePayload {
  workflowInstance(
    filter: WorkflowInstanceFilter
    order: WorkflowInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowInstance]
  numUids: Int
}

input UpdateWorkflowInstancePropertyInput {
  filter: WorkflowInstancePropertyFilter!
  set: WorkflowInstancePropertyPatch
  remove: WorkflowInstancePropertyPatch
}

type UpdateWorkflowInstancePropertyPayload {
  workflowInstanceProperty(
    filter: WorkflowInstancePropertyFilter
    order: WorkflowInstancePropertyOrder
    first: Int
    offset: Int
  ): [WorkflowInstanceProperty]
  numUids: Int
}

input UpdateWorkflowNodeEventInput {
  filter: WorkflowNodeEventFilter!
  set: WorkflowNodeEventPatch
  remove: WorkflowNodeEventPatch
}

type UpdateWorkflowNodeEventPayload {
  workflowNodeEvent(
    filter: WorkflowNodeEventFilter
    order: WorkflowNodeEventOrder
    first: Int
    offset: Int
  ): [WorkflowNodeEvent]
  numUids: Int
}

input UpdateWorkflowNodeInput {
  filter: WorkflowNodeFilter!
  set: WorkflowNodePatch
  remove: WorkflowNodePatch
}

input UpdateWorkflowNodeInstanceInput {
  filter: WorkflowNodeInstanceFilter!
  set: WorkflowNodeInstancePatch
  remove: WorkflowNodeInstancePatch
}

type UpdateWorkflowNodeInstancePayload {
  workflowNodeInstance(
    filter: WorkflowNodeInstanceFilter
    order: WorkflowNodeInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowNodeInstance]
  numUids: Int
}

type UpdateWorkflowNodePayload {
  workflowNode(
    filter: WorkflowNodeFilter
    order: WorkflowNodeOrder
    first: Int
    offset: Int
  ): [WorkflowNode]
  numUids: Int
}

input UpdateWorkflowNodeTypeInput {
  filter: WorkflowNodeTypeFilter!
  set: WorkflowNodeTypePatch
  remove: WorkflowNodeTypePatch
}

type UpdateWorkflowNodeTypePayload {
  workflowNodeType(
    filter: WorkflowNodeTypeFilter
    order: WorkflowNodeTypeOrder
    first: Int
    offset: Int
  ): [WorkflowNodeType]
  numUids: Int
}

input UpdateWorkflowPropertyInput {
  filter: WorkflowPropertyFilter!
  set: WorkflowPropertyPatch
  remove: WorkflowPropertyPatch
}

input UpdateWorkflowPropertyInstanceInput {
  filter: WorkflowPropertyInstanceFilter!
  set: WorkflowPropertyInstancePatch
  remove: WorkflowPropertyInstancePatch
}

type UpdateWorkflowPropertyInstancePayload {
  workflowPropertyInstance(
    filter: WorkflowPropertyInstanceFilter
    order: WorkflowPropertyInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowPropertyInstance]
  numUids: Int
}

type UpdateWorkflowPropertyPayload {
  workflowProperty(
    filter: WorkflowPropertyFilter
    order: WorkflowPropertyOrder
    first: Int
    offset: Int
  ): [WorkflowProperty]
  numUids: Int
}

input UpdateWorkflowPropertyValueInput {
  filter: WorkflowPropertyValueFilter!
  set: WorkflowPropertyValuePatch
  remove: WorkflowPropertyValuePatch
}

type UpdateWorkflowPropertyValuePayload {
  workflowPropertyValue(
    filter: WorkflowPropertyValueFilter
    order: WorkflowPropertyValueOrder
    first: Int
    offset: Int
  ): [WorkflowPropertyValue]
  numUids: Int
}

input UpdateWorkflowSpecificationInput {
  filter: WorkflowSpecificationFilter!
  set: WorkflowSpecificationPatch
  remove: WorkflowSpecificationPatch
}

type UpdateWorkflowSpecificationPayload {
  workflowSpecification(
    filter: WorkflowSpecificationFilter
    order: WorkflowSpecificationOrder
    first: Int
    offset: Int
  ): [WorkflowSpecification]
  numUids: Int
}

input UpdateWorkflowTaskInput {
  user: CoreUserRef!
  properties: [ExtWorkflowPropertyRef]
  task: ExtWorkflowNodeInstanceRef!
  status: String!
}

input UploadScheduleInput {
  orderNo: String
  matNo: String
  begin: DateTime
  end: DateTime
  workCenter: String
}

type UploadScheduleRowValidation {
  orderNo: String
  materialNo: String
  begin: DateTime
  end: DateTime
  workCenter: String
  errList: [String]
  isValid: Boolean
}

type UploadScheduleStaging {
  rowValidations: [UploadScheduleRowValidation]
  jobOrderStagings: [JobOrderStaging]
  operationsRequestStagings: [OperationsRequestStaging]
}

input UploadStagedScheduleInput {
  jobOrderStagings: [JobOrderStagingInput]
  operationsRequestStagings: [OperationsRequestStagingInput]
}

type UploadStagedScheduleOutput {
  jobOrders: [JobOrder]
  operationsRequest: [OperationsRequest]
}

type User {
  id: ID!
  username: String!
  name: String
  isType: UserType!
  hasRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
  tasks(
    filter: WorkflowNodeInstanceFilter
    order: WorkflowNodeInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowNodeInstance]
  isActive: Boolean
  hasRoleAggregate(filter: UserRoleFilter): UserRoleAggregateResult
  tasksAggregate(
    filter: WorkflowNodeInstanceFilter
  ): WorkflowNodeInstanceAggregateResult
}

type UserAggregateResult {
  count: Int
  usernameMin: String
  usernameMax: String
  nameMin: String
  nameMax: String
}

input UserFilter {
  id: [ID!]
  username: StringHashFilter
  isType: UserType_hash
  has: [UserHasFilter]
  and: [UserFilter]
  or: [UserFilter]
  not: UserFilter
}

enum UserHasFilter {
  username
  name
  isType
  hasRole
  tasks
  isActive
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

enum UserOrderable {
  username
  name
}

input UserPatch {
  name: String
  isType: UserType
  hasRole: [UserRoleRef]
  tasks: [WorkflowNodeInstanceRef]
  isActive: Boolean
}

input UserRef {
  id: ID
  username: String
  name: String
  isType: UserType
  hasRole: [UserRoleRef]
  tasks: [WorkflowNodeInstanceRef]
  isActive: Boolean
}

type UserRole {
  id: ID!
  role(filter: RoleFilter): Role!
  user(filter: UserFilter): User!
  responsibilities(
    filter: EquipmentFilter
    order: EquipmentOrder
    first: Int
    offset: Int
  ): [Equipment]!
  isActive: Boolean
  responsibilitiesAggregate(filter: EquipmentFilter): EquipmentAggregateResult
}

type UserRoleAggregateResult {
  count: Int
}

input UserRoleFilter {
  id: [ID!]
  has: [UserRoleHasFilter]
  and: [UserRoleFilter]
  or: [UserRoleFilter]
  not: UserRoleFilter
}

enum UserRoleHasFilter {
  role
  user
  responsibilities
  isActive
}

input UserRolePatch {
  role: RoleRef
  user: UserRef
  responsibilities: [EquipmentRef]
  isActive: Boolean
}

input UserRoleRef {
  id: ID
  role: RoleRef
  user: UserRef
  responsibilities: [EquipmentRef]
  isActive: Boolean
}

enum UserType {
  USER
  ADMIN
}

input UserType_hash {
  eq: UserType
  in: [UserType]
}

input ValidateASNInput {
  site: ExtEquipmentRef!
  asnStagingInput: [ASNStagingInput!]!
}

enum Weekday {
  MO
  TU
  WE
  TH
  FR
  SA
  SU
}

input WithinFilter {
  polygon: PolygonRef!
}

type WorkCalendar {
  id: ID!
  isActive: Boolean
  name: String!
  description: String
  definition(
    filter: WorkCalendarDefinitionEntryFilter
    order: WorkCalendarDefinitionEntryOrder
    first: Int
    offset: Int
  ): [WorkCalendarDefinitionEntry]
  entries(
    filter: WorkCalendarEntryFilter
    order: WorkCalendarEntryOrder
    first: Int
    offset: Int
  ): [WorkCalendarEntry]
  equipment(
    filter: EquipmentFilter
    order: EquipmentOrder
    first: Int
    offset: Int
  ): [Equipment]
  definitionAggregate(
    filter: WorkCalendarDefinitionEntryFilter
  ): WorkCalendarDefinitionEntryAggregateResult
  entriesAggregate(
    filter: WorkCalendarEntryFilter
  ): WorkCalendarEntryAggregateResult
  equipmentAggregate(filter: EquipmentFilter): EquipmentAggregateResult
}

type WorkCalendarAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
}

# Work Calendar domain describes the definition of shift patterns and non-working days
# The Work Calendar Definition defines the rule used to determine work calendar entries.
# It contains the recurrence time for the rule, the duration of the entry, the entry type, and properties associated with the entry.
# Standard Entry Types include Working Time and Non-Working Time. The entry may include property definitions.
# The definition uses the rrule.js library to generate calendar events, and the fields available match
# the configuration fields required by rrule.js
type WorkCalendarDefinitionEntry {
  id: ID!
  isActive: Boolean
  description: String
  hierarchyScope(filter: EquipmentFilter): Equipment
  freq: Frequency!
  startDateTime: DateTime!
  endDateTime: DateTime
  count: Int
  interval: Int
  wkst: Weekday
  byWeekDay: [Weekday]
  byMonth: [Int]
  bySetPos: [Int]
  byMonthDay: [Int]
  byYearDay: [Int]
  byWeekNo: [Int]
  byHour: [Int]
  byMinute: [Int]
  bySecond: [Int]
  duration: String
  entryType: WorkCalendarEntryType!
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  calendarEntries(
    filter: WorkCalendarEntryFilter
    order: WorkCalendarEntryOrder
    first: Int
    offset: Int
  ): [WorkCalendarEntry]
  workCalendar(filter: WorkCalendarFilter): WorkCalendar
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  calendarEntriesAggregate(
    filter: WorkCalendarEntryFilter
  ): WorkCalendarEntryAggregateResult
}

type WorkCalendarDefinitionEntryAggregateResult {
  count: Int
  descriptionMin: String
  descriptionMax: String
  startDateTimeMin: DateTime
  startDateTimeMax: DateTime
  endDateTimeMin: DateTime
  endDateTimeMax: DateTime
  countMin: Int
  countMax: Int
  countSum: Int
  countAvg: Float
  intervalMin: Int
  intervalMax: Int
  intervalSum: Int
  intervalAvg: Float
  durationMin: String
  durationMax: String
}

input WorkCalendarDefinitionEntryFilter {
  id: [ID!]
  isActive: Boolean
  has: [WorkCalendarDefinitionEntryHasFilter]
  and: [WorkCalendarDefinitionEntryFilter]
  or: [WorkCalendarDefinitionEntryFilter]
  not: WorkCalendarDefinitionEntryFilter
}

enum WorkCalendarDefinitionEntryHasFilter {
  isActive
  description
  hierarchyScope
  freq
  startDateTime
  endDateTime
  count
  interval
  wkst
  byWeekDay
  byMonth
  bySetPos
  byMonthDay
  byYearDay
  byWeekNo
  byHour
  byMinute
  bySecond
  duration
  entryType
  properties
  calendarEntries
  workCalendar
}

input WorkCalendarDefinitionEntryOrder {
  asc: WorkCalendarDefinitionEntryOrderable
  desc: WorkCalendarDefinitionEntryOrderable
  then: WorkCalendarDefinitionEntryOrder
}

enum WorkCalendarDefinitionEntryOrderable {
  description
  startDateTime
  endDateTime
  count
  interval
  duration
}

input WorkCalendarDefinitionEntryPatch {
  isActive: Boolean
  description: String
  hierarchyScope: EquipmentRef
  freq: Frequency
  startDateTime: DateTime
  endDateTime: DateTime
  count: Int
  interval: Int
  wkst: Weekday
  byWeekDay: [Weekday]
  byMonth: [Int]
  bySetPos: [Int]
  byMonthDay: [Int]
  byYearDay: [Int]
  byWeekNo: [Int]
  byHour: [Int]
  byMinute: [Int]
  bySecond: [Int]
  duration: String
  entryType: WorkCalendarEntryType
  properties: [PropertyRef]
  calendarEntries: [WorkCalendarEntryRef]
  workCalendar: WorkCalendarRef
}

input WorkCalendarDefinitionEntryRef {
  id: ID
  isActive: Boolean
  description: String
  hierarchyScope: EquipmentRef
  freq: Frequency
  startDateTime: DateTime
  endDateTime: DateTime
  count: Int
  interval: Int
  wkst: Weekday
  byWeekDay: [Weekday]
  byMonth: [Int]
  bySetPos: [Int]
  byMonthDay: [Int]
  byYearDay: [Int]
  byWeekNo: [Int]
  byHour: [Int]
  byMinute: [Int]
  bySecond: [Int]
  duration: String
  entryType: WorkCalendarEntryType
  properties: [PropertyRef]
  calendarEntries: [WorkCalendarEntryRef]
  workCalendar: WorkCalendarRef
}

type WorkCalendarEntry {
  id: ID!
  isActive: Boolean
  description: String
  definition(
    filter: WorkCalendarDefinitionEntryFilter
  ): WorkCalendarDefinitionEntry
  hierarchyScope(filter: EquipmentFilter): Equipment
  startDateTime: DateTime!
  finishDateTime: DateTime!
  entryType: WorkCalendarEntryType!
  properties(
    filter: PropertyFilter
    order: PropertyOrder
    first: Int
    offset: Int
  ): [Property]
  workCalendar(filter: WorkCalendarFilter): WorkCalendar
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult
  elapsedDuration: Int
}

type WorkCalendarEntryAggregateResult {
  count: Int
  descriptionMin: String
  descriptionMax: String
  startDateTimeMin: DateTime
  startDateTimeMax: DateTime
  finishDateTimeMin: DateTime
  finishDateTimeMax: DateTime
}

input WorkCalendarEntryFilter {
  id: [ID!]
  isActive: Boolean
  startDateTime: DateTimeFilter
  finishDateTime: DateTimeFilter
  entryType: WorkCalendarEntryType_hash
  has: [WorkCalendarEntryHasFilter]
  and: [WorkCalendarEntryFilter]
  or: [WorkCalendarEntryFilter]
  not: WorkCalendarEntryFilter
}

enum WorkCalendarEntryHasFilter {
  isActive
  description
  definition
  hierarchyScope
  startDateTime
  finishDateTime
  entryType
  properties
  workCalendar
}

input WorkCalendarEntryOrder {
  asc: WorkCalendarEntryOrderable
  desc: WorkCalendarEntryOrderable
  then: WorkCalendarEntryOrder
}

enum WorkCalendarEntryOrderable {
  description
  startDateTime
  finishDateTime
}

input WorkCalendarEntryPatch {
  isActive: Boolean
  description: String
  definition: WorkCalendarDefinitionEntryRef
  hierarchyScope: EquipmentRef
  startDateTime: DateTime
  finishDateTime: DateTime
  entryType: WorkCalendarEntryType
  properties: [PropertyRef]
  workCalendar: WorkCalendarRef
}

input WorkCalendarEntryRef {
  id: ID
  isActive: Boolean
  description: String
  definition: WorkCalendarDefinitionEntryRef
  hierarchyScope: EquipmentRef
  startDateTime: DateTime
  finishDateTime: DateTime
  entryType: WorkCalendarEntryType
  properties: [PropertyRef]
  workCalendar: WorkCalendarRef
}

enum WorkCalendarEntryType {
  PlannedBusyTime
  PlannedDowntime
  PlannedShutdown
}

input WorkCalendarEntryType_hash {
  eq: WorkCalendarEntryType
  in: [WorkCalendarEntryType]
}

input WorkCalendarFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  has: [WorkCalendarHasFilter]
  and: [WorkCalendarFilter]
  or: [WorkCalendarFilter]
  not: WorkCalendarFilter
}

enum WorkCalendarHasFilter {
  isActive
  name
  description
  definition
  entries
  equipment
}

input WorkCalendarOrder {
  asc: WorkCalendarOrderable
  desc: WorkCalendarOrderable
  then: WorkCalendarOrder
}

enum WorkCalendarOrderable {
  name
  description
}

input WorkCalendarPatch {
  isActive: Boolean
  description: String
  definition: [WorkCalendarDefinitionEntryRef]
  entries: [WorkCalendarEntryRef]
  equipment: [EquipmentRef]
}

input WorkCalendarRef {
  id: ID
  isActive: Boolean
  name: String
  description: String
  definition: [WorkCalendarDefinitionEntryRef]
  entries: [WorkCalendarEntryRef]
  equipment: [EquipmentRef]
}

type WorkflowConnection {
  id: ID!
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  modifiedBy(filter: UserFilter): User
  connectionType(filter: WorkflowConnectionTypeFilter): WorkflowConnectionType!
  workflowSpecification(
    filter: WorkflowSpecificationFilter
  ): WorkflowSpecification!
  from(filter: WorkflowNodeFilter): WorkflowNode!
  to(filter: WorkflowNodeFilter): WorkflowNode!
  condition: String
  properties(
    filter: WorkflowPropertyFilter
    order: WorkflowPropertyOrder
    first: Int
    offset: Int
  ): [WorkflowProperty]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  propertiesAggregate(
    filter: WorkflowPropertyFilter
  ): WorkflowPropertyAggregateResult
}

type WorkflowConnectionAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  conditionMin: String
  conditionMax: String
}

input WorkflowConnectionFilter {
  id: [ID!]
  isActive: Boolean
  has: [WorkflowConnectionHasFilter]
  and: [WorkflowConnectionFilter]
  or: [WorkflowConnectionFilter]
  not: WorkflowConnectionFilter
}

enum WorkflowConnectionHasFilter {
  access
  isActive
  createdDateTime
  createdBy
  modifiedDateTime
  modifiedBy
  connectionType
  workflowSpecification
  from
  to
  condition
  properties
}

input WorkflowConnectionOrder {
  asc: WorkflowConnectionOrderable
  desc: WorkflowConnectionOrderable
  then: WorkflowConnectionOrder
}

enum WorkflowConnectionOrderable {
  createdDateTime
  modifiedDateTime
  condition
}

input WorkflowConnectionPatch {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  connectionType: WorkflowConnectionTypeRef
  workflowSpecification: WorkflowSpecificationRef
  from: WorkflowNodeRef
  to: WorkflowNodeRef
  condition: String
  properties: [WorkflowPropertyRef]
}

input WorkflowConnectionRef {
  id: ID
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  connectionType: WorkflowConnectionTypeRef
  workflowSpecification: WorkflowSpecificationRef
  from: WorkflowNodeRef
  to: WorkflowNodeRef
  condition: String
  properties: [WorkflowPropertyRef]
}

type WorkflowConnectionType {
  id: ID!
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  modifiedBy(filter: UserFilter): User
  name: String!
  description: String!
  connections(
    filter: WorkflowConnectionFilter
    order: WorkflowConnectionOrder
    first: Int
    offset: Int
  ): [WorkflowConnection]
  properties(
    filter: WorkflowPropertyFilter
    order: WorkflowPropertyOrder
    first: Int
    offset: Int
  ): [WorkflowProperty]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  connectionsAggregate(
    filter: WorkflowConnectionFilter
  ): WorkflowConnectionAggregateResult
  propertiesAggregate(
    filter: WorkflowPropertyFilter
  ): WorkflowPropertyAggregateResult
}

type WorkflowConnectionTypeAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
}

input WorkflowConnectionTypeFilter {
  id: [ID!]
  isActive: Boolean
  has: [WorkflowConnectionTypeHasFilter]
  and: [WorkflowConnectionTypeFilter]
  or: [WorkflowConnectionTypeFilter]
  not: WorkflowConnectionTypeFilter
}

enum WorkflowConnectionTypeHasFilter {
  access
  isActive
  createdDateTime
  createdBy
  modifiedDateTime
  modifiedBy
  name
  description
  connections
  properties
}

input WorkflowConnectionTypeOrder {
  asc: WorkflowConnectionTypeOrderable
  desc: WorkflowConnectionTypeOrderable
  then: WorkflowConnectionTypeOrder
}

enum WorkflowConnectionTypeOrderable {
  createdDateTime
  modifiedDateTime
  name
  description
}

input WorkflowConnectionTypePatch {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  name: String
  description: String
  connections: [WorkflowConnectionRef]
  properties: [WorkflowPropertyRef]
}

input WorkflowConnectionTypeRef {
  id: ID
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  name: String
  description: String
  connections: [WorkflowConnectionRef]
  properties: [WorkflowPropertyRef]
}

type WorkflowInstance {
  id: ID!
  createdDateTime: DateTime
  createdBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  modifiedBy(filter: UserFilter): User
  status: WorkflowNodeStatus
  workflowSpecification(
    filter: WorkflowSpecificationFilter
  ): WorkflowSpecification
  equipment(filter: EquipmentFilter): Equipment
  parent(filter: WorkflowInstanceFilter): WorkflowInstance
  children(
    filter: WorkflowInstanceFilter
    order: WorkflowInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowInstance]
  nodeInstances(
    filter: WorkflowNodeInstanceFilter
    order: WorkflowNodeInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowNodeInstance]
  propertyInstances(
    filter: WorkflowPropertyInstanceFilter
    order: WorkflowPropertyInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowPropertyInstance]
  properties(
    filter: WorkflowInstancePropertyFilter
    order: WorkflowInstancePropertyOrder
    first: Int
    offset: Int
  ): [WorkflowInstanceProperty]
  orderLines(
    filter: OrderLineFilter
    order: OrderLineOrder
    first: Int
    offset: Int
  ): [OrderLine]
  childrenAggregate(
    filter: WorkflowInstanceFilter
  ): WorkflowInstanceAggregateResult
  nodeInstancesAggregate(
    filter: WorkflowNodeInstanceFilter
  ): WorkflowNodeInstanceAggregateResult
  propertyInstancesAggregate(
    filter: WorkflowPropertyInstanceFilter
  ): WorkflowPropertyInstanceAggregateResult
  propertiesAggregate(
    filter: WorkflowInstancePropertyFilter
  ): WorkflowInstancePropertyAggregateResult
  orderLinesAggregate(filter: OrderLineFilter): OrderLineAggregateResult
}

type WorkflowInstanceAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
}

input WorkflowInstanceFilter {
  id: [ID!]
  createdDateTime: DateTimeFilter
  status: WorkflowNodeStatus_hash
  has: [WorkflowInstanceHasFilter]
  and: [WorkflowInstanceFilter]
  or: [WorkflowInstanceFilter]
  not: WorkflowInstanceFilter
}

enum WorkflowInstanceHasFilter {
  createdDateTime
  createdBy
  modifiedDateTime
  modifiedBy
  status
  workflowSpecification
  equipment
  parent
  children
  nodeInstances
  propertyInstances
  properties
  orderLines
}

input WorkflowInstanceOrder {
  asc: WorkflowInstanceOrderable
  desc: WorkflowInstanceOrderable
  then: WorkflowInstanceOrder
}

enum WorkflowInstanceOrderable {
  createdDateTime
  modifiedDateTime
}

input WorkflowInstancePatch {
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  status: WorkflowNodeStatus
  workflowSpecification: WorkflowSpecificationRef
  equipment: EquipmentRef
  parent: WorkflowInstanceRef
  children: [WorkflowInstanceRef]
  nodeInstances: [WorkflowNodeInstanceRef]
  propertyInstances: [WorkflowPropertyInstanceRef]
  properties: [WorkflowInstancePropertyRef]
  orderLines: [OrderLineRef]
}

type WorkflowInstanceProperty {
  id: ID!
  key: String!
  workflowInstance(filter: WorkflowInstanceFilter): WorkflowInstance
  name: String!
  values(
    filter: WorkflowPropertyValueFilter
    order: WorkflowPropertyValueOrder
    first: Int
    offset: Int
  ): [WorkflowPropertyValue]
  valuesAggregate(
    filter: WorkflowPropertyValueFilter
  ): WorkflowPropertyValueAggregateResult
}

type WorkflowInstancePropertyAggregateResult {
  count: Int
  keyMin: String
  keyMax: String
  nameMin: String
  nameMax: String
}

input WorkflowInstancePropertyFilter {
  id: [ID!]
  key: StringHashFilter
  has: [WorkflowInstancePropertyHasFilter]
  and: [WorkflowInstancePropertyFilter]
  or: [WorkflowInstancePropertyFilter]
  not: WorkflowInstancePropertyFilter
}

enum WorkflowInstancePropertyHasFilter {
  key
  workflowInstance
  name
  values
}

input WorkflowInstancePropertyOrder {
  asc: WorkflowInstancePropertyOrderable
  desc: WorkflowInstancePropertyOrderable
  then: WorkflowInstancePropertyOrder
}

enum WorkflowInstancePropertyOrderable {
  key
  name
}

input WorkflowInstancePropertyPatch {
  workflowInstance: WorkflowInstanceRef
  name: String
  values: [WorkflowPropertyValueRef]
}

input WorkflowInstancePropertyRef {
  id: ID
  key: String
  workflowInstance: WorkflowInstanceRef
  name: String
  values: [WorkflowPropertyValueRef]
}

input WorkflowInstanceRef {
  id: ID
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  status: WorkflowNodeStatus
  workflowSpecification: WorkflowSpecificationRef
  equipment: EquipmentRef
  parent: WorkflowInstanceRef
  children: [WorkflowInstanceRef]
  nodeInstances: [WorkflowNodeInstanceRef]
  propertyInstances: [WorkflowPropertyInstanceRef]
  properties: [WorkflowInstancePropertyRef]
  orderLines: [OrderLineRef]
}

type WorkflowNode {
  id: ID!
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  modifiedBy(filter: UserFilter): User
  name: String!
  description: String!
  uiComponent: String
  form(filter: FormFilter): Form
  role(filter: RoleFilter): Role
  nodeType(filter: WorkflowNodeTypeFilter): WorkflowNodeType!
  inflows(
    filter: WorkflowConnectionFilter
    order: WorkflowConnectionOrder
    first: Int
    offset: Int
  ): [WorkflowConnection]
  outflows(
    filter: WorkflowConnectionFilter
    order: WorkflowConnectionOrder
    first: Int
    offset: Int
  ): [WorkflowConnection]
  workflowSpecification(
    filter: WorkflowSpecificationFilter
  ): WorkflowSpecification!
  properties(
    filter: WorkflowPropertyFilter
    order: WorkflowPropertyOrder
    first: Int
    offset: Int
  ): [WorkflowProperty]
  nodeInstances(
    filter: WorkflowNodeInstanceFilter
    order: WorkflowNodeInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowNodeInstance]
  positionX: Int
  positionY: Int
  width: Int
  height: Int
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  inflowsAggregate(
    filter: WorkflowConnectionFilter
  ): WorkflowConnectionAggregateResult
  outflowsAggregate(
    filter: WorkflowConnectionFilter
  ): WorkflowConnectionAggregateResult
  propertiesAggregate(
    filter: WorkflowPropertyFilter
  ): WorkflowPropertyAggregateResult
  nodeInstancesAggregate(
    filter: WorkflowNodeInstanceFilter
  ): WorkflowNodeInstanceAggregateResult
}

type WorkflowNodeAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
  uiComponentMin: String
  uiComponentMax: String
  positionXMin: Int
  positionXMax: Int
  positionXSum: Int
  positionXAvg: Float
  positionYMin: Int
  positionYMax: Int
  positionYSum: Int
  positionYAvg: Float
  widthMin: Int
  widthMax: Int
  widthSum: Int
  widthAvg: Float
  heightMin: Int
  heightMax: Int
  heightSum: Int
  heightAvg: Float
}

enum WorkflowNodeClass {
  EVENT_START
  EVENT_END
  EVENT_INTERMEDIATE
  GATEWAY
  TASK_USER
  TASK_SYSTEM
  SUBPROCESS
}

type WorkflowNodeEvent {
  id: ID!
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  modifiedBy(filter: UserFilter): User
  nodeInstance(filter: WorkflowNodeInstanceFilter): WorkflowNodeInstance
  previous(filter: WorkflowNodeEventFilter): WorkflowNodeEvent
  next(filter: WorkflowNodeEventFilter): WorkflowNodeEvent
  status: WorkflowNodeStatus
  isProcessed: Boolean
  value: String
  accessAggregate(filter: ACLFilter): ACLAggregateResult
}

type WorkflowNodeEventAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  valueMin: String
  valueMax: String
}

input WorkflowNodeEventFilter {
  id: [ID!]
  isActive: Boolean
  createdDateTime: DateTimeFilter
  status: WorkflowNodeStatus_hash
  isProcessed: Boolean
  has: [WorkflowNodeEventHasFilter]
  and: [WorkflowNodeEventFilter]
  or: [WorkflowNodeEventFilter]
  not: WorkflowNodeEventFilter
}

enum WorkflowNodeEventHasFilter {
  access
  isActive
  createdDateTime
  createdBy
  modifiedDateTime
  modifiedBy
  nodeInstance
  previous
  next
  status
  isProcessed
  value
}

input WorkflowNodeEventOrder {
  asc: WorkflowNodeEventOrderable
  desc: WorkflowNodeEventOrderable
  then: WorkflowNodeEventOrder
}

enum WorkflowNodeEventOrderable {
  createdDateTime
  modifiedDateTime
  value
}

input WorkflowNodeEventPatch {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  nodeInstance: WorkflowNodeInstanceRef
  previous: WorkflowNodeEventRef
  next: WorkflowNodeEventRef
  status: WorkflowNodeStatus
  isProcessed: Boolean
  value: String
}

input WorkflowNodeEventRef {
  id: ID
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  nodeInstance: WorkflowNodeInstanceRef
  previous: WorkflowNodeEventRef
  next: WorkflowNodeEventRef
  status: WorkflowNodeStatus
  isProcessed: Boolean
  value: String
}

input WorkflowNodeFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  has: [WorkflowNodeHasFilter]
  and: [WorkflowNodeFilter]
  or: [WorkflowNodeFilter]
  not: WorkflowNodeFilter
}

enum WorkflowNodeHasFilter {
  access
  isActive
  createdDateTime
  createdBy
  modifiedDateTime
  modifiedBy
  name
  description
  uiComponent
  form
  role
  nodeType
  inflows
  outflows
  workflowSpecification
  properties
  nodeInstances
  positionX
  positionY
  width
  height
}

type WorkflowNodeInstance {
  id: ID!
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  modifiedBy(filter: UserFilter): User
  status: WorkflowNodeStatus
  assignedUser(filter: UserFilter): User
  workflowInstance(filter: WorkflowInstanceFilter): WorkflowInstance!
  node(filter: WorkflowNodeFilter): WorkflowNode!
  events(
    filter: WorkflowNodeEventFilter
    order: WorkflowNodeEventOrder
    first: Int
    offset: Int
  ): [WorkflowNodeEvent]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  eventsAggregate(
    filter: WorkflowNodeEventFilter
  ): WorkflowNodeEventAggregateResult
  duration: Int
}

type WorkflowNodeInstanceAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
}

input WorkflowNodeInstanceFilter {
  id: [ID!]
  isActive: Boolean
  createdDateTime: DateTimeFilter
  status: WorkflowNodeStatus_hash
  has: [WorkflowNodeInstanceHasFilter]
  and: [WorkflowNodeInstanceFilter]
  or: [WorkflowNodeInstanceFilter]
  not: WorkflowNodeInstanceFilter
}

enum WorkflowNodeInstanceHasFilter {
  access
  isActive
  createdDateTime
  createdBy
  modifiedDateTime
  modifiedBy
  status
  assignedUser
  workflowInstance
  node
  events
}

input WorkflowNodeInstanceOrder {
  asc: WorkflowNodeInstanceOrderable
  desc: WorkflowNodeInstanceOrderable
  then: WorkflowNodeInstanceOrder
}

enum WorkflowNodeInstanceOrderable {
  createdDateTime
  modifiedDateTime
}

input WorkflowNodeInstancePatch {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  status: WorkflowNodeStatus
  assignedUser: UserRef
  workflowInstance: WorkflowInstanceRef
  node: WorkflowNodeRef
  events: [WorkflowNodeEventRef]
}

input WorkflowNodeInstanceRef {
  id: ID
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  status: WorkflowNodeStatus
  assignedUser: UserRef
  workflowInstance: WorkflowInstanceRef
  node: WorkflowNodeRef
  events: [WorkflowNodeEventRef]
}

input WorkflowNodeOrder {
  asc: WorkflowNodeOrderable
  desc: WorkflowNodeOrderable
  then: WorkflowNodeOrder
}

enum WorkflowNodeOrderable {
  createdDateTime
  modifiedDateTime
  name
  description
  uiComponent
  positionX
  positionY
  width
  height
}

input WorkflowNodePatch {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  name: String
  description: String
  uiComponent: String
  form: FormRef
  role: RoleRef
  nodeType: WorkflowNodeTypeRef
  inflows: [WorkflowConnectionRef]
  outflows: [WorkflowConnectionRef]
  workflowSpecification: WorkflowSpecificationRef
  properties: [WorkflowPropertyRef]
  nodeInstances: [WorkflowNodeInstanceRef]
  positionX: Int
  positionY: Int
  width: Int
  height: Int
}

input WorkflowNodeRef {
  id: ID
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  name: String
  description: String
  uiComponent: String
  form: FormRef
  role: RoleRef
  nodeType: WorkflowNodeTypeRef
  inflows: [WorkflowConnectionRef]
  outflows: [WorkflowConnectionRef]
  workflowSpecification: WorkflowSpecificationRef
  properties: [WorkflowPropertyRef]
  nodeInstances: [WorkflowNodeInstanceRef]
  positionX: Int
  positionY: Int
  width: Int
  height: Int
}

enum WorkflowNodeStatus {
  CREATED
  CLAIMED
  STARTED
  PAUSED
  COMPLETED
}

input WorkflowNodeStatus_hash {
  eq: WorkflowNodeStatus
  in: [WorkflowNodeStatus]
}

type WorkflowNodeType {
  id: ID!
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  modifiedBy(filter: UserFilter): User
  name: String!
  description: String!
  nodeClass: WorkflowNodeClass!
  nodes(
    filter: WorkflowNodeFilter
    order: WorkflowNodeOrder
    first: Int
    offset: Int
  ): [WorkflowNode]
  properties(
    filter: WorkflowPropertyFilter
    order: WorkflowPropertyOrder
    first: Int
    offset: Int
  ): [WorkflowProperty]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  nodesAggregate(filter: WorkflowNodeFilter): WorkflowNodeAggregateResult
  propertiesAggregate(
    filter: WorkflowPropertyFilter
  ): WorkflowPropertyAggregateResult
}

type WorkflowNodeTypeAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
}

input WorkflowNodeTypeFilter {
  id: [ID!]
  isActive: Boolean
  has: [WorkflowNodeTypeHasFilter]
  and: [WorkflowNodeTypeFilter]
  or: [WorkflowNodeTypeFilter]
  not: WorkflowNodeTypeFilter
}

enum WorkflowNodeTypeHasFilter {
  access
  isActive
  createdDateTime
  createdBy
  modifiedDateTime
  modifiedBy
  name
  description
  nodeClass
  nodes
  properties
}

input WorkflowNodeTypeOrder {
  asc: WorkflowNodeTypeOrderable
  desc: WorkflowNodeTypeOrderable
  then: WorkflowNodeTypeOrder
}

enum WorkflowNodeTypeOrderable {
  createdDateTime
  modifiedDateTime
  name
  description
}

input WorkflowNodeTypePatch {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  name: String
  description: String
  nodeClass: WorkflowNodeClass
  nodes: [WorkflowNodeRef]
  properties: [WorkflowPropertyRef]
}

input WorkflowNodeTypeRef {
  id: ID
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  name: String
  description: String
  nodeClass: WorkflowNodeClass
  nodes: [WorkflowNodeRef]
  properties: [WorkflowPropertyRef]
}

type WorkflowProperty {
  id: ID!
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  modifiedBy(filter: UserFilter): User
  propertyType: WorkflowPropertyType!
  name: String!
  description: String!
  definedBy(filter: WorkflowPropertyFilter): WorkflowProperty
  dataType: DataType
  unitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure
  value: String
  nodeType(filter: WorkflowNodeTypeFilter): WorkflowNodeType
  node(filter: WorkflowNodeFilter): WorkflowNode
  connectionType(filter: WorkflowConnectionTypeFilter): WorkflowConnectionType
  connection(filter: WorkflowConnectionFilter): WorkflowConnection
  instances(
    filter: WorkflowPropertyInstanceFilter
    order: WorkflowPropertyInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowPropertyInstance]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  instancesAggregate(
    filter: WorkflowPropertyInstanceFilter
  ): WorkflowPropertyInstanceAggregateResult
}

type WorkflowPropertyAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
  valueMin: String
  valueMax: String
}

input WorkflowPropertyFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  description: StringHashFilter
  has: [WorkflowPropertyHasFilter]
  and: [WorkflowPropertyFilter]
  or: [WorkflowPropertyFilter]
  not: WorkflowPropertyFilter
}

enum WorkflowPropertyHasFilter {
  access
  isActive
  createdDateTime
  createdBy
  modifiedDateTime
  modifiedBy
  propertyType
  name
  description
  definedBy
  dataType
  unitOfMeasure
  value
  nodeType
  node
  connectionType
  connection
  instances
}

type WorkflowPropertyInstance {
  id: ID!
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  modifiedBy(filter: UserFilter): User
  workflowInstance(filter: WorkflowInstanceFilter): WorkflowInstance
  workflowProperty(filter: WorkflowPropertyFilter): WorkflowProperty
  values(
    filter: WorkflowPropertyValueFilter
    order: WorkflowPropertyValueOrder
    first: Int
    offset: Int
  ): [WorkflowPropertyValue]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  valuesAggregate(
    filter: WorkflowPropertyValueFilter
  ): WorkflowPropertyValueAggregateResult
}

type WorkflowPropertyInstanceAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
}

input WorkflowPropertyInstanceFilter {
  id: [ID!]
  isActive: Boolean
  has: [WorkflowPropertyInstanceHasFilter]
  and: [WorkflowPropertyInstanceFilter]
  or: [WorkflowPropertyInstanceFilter]
  not: WorkflowPropertyInstanceFilter
}

enum WorkflowPropertyInstanceHasFilter {
  access
  isActive
  createdDateTime
  createdBy
  modifiedDateTime
  modifiedBy
  workflowInstance
  workflowProperty
  values
}

input WorkflowPropertyInstanceOrder {
  asc: WorkflowPropertyInstanceOrderable
  desc: WorkflowPropertyInstanceOrderable
  then: WorkflowPropertyInstanceOrder
}

enum WorkflowPropertyInstanceOrderable {
  createdDateTime
  modifiedDateTime
}

input WorkflowPropertyInstancePatch {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  workflowInstance: WorkflowInstanceRef
  workflowProperty: WorkflowPropertyRef
  values: [WorkflowPropertyValueRef]
}

input WorkflowPropertyInstanceRef {
  id: ID
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  workflowInstance: WorkflowInstanceRef
  workflowProperty: WorkflowPropertyRef
  values: [WorkflowPropertyValueRef]
}

input WorkflowPropertyOrder {
  asc: WorkflowPropertyOrderable
  desc: WorkflowPropertyOrderable
  then: WorkflowPropertyOrder
}

enum WorkflowPropertyOrderable {
  createdDateTime
  modifiedDateTime
  name
  description
  value
}

input WorkflowPropertyPatch {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  propertyType: WorkflowPropertyType
  name: String
  description: String
  definedBy: WorkflowPropertyRef
  dataType: DataType
  unitOfMeasure: UnitOfMeasureRef
  value: String
  nodeType: WorkflowNodeTypeRef
  node: WorkflowNodeRef
  connectionType: WorkflowConnectionTypeRef
  connection: WorkflowConnectionRef
  instances: [WorkflowPropertyInstanceRef]
}

input WorkflowPropertyRef {
  id: ID
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  propertyType: WorkflowPropertyType
  name: String
  description: String
  definedBy: WorkflowPropertyRef
  dataType: DataType
  unitOfMeasure: UnitOfMeasureRef
  value: String
  nodeType: WorkflowNodeTypeRef
  node: WorkflowNodeRef
  connectionType: WorkflowConnectionTypeRef
  connection: WorkflowConnectionRef
  instances: [WorkflowPropertyInstanceRef]
}

enum WorkflowPropertyType {
  STATIC
  CONFIG
  VARIABLE
}

type WorkflowPropertyValue {
  id: ID!
  createdDateTime: DateTime
  createdBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  modifiedBy(filter: UserFilter): User
  propertyInstance(
    filter: WorkflowPropertyInstanceFilter
  ): WorkflowPropertyInstance!
  value: String
  previous(filter: WorkflowPropertyValueFilter): WorkflowPropertyValue
  next(filter: WorkflowPropertyValueFilter): WorkflowPropertyValue
}

type WorkflowPropertyValueAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  valueMin: String
  valueMax: String
}

input WorkflowPropertyValueFilter {
  id: [ID!]
  has: [WorkflowPropertyValueHasFilter]
  and: [WorkflowPropertyValueFilter]
  or: [WorkflowPropertyValueFilter]
  not: WorkflowPropertyValueFilter
}

enum WorkflowPropertyValueHasFilter {
  createdDateTime
  createdBy
  modifiedDateTime
  modifiedBy
  propertyInstance
  value
  previous
  next
}

input WorkflowPropertyValueOrder {
  asc: WorkflowPropertyValueOrderable
  desc: WorkflowPropertyValueOrderable
  then: WorkflowPropertyValueOrder
}

enum WorkflowPropertyValueOrderable {
  createdDateTime
  modifiedDateTime
  value
}

input WorkflowPropertyValuePatch {
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  propertyInstance: WorkflowPropertyInstanceRef
  value: String
  previous: WorkflowPropertyValueRef
  next: WorkflowPropertyValueRef
}

input WorkflowPropertyValueRef {
  id: ID
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  propertyInstance: WorkflowPropertyInstanceRef
  value: String
  previous: WorkflowPropertyValueRef
  next: WorkflowPropertyValueRef
}

type WorkflowSpecification {
  id: ID!
  access(filter: ACLFilter, first: Int, offset: Int): [ACL]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy(filter: UserFilter): User
  modifiedDateTime: DateTime
  modifiedBy(filter: UserFilter): User
  name: String!
  description: String!
  nodes(
    filter: WorkflowNodeFilter
    order: WorkflowNodeOrder
    first: Int
    offset: Int
  ): [WorkflowNode]
  connections(
    filter: WorkflowConnectionFilter
    order: WorkflowConnectionOrder
    first: Int
    offset: Int
  ): [WorkflowConnection]
  instances(
    filter: WorkflowInstanceFilter
    order: WorkflowInstanceOrder
    first: Int
    offset: Int
  ): [WorkflowInstance]
  accessAggregate(filter: ACLFilter): ACLAggregateResult
  nodesAggregate(filter: WorkflowNodeFilter): WorkflowNodeAggregateResult
  connectionsAggregate(
    filter: WorkflowConnectionFilter
  ): WorkflowConnectionAggregateResult
  instancesAggregate(
    filter: WorkflowInstanceFilter
  ): WorkflowInstanceAggregateResult
}

type WorkflowSpecificationAggregateResult {
  count: Int
  createdDateTimeMin: DateTime
  createdDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
}

input WorkflowSpecificationFilter {
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  has: [WorkflowSpecificationHasFilter]
  and: [WorkflowSpecificationFilter]
  or: [WorkflowSpecificationFilter]
  not: WorkflowSpecificationFilter
}

enum WorkflowSpecificationHasFilter {
  access
  isActive
  createdDateTime
  createdBy
  modifiedDateTime
  modifiedBy
  name
  description
  nodes
  connections
  instances
}

input WorkflowSpecificationOrder {
  asc: WorkflowSpecificationOrderable
  desc: WorkflowSpecificationOrderable
  then: WorkflowSpecificationOrder
}

enum WorkflowSpecificationOrderable {
  createdDateTime
  modifiedDateTime
  name
  description
}

input WorkflowSpecificationPatch {
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  name: String
  description: String
  nodes: [WorkflowNodeRef]
  connections: [WorkflowConnectionRef]
  instances: [WorkflowInstanceRef]
}

input WorkflowSpecificationRef {
  id: ID
  access: [ACLRef]
  isActive: Boolean
  createdDateTime: DateTime
  createdBy: UserRef
  modifiedDateTime: DateTime
  modifiedBy: UserRef
  name: String
  description: String
  nodes: [WorkflowNodeRef]
  connections: [WorkflowConnectionRef]
  instances: [WorkflowInstanceRef]
}

# An identification of the resources and workflow required to perform a specified unit of work
# shall be defined as a work definition. The work definition may apply to production, maintenance, quality and inventory
# activities.
enum WorkType {
  Production
  Maintenance
  Quality
  Inventory
  Mixed
}

input WorkType_hash {
  eq: WorkType
  in: [WorkType]
}
